# Start Forms
  --SiteController: criar o model request(post) validate, view
  --Model: Formulario de Registro, model rules
  --View: Formulário(widgets)
  --View: Resposta do formulário

# Banco de Dados, ActiveRecord(sintaxe tipo eloquent(laravel))
  --Criar ActiveRecord (models), [Customer]
  --Checar conexão (config.db)
  ----querybuilder https://www.yiiframework.com/doc/guide/2.0/pt-br/db-query-builder#query-methods

  DB Browser SQLITE
  --schema/table
  --model: pais
  --PaisController: active record query's
  --'dsn' => 'sqlite:teste.sqlite', (cria banco em web->testesql)
  --view: pasta da action e index, view render db

# Gerando código com GII (https://www.yiiframework.com/doc/guide/2.0/pt-br/start-gii)
  --Models 
  --generate/overwrite - tableName - ModelClassName (pais-Pais), ctrl+c ou overwrite.

  --generate crud
  Model Class
    app\models\Pais
  Search Model Class
    app\models\PaisSearch
  Controller Class
    app\controllers\PaisController
  View Path
    @app/views/pais
  
  --criar namespace do models, o PaisSearch é a nova do crud, adicona o controller
    e a view, já criamos o controller model e view, e precisamos dar overwrite, 
    para criar os códigos template com support ao crud.

  urlparam: ?r=pais/index.
  urlparam-pais(update/delete): ?r=pais%2Fview&id=SS

# Seguindo em Frente (https://www.yiiframework.com/doc/guide/2.0/pt-br/start-looking-ahead)
- Docs (classes) - https://www.yiiframework.com/doc/api/2.0/index
- Wiki (forum/stack somente o yii2) - https://www.yiiframework.com/wiki?tag=yii2
- O Guia - https://www.yiiframework.com/doc/guide/2.0/pt-br
- Plugins/Extensões do yii2 - https://www.yiiframework.com/extensions

# Estrutura da Aplicação
- https://www.yiiframework.com/doc/guide/2.0/pt-br/structure-overview
-- Defined(const) em scripts de entrada, (modo web, console)
  EXEMPLO DO SCRIPT DE entrada
    require __DIR__ . '/../vendor/autoload.php';
    require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

    // carrega a configuração da aplicação
    $config = require __DIR__ . '/../config/web.php';

    // instancia e configura a aplicação
    (new yii\web\Application($config))->run();
  
  temos este arquivo rodando nosso basic app, temos as constantes/autoloads/vendor.

  Propiedades da App, required.
  id;basePath, 
    id geralmente ja vem um, a nao ser que tenha mais de uma app.
    basePath, caminho da app, do codfont, podemos criar aliases(atalhos), base path(@app)

    Exemplo de ALIASES
    [
      [
        'aliases' => [
          '@name1' => 'path/to/path1',
          '@name2' => 'path/to/path2',
      ],
    ]

  bootstrap da app
  -array de componentes, modulos, regras da app, que pode ser carregado junto com a app.
    exemplo do debug e o gii

  outras propriedades:
  --catchAll, pega todas requisições web para mostrar.
  --components - consegue armazenar lista de components, como cache/users/autologin etc
    tipo um bootstraping
  --ControllerMap, pega o controller e configura algumas coisas, como csrf token.
  --ControllerNamespace, como nome ja diz, consegue modificar o namespace do controller.
  --language, muda linguangem para o usuario final, padrão. 
  --modules, modules e configurações, ex: da config da database.
  --names/--params/--sourceLanguage/--timeZone/--version/--charset
    --defaultRoute/--extensions(plugins)
  
  --layout, layout da app, headers/footers etc, /--layoutPath
  --runtimePath, arquivos temporários/cache
  --viewpath/--vendorPath

  EVENTOS DA APLICAÇÃO
  [
    'on beforeRequest' => function ($event) {
        // ...
    },
  ]

  EVENT_BEFORE_REQUEST (antes do post)
  EVENT_AFTER_REQUEST  (depois do post)
  EVENT_BEFORE_ACTION   (antes de executar cada action controller)
  EVENT_AFTER_ACTION    (depois de executar cada action controller)

  LIFE CICLE
  -Script de entrada, carrega as config como array
  
  -- cria uma nova instancia da app
  --- preInit() config alta prioridade como o basePath
  --- config das propriedades da app
  --- init() chama o bootstrap() roda os components de inicialização

  ---- yii2 app run..
  ---- dispara os eventos, os before
  ---- resolve as rotas, params, model, controllers actions
  ---- dispara os eventos after 
  ---- envia resposta pro final user.

  ----- status code e completa o processamento.

  MVC
  Controllers/Rotas
  --Rotas é baseado na action e nos controllers
  Segue alguns exemplos, assumindo que o namespace do controller tenha por 
  padrão o valor app\controllers:

  article torna-se app\controllers\ArticleController;
  post-comment torna-se app\controllers\PostCommentController;
  admin/post-comment torna-se app\controllers\admin\PostCommentController;
  adminPanels/post-comment torna-se app\controllers\adminPanels\PostCommentController.

  também é possível mapear os controllers, para seguir um padrão, quando vem de crosssite.
  [
    'controllerMap' => [
        // declara o controller "account" usando um nome de classe
        'account' => 'app\controllers\UserController',

        // declara o controller "article" usando uma configuração em array
        'article' => [
            'class' => 'app\controllers\PostController',
            'enableCsrfValidation' => false,
        ],
    ],
  ]

  Segue algumas boas práticas em destaque. Os controllers:

  podem acessar os dados de uma requisição;

  podem chamar os métodos dos models e outros componentes de serviço com dados 
  da requisição;
  podem usar as views para compor as respostas;

  NÃO devem processar os dados da requisição - isto deve ser feito na 
  camada model (modelo);

  devem evitar inserir códigos HTML ou outro código de apresentação - é 
  melhor que sejam feitos nas views.

  Models
  -temos nossos request;rules/validations/atributos, nossa conexão com algumas
    tabela do db que passa pro controller dps como variável/const.

  atribuição em massa, podemos fazer apenas com atributos seguros(safe)
  public function rules()
  {
      return [
          [['title', 'description'], 'safe'],
      ];
  }

  não seguros podemos colocar !
  public function scenarios()
  {
      return [
          'login' => ['username', 'password', '!secret'],
      ];
  }

  na exportação de dados, são convertidos em arrays, porém podemos especificar depois
  para retornar um outro tipo de dado.

  boas praticas no model
  Em resumo, os models (modelos):

  podem conter atributos para representar os dados de negócio;
  podem conter regras de validação para garantir a validade e integridade dos dados;
  podem conter métodos para implementar lógicas de negócio;
  NÃO devem acessar diretamente as requisições, sessões ou quaisquer dados do ambiente do usuário. Os models (modelos) devem receber estes dados a partir dos controllers (controladores);
  devem evitar inserir HTML ou outros códigos de apresentação – isto deve ser feito nas views (visões);
  devem evitar ter muitos cenários em um único model (modelo).

  Views 
  --Segurança, sobre Html::encode, codifica o nome de usuario antes de exibi-lo

      <?php
      use yii\helpers\Html;
      ?>

      <div class="username">
          <?= Html::encode($user->name) ?>
      </div>

    Exibir conteúdo html, filtrar conteudo primeiro, ele é mais lento, então é melhor
    guardar em cache, se for usar muitas vezes.

      <?php
      use yii\helpers\HtmlPurifier;
      ?>

      <div class="post">
          <?= HtmlPurifier::process($post->text) ?>
      </div>

    
    além da render() temos outros tipos de render()...

    Nos controllers, você pode chamar os seguintes métodos para renderizar as views:

    render(): renderiza uma view nomeada e aplica um layout ao resultado da renderização.
    renderPartial(): renderiza uma view nomeada sem qualquer layout.
    renderAjax(): renderiza uma view nomeada sem qualquer layout e injeta todos os arquivos JS/CSS registrados. É geralmente utilizado em respostas de requisições Web Ajax.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.
    renderContent(): renderiza um conteúdo estático que será incorporado no layout selecionado. Este método está disponível desde a versão 2.0.1.

    na renderização de widgets podemos utiliar as seguintes:
    render(): renderiza uma view nomeada.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.

    podemos renderizar uma view dentro de outra:
    render(): renderiza uma view nomeada.
    renderAjax(): renderiza uma view nomeada sem qualquer layout e injeta todos os arquivos JS/CSS registrados. É geralmente utilizado em respostas de requisições Web Ajax.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.

    <?= $this->render('_visao-geral') ?>

    renderização de outros lugares, no código
    // exibe a view "@app/views/site/license.php"
    echo \Yii::$app->view->renderFile('@app/views/site/license.php');

    Compartilhando Dados entre as Views
    O componente view fornece a propriedade params que você pode usar para compartilhar dados entre as views.

    Por exemplo, em uma view sobre, você pode ter o seguinte código que especifica o seguimento atual do "rastro de navegação" (breadcrumbs):

    $this->params['breadcrumbs'][] = 'Sobre nós';
    Em seguida, no arquivo layout, que também é uma view, você pode exibir o "rastro de navegação" (breadcrumbs) usando os dados passados pela propriedade params:

    <?= yii\widgets\Breadcrumbs::widget([
        'links' => isset($this->params['breadcrumbs']) ? $this->params['breadcrumbs'] : [],
    ]) ?>




    Exemplo de layout, header/footer - content

    <?php
      use yii\helpers\Html;

      /* @var $this yii\web\View */
      /* @var $content string */
      ?>
      <?php $this->beginPage() ?>
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8"/>
          <?= Html::csrfMetaTags() ?>
          <title><?= Html::encode($this->title) ?></title>
          <?php $this->head() ?>
      </head>
      <body>
      <?php $this->beginBody() ?>
          <header>Minha Empresa</header>
          <?= $content ?>
          <footer>&copy; 2014 por Minhas Empresa</footer>
      <?php $this->endBody() ?>
      </body>
      </html>
      <?php $this->endPage() ?>



      Podemos utilizar layouts aninhados

      <?php $this->beginContent('@app/views/layouts/base.php'); ?>

      ...conteúdoo do layout filho aqui...

      <?php $this->endContent(); ?>

      
      podemos definir blocos no meio do layout também
      <?php $this->beginBlock('bloco1'); ?>

      ...conteúdoo do bloco1...

      <?php $this->endBlock(); ?>

      ...

      <?php $this->beginBlock('bloco3'); ?>

      ... conteúdoo do bloco3...

      <?php $this->endBlock(); ?>

      
      dai no layout temos que colocar o content do bloco também;
      ...
      <?php if (isset($this->blocks['bloco1'])): ?>
          <?= $this->blocks['bloco1'] ?>
      <?php else: ?>
          ... conteúdoo padrãoo para o bloco1 ...
      <?php endif; ?>


    Temos TEMAS, de widgets/modules e herança de temas

    ----------TODO-----------
    continuando na estrutura da documentação

    Config de title dapágina normal, tipo layout

    <?php
      $this->title = 'Título da Minha Página';
    ?>

    e dentro do layout encoded
    <title><?= Html::encode($this->title) ?></title>

    META TAGS 
    <?php
    $this->registerMetaTag(['name' => 'keywords', 'content' => 'yii, framework, php']);
    ?>

    KEYWORDS 
    <meta name="keywords" content="yii, framework, php">

    TAG LINKS
      $this->registerLinkTag([
      'title' => 'Notícias sobre o Yii',
      'rel' => 'alternate',
      'type' => 'application/rss+xml',
      'href' => 'http://www.yiiframework.com/rss.xml/',
    ]);

    codigo acima vai da nisso aqui:
    <link title="Notícias sobre o Yii" rel="alternate" type="application/rss+xml" href="http://www.yiiframework.com/rss.xml/">

    View também tem seus EVENTOS
    EVENT_BEFORE_RENDER
    EVENT_AFTER_RENDER
    EVENT_BEGIN_PAGE
    EVENT_END_PAGE
    EVENT_BEGIN_BODY
    EVENT_END_BODY


    exemplo de renderizar data com yii2 com php
    \Yii::$app->view->on(View::EVENT_END_BODY, function () {
     echo date('Y-m-d');
    });

    Página estáticas são aquelas que não existem nada de param de database ou vem do
    form.

    public function actionAbout()
    {
        return $this->render('about');
    }

    para repetir varias paginas estaticas podemos colocar uma action"externa" standalone.


    namespace app\controllers;

    use yii\web\Controller;

    class SiteController extends Controller
    {
        public function actions()
        {
            return [
                'page' => [
                    'class' => 'yii\web\ViewAction',
                ],
            ];
        }
    }


  BOAS PRATICAS da view
  Views são responsáveis por apresentar models (modelos) no formato que os usuários finais desejam. Em geral, views:

  devem conter principalmente código de apresentação, tal como o HTML, e trechos simples de PHP para percorrer, formatar e renderizar dados.
  não devem conter código de consulta ao banco de dados. Consultas assim devem ser feitas nos models.
  devem evitar acessar diretamente os dados da requisição, tais como $_GET e $_POST pois essa tarefa cabe aos controllers. Se os dados da requisição forem necessários, deverão ser fornecidos às views pelos controllers.
  podem ler as propriedades dos models, mas não devem alterá-las.
  Para tornar as views mais gerenciáveis, evite criar views muito complexas ou que contenham muito código redundante. Você pode usar as seguintes técnicas para atingir este objetivo:

  use layouts para representar as seções de apresentação comuns (por exemplo, cabeçalho e rodapé).
  divida uma view complicada em varias outras menores. As views menores podem ser renderizadas e montadas em uma maior usando os métodos descritos anteriormente.
  crie e use widgets como blocos de construção das views.
  crie e use as classes helper (auxiliares) para transformar e formatar os dados nas views.

  

  MODULES/FILTROS/
      filtro é tipo aqueles comportamentos(behaviors) na parte de auth também.
    contentNegotiator também filtras os dados, com se recebesse response em xml ou json.

    use yii\filters\ContentNegotiator;
    use yii\web\Response;

    public function behaviors()
    {
        return [
            [
                'class' => ContentNegotiator::className(),
                'formats' => [
                    'application/json' => Response::FORMAT_JSON,
                    'application/xml' => Response::FORMAT_XML,
                ],
                'languages' => [
                    'en-US',
                    'de',
                ],
            ],
        ];
    }

    PageCache, temos cache de página tbm, e fica dentro dos behaviors
    RateLimiter/VerbFilter

    Cors(cross origin resource sharing) acesso vindo de outros sites,
    podemos restringir acesso somente a um dominio, no caso o nosso tbm.


    WIDGETS 
      temos vários widgets, tipo uns plugins ou mini components, para usar na view
      datepicker, os forms.

    exemplo:
   
    namespace app\components;

    use yii\base\Widget;
    use yii\helpers\Html;

    class HelloWidget extends Widget
    {
        public $message;

        public function init()
        {
            parent::init();
            if ($this->message === null) {
                $this->message = 'Hello World';
            }
        }

        public function run()
        {
            return Html::encode($this->message);
        }
    }
    Para usar este widget, simplesmente insira o código a seguir em uma view (visão):

    <?php
    use app\components\HelloWidget;
      ?>
    <?= HelloWidget::widget(['message' => 'Good morning']) ?>

    Aqui temos o exemplo com buffer
    namespace app\components;

    use yii\base\Widget;
    use yii\helpers\Html;

    class HelloWidget extends Widget
    {
        public function init()
        {
            parent::init();
            ob_start();
        }

        public function run()
        {
            $content = ob_get_clean();
            return Html::encode($content);
        }
    }

    Como você pode ver, o buffer de saída do PHP é iniciado no método init() 
    para que qualquer conteúdo entre as chamadas de init() e run() possam ser 
    capturadas, processadas e retornadas em run().

    widgets é mais pra reuso de código na view, deve seguir o padrão MVC
    são autossuficientes e podem ser removidos da view sem fazer qualquer outra coisa.


  ASSETS
  Um asset no Yii é um arquivo que pode ser referenciado em uma página Web.
  parecido com do laravel, assets que podemos pegar nossos scripts de css ou js

  asset bundle, é uma coleção de assets, localizados em um diretório;
  exemplo:

  <?php

  namespace app\assets;

  use yii\web\AssetBundle;

  class AppAsset extends AssetBundle
  {
      public $basePath = '@webroot';
      public $baseUrl = '@web';
      public $css = [
          'css/site.css',
      ];
      public $js = [
      ];
      public $depends = [
          'yii\web\YiiAsset',
          'yii\bootstrap\BootstrapAsset',
      ];
  }

  então temos todas aquelas coisas, de asset js/css. e outras coisas.
  -sourcePath
  -basePath
  -baseUrl-js-css-depends-jsOptions
  -cssOptions
  -publishOptions

  Observação: Não use o @webroot/assets como o caminho da fonte. 
  Este diretório é usado por padrão pelo gerenciador de asset para 
  salvar os arquivos de asset publicados a partir de seu local de origem. 
  Qualquer conteúdo deste diretório será considerado como temporário e podem 
  estar sujeitos a serem deletados.

  <?php
  namespace app\assets;

  use yii\web\AssetBundle;

  class FontAwesomeAsset extends AssetBundle 
  {
      public $sourcePath = '@bower/font-awesome'; 
      public $css = [ 
          'css/font-awesome.min.css', 
      ]; 
      
      public function init()
      {
          parent::init();
          $this->publishOptions['beforeCopy'] = function ($from, $to) {
              $dirname = basename(dirname($from));
              return $dirname === 'fonts' || $dirname === 'css';
          };
      }
  }  
  O exemplo anterior define um asset bundle para o pacode de "fontawesome". 
  Ao especificar a opção de publicação beforeCopy, apenas os subdiretórios 
  fonts e css serão publicados.

  Assets do BOWER E NPM, pacotes js são gerenciados pelo Bower e NPM.

  temos o Cache Busting, que deixa os assets em cache, porém é preciso configurar
  também um timestamp para ele poder procurar o asset mais recente, caso adicione mais
  coisa depois no ambiente de produção

    return [
      // ...
      'components' => [
          'assetManager' => [
              'appendTimestamp' => true,
          ],
      ],
  ];

  dai temos até conversões de assets, mais configs etc. que podemso utilizar
  less/scss/stylus/coffeescript/typescript

  podemos e devemos combinar/comprimir nossos assets, para evitar muitas requisições http

  Localize todos os asset bundles em sua aplicação que você deseja combinar e comprimir.

  Divida estes bundles em um ou alguns grupos. Observe que cada bundle pode apenas 
  pertencer a um único grupo.

  Combinar/Comprimir os arquivos CSS de cada grupo em um único arquivo. 

  Faça isto de forma semelhante para os arquivos JavaScript.

  Defina um novo asset bundle para cada grupo:
  Defina as propriedade css e js com os arquivos CSS e JavaScript combinados, 
  respectivamente.

  Personalize os asset bundles de cada grupo definindo as suas propriedades 
  css e js como vazias e definindo a sua propriedade depends para ser o 
  novo asset bundle criado para o grupo.

  podemos fazer isto com as ferramentas, (CLOSURE COMPILER, YUI COMPRESSOR)

  da pra agrupar assset bundles também, como allshared/allfrontend/allbackend

  EXTENSÕES 
    tipo nossas dependencies, nos arquivos json, que pegamos com composer mesmo.
    composer.json q temos todo objeto com varios negocios, dependencias, até TAGS
    {
        // nome do pacote
        "name": "yiisoft/yii2-imagine",

        // tipo de pacote
        "type": "yii2-extension",

        "description": "The Imagine integration for the Yii framework",
        "keywords": ["yii2", "imagine", "image", "helper"],
        "license": "BSD-3-Clause",
        "support": {
            "issues": "https://github.com/yiisoft/yii2/issues?labels=ext%3Aimagine",
            "forum": "http://www.yiiframework.com/forum/",
            "wiki": "http://www.yiiframework.com/wiki/",
            "irc": "irc://irc.freenode.net/yii",
            "source": "https://github.com/yiisoft/yii2"
        },
        "authors": [
            {
                "name": "Antonio Ramirez",
                "email": "amigo.cobos@gmail.com"
            }
        ],

        // dependências do pacote
        "require": {
            "yiisoft/yii2": "~2.0.0",
            "imagine/imagine": "v0.5.0"
        },

        // especifica as classes autoloading 
        "autoload": {
            "psr-4": {
                "yii\\imagine\\": ""
            }
        }
    }


    namespace deve ser nomeado seguindo o padrão psr-4 ou psr-0
    não pode utilizar 'yii,yii2,yiisoft' como nome do vendor, pq são palavras 
    reservadas do codigo nativo do yii.
    

    existem extensoes nativas também, que estão no packagist.
    https://www.yiiframework.com/doc/guide/2.0/pt-br/structure-extensions
    
    apidoc - gerar api de doc do framework
    authclient - auth de clientes, contas etc
    bootstrap - widgets que encapsulam os components e plugins
    codeception - suporte a testes
    debug - debug o yii
    elasticsearch - consultas/pesquisas básicas, implementa tbm o active record.
    faker - dados falsos para gerar pra testar ou sei lá
    gii - gerador de código, que já vimos
    httpclient - httpclient v;
    imagine - funcoes de manipulação de imagens
    jui - conjunto de widgets
    mongodb - suporte pra uso do db mongodb
    redis - suporte para uso do redis, consulta basica, activerecord,cache..
    smarty - motor de template-
    sphinx - suporte pra uso do sphinx, mesma coisa de cima praticamente
    swiftmailer - fornece recursos para envio de emails
    twig- motor de template tbm.


  ==========================================
    # TRATANDO REQUISIÇÕES  

    


  ==========================================
    # SEGURANÇA

      !!AUTENTICAÇÃO!!(https://www.yiiframework.com/doc/guide/2.0/pt-br/security-authentication)
      
      processo de verificação de identidade do usuário, nome/token/etc
      ---yii\web\user 

            return [
            'components' => [
                'user' => [
                    'identityClass' => 'app\models\User',
                ],
            ],
        ];

      no caso precisamos da getAuthKey() e validateAuthKey(), para validar usuario, porém
      neste link temos outros métodos, e também se gravamos em cookie o user.

      Para logar um usuário, você pode usar o seguinte código:

      // encontrar uma identidade de usuário com o nome de usuário especificado.
      // observe que você pode querer checar a senha se necessário
      $identity = User::findOne(['username' => $username]);

      // logar o usuário
      Yii::$app->user->login($identity);

      Para realizar o logout de um usuário, simplesmente chame:

      Yii::$app->user->logout();

      ele também destruirá todos os dados da sessão do usuário. 
      Se você quiser guardar os dados da sessão, você deve chamar 
      Yii::$app->user->logout(false).

      existe também EVENTOS para autenticação
      EVENT_BEFORE_LOGIN
      EVENT_AFTER_LOGIN
      EVENT_BEFORE_LOGOUT
      EVENT_AFTER_LOGOUT
    


    !!AUTORIZAÇÃO!! (https://www.yiiframework.com/doc/guide/2.0/pt-br/security-authorization)

    verifica se o user tem permissão para fazer algo dentro da app.
    oferece o Filtro de Controle de Acesso(ACF) e Controle de Acesso Baseado em Role (RBAC)

    ACF apenas no controller, varias rules, e permissões que o usuário poderá fazer.
    behaviors = comportamento

    use yii\web\Controller;
    use yii\filters\AccessControl;

    class SiteController extends Controller
    {
      public function behaviors()
      {
          return [
              'access' => [
                  'class' => AccessControl::className(),
                  'only' => ['login', 'logout', 'signup'],
                  'rules' => [
                      [
                          'allow' => true,
                          'actions' => ['login', 'signup'],
                          'roles' => ['?'],
                      ],
                      [
                          'allow' => true,
                          'actions' => ['logout'],
                          'roles' => ['@'],
                      ],
                  ],
              ],
          ];
      }
      // ...
    }


    deny callbacks

      [
    'class' => AccessControl::className(),
    ...
    'denyCallback' => function ($rule, $action) {
        throw new \Exception('Você não está autorizado a acessar esta página');
        }
      ]

    
    temos um exemplo também de matchCallBack, lógica de validação de acesso,
    no caso, uma página disponível somente em uma certa data.

    use yii\filters\AccessControl;

    class SiteController extends Controller
    {
      public function behaviors()
      {
          return [
              'access' => [
                  'class' => AccessControl::className(),
                  'only' => ['special-callback'],
                  'rules' => [
                      [
                          'actions' => ['special-callback'],
                          'allow' => true,
                          'matchCallback' => function ($rule, $action) {
                              return date('d-m') === '31-10';
                          }
                      ],
                  ],
              ],
          ];
      }

      // Match callback chamada! Esta página pode ser acessado somente a cada 31 de outubro
      public function actionSpecialCallback()
      {
          return $this->render('happy-halloween');
      }
    }


    RBAC
      uma role representa coleção de permissão.(criar posts, atualizar posts etc);
      pode ser atribuída a um ou vários usuários.

  então temos a config do phpManager ou DbManager, que é feito pela config em components
  ++rbac (rolesPadrões);





