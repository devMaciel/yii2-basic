# Start Forms
  --SiteController: criar o model request(post) validate, view
  --Model: Formulario de Registro, model rules
  --View: Formulário(widgets)
  --View: Resposta do formulário

# Banco de Dados, ActiveRecord(sintaxe tipo eloquent(laravel))
  --Criar ActiveRecord (models), [Customer]
  --Checar conexão (config.db)
  ----querybuilder https://www.yiiframework.com/doc/guide/2.0/pt-br/db-query-builder#query-methods

  DB Browser SQLITE
  --schema/table
  --model: pais
  --PaisController: active record query's
  --'dsn' => 'sqlite:teste.sqlite', (cria banco em web->testesql)
  --view: pasta da action e index, view render db

# Gerando código com GII (https://www.yiiframework.com/doc/guide/2.0/pt-br/start-gii)
  --Models 
  --generate/overwrite - tableName - ModelClassName (pais-Pais), ctrl+c ou overwrite.

  --generate crud
  Model Class
    app\models\Pais
  Search Model Class
    app\models\PaisSearch
  Controller Class
    app\controllers\PaisController
  View Path
    @app/views/pais
  
  --criar namespace do models, o PaisSearch é a nova do crud, adicona o controller
    e a view, já criamos o controller model e view, e precisamos dar overwrite, 
    para criar os códigos template com support ao crud.

  urlparam: ?r=pais/index.
  urlparam-pais(update/delete): ?r=pais%2Fview&id=SS

# Seguindo em Frente (https://www.yiiframework.com/doc/guide/2.0/pt-br/start-looking-ahead)
- Docs (classes) - https://www.yiiframework.com/doc/api/2.0/index
- Wiki (forum/stack somente o yii2) - https://www.yiiframework.com/wiki?tag=yii2
- O Guia - https://www.yiiframework.com/doc/guide/2.0/pt-br
- Plugins/Extensões do yii2 - https://www.yiiframework.com/extensions

# Estrutura da Aplicação
- https://www.yiiframework.com/doc/guide/2.0/pt-br/structure-overview
-- Defined(const) em scripts de entrada, (modo web, console)
  EXEMPLO DO SCRIPT DE entrada
    require __DIR__ . '/../vendor/autoload.php';
    require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

    // carrega a configuração da aplicação
    $config = require __DIR__ . '/../config/web.php';

    // instancia e configura a aplicação
    (new yii\web\Application($config))->run();
  
  temos este arquivo rodando nosso basic app, temos as constantes/autoloads/vendor.

  Propiedades da App, required.
  id;basePath, 
    id geralmente ja vem um, a nao ser que tenha mais de uma app.
    basePath, caminho da app, do codfont, podemos criar aliases(atalhos), base path(@app)

    Exemplo de ALIASES
    [
      [
        'aliases' => [
          '@name1' => 'path/to/path1',
          '@name2' => 'path/to/path2',
      ],
    ]

  bootstrap da app
  -array de componentes, modulos, regras da app, que pode ser carregado junto com a app.
    exemplo do debug e o gii

  outras propriedades:
  --catchAll, pega todas requisições web para mostrar.
  --components - consegue armazenar lista de components, como cache/users/autologin etc
    tipo um bootstraping
  --ControllerMap, pega o controller e configura algumas coisas, como csrf token.
  --ControllerNamespace, como nome ja diz, consegue modificar o namespace do controller.
  --language, muda linguangem para o usuario final, padrão. 
  --modules, modules e configurações, ex: da config da database.
  --names/--params/--sourceLanguage/--timeZone/--version/--charset
    --defaultRoute/--extensions(plugins)
  
  --layout, layout da app, headers/footers etc, /--layoutPath
  --runtimePath, arquivos temporários/cache
  --viewpath/--vendorPath

  EVENTOS DA APLICAÇÃO
  [
    'on beforeRequest' => function ($event) {
        // ...
    },
  ]

  EVENT_BEFORE_REQUEST (antes do post)
  EVENT_AFTER_REQUEST  (depois do post)
  EVENT_BEFORE_ACTION   (antes de executar cada action controller)
  EVENT_AFTER_ACTION    (depois de executar cada action controller)

  LIFE CICLE
  -Script de entrada, carrega as config como array
  
  -- cria uma nova instancia da app
  --- preInit() config alta prioridade como o basePath
  --- config das propriedades da app
  --- init() chama o bootstrap() roda os components de inicialização

  ---- yii2 app run..
  ---- dispara os eventos, os before
  ---- resolve as rotas, params, model, controllers actions
  ---- dispara os eventos after 
  ---- envia resposta pro final user.

  ----- status code e completa o processamento.

  MVC
  Controllers/Rotas
  --Rotas é baseado na action e nos controllers
  Segue alguns exemplos, assumindo que o namespace do controller tenha por 
  padrão o valor app\controllers:

  article torna-se app\controllers\ArticleController;
  post-comment torna-se app\controllers\PostCommentController;
  admin/post-comment torna-se app\controllers\admin\PostCommentController;
  adminPanels/post-comment torna-se app\controllers\adminPanels\PostCommentController.

  também é possível mapear os controllers, para seguir um padrão, quando vem de crosssite.
  [
    'controllerMap' => [
        // declara o controller "account" usando um nome de classe
        'account' => 'app\controllers\UserController',

        // declara o controller "article" usando uma configuração em array
        'article' => [
            'class' => 'app\controllers\PostController',
            'enableCsrfValidation' => false,
        ],
    ],
  ]

  Segue algumas boas práticas em destaque. Os controllers:

  podem acessar os dados de uma requisição;

  podem chamar os métodos dos models e outros componentes de serviço com dados 
  da requisição;
  podem usar as views para compor as respostas;

  NÃO devem processar os dados da requisição - isto deve ser feito na 
  camada model (modelo);

  devem evitar inserir códigos HTML ou outro código de apresentação - é 
  melhor que sejam feitos nas views.

  Models
  -temos nossos request;rules/validations/atributos, nossa conexão com algumas
    tabela do db que passa pro controller dps como variável/const.

  atribuição em massa, podemos fazer apenas com atributos seguros(safe)
  public function rules()
  {
      return [
          [['title', 'description'], 'safe'],
      ];
  }

  não seguros podemos colocar !
  public function scenarios()
  {
      return [
          'login' => ['username', 'password', '!secret'],
      ];
  }

  na exportação de dados, são convertidos em arrays, porém podemos especificar depois
  para retornar um outro tipo de dado.

  boas praticas no model
  Em resumo, os models (modelos):

  podem conter atributos para representar os dados de negócio;
  podem conter regras de validação para garantir a validade e integridade dos dados;
  podem conter métodos para implementar lógicas de negócio;
  NÃO devem acessar diretamente as requisições, sessões ou quaisquer dados do ambiente do usuário. Os models (modelos) devem receber estes dados a partir dos controllers (controladores);
  devem evitar inserir HTML ou outros códigos de apresentação – isto deve ser feito nas views (visões);
  devem evitar ter muitos cenários em um único model (modelo).

  Views 
  --Segurança, sobre Html::encode, codifica o nome de usuario antes de exibi-lo

      <?php
      use yii\helpers\Html;
      ?>

      <div class="username">
          <?= Html::encode($user->name) ?>
      </div>

    Exibir conteúdo html, filtrar conteudo primeiro, ele é mais lento, então é melhor
    guardar em cache, se for usar muitas vezes.

      <?php
      use yii\helpers\HtmlPurifier;
      ?>

      <div class="post">
          <?= HtmlPurifier::process($post->text) ?>
      </div>

    
    além da render() temos outros tipos de render()...

    Nos controllers, você pode chamar os seguintes métodos para renderizar as views:

    render(): renderiza uma view nomeada e aplica um layout ao resultado da renderização.
    renderPartial(): renderiza uma view nomeada sem qualquer layout.
    renderAjax(): renderiza uma view nomeada sem qualquer layout e injeta todos os arquivos JS/CSS registrados. É geralmente utilizado em respostas de requisições Web Ajax.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.
    renderContent(): renderiza um conteúdo estático que será incorporado no layout selecionado. Este método está disponível desde a versão 2.0.1.

    na renderização de widgets podemos utiliar as seguintes:
    render(): renderiza uma view nomeada.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.

    podemos renderizar uma view dentro de outra:
    render(): renderiza uma view nomeada.
    renderAjax(): renderiza uma view nomeada sem qualquer layout e injeta todos os arquivos JS/CSS registrados. É geralmente utilizado em respostas de requisições Web Ajax.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.

    <?= $this->render('_visao-geral') ?>

    renderização de outros lugares, no código
    // exibe a view "@app/views/site/license.php"
    echo \Yii::$app->view->renderFile('@app/views/site/license.php');

    Compartilhando Dados entre as Views
    O componente view fornece a propriedade params que você pode usar para compartilhar dados entre as views.

    Por exemplo, em uma view sobre, você pode ter o seguinte código que especifica o seguimento atual do "rastro de navegação" (breadcrumbs):

    $this->params['breadcrumbs'][] = 'Sobre nós';
    Em seguida, no arquivo layout, que também é uma view, você pode exibir o "rastro de navegação" (breadcrumbs) usando os dados passados pela propriedade params:

    <?= yii\widgets\Breadcrumbs::widget([
        'links' => isset($this->params['breadcrumbs']) ? $this->params['breadcrumbs'] : [],
    ]) ?>




    Exemplo de layout, header/footer - content

    <?php
      use yii\helpers\Html;

      /* @var $this yii\web\View */
      /* @var $content string */
      ?>
      <?php $this->beginPage() ?>
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8"/>
          <?= Html::csrfMetaTags() ?>
          <title><?= Html::encode($this->title) ?></title>
          <?php $this->head() ?>
      </head>
      <body>
      <?php $this->beginBody() ?>
          <header>Minha Empresa</header>
          <?= $content ?>
          <footer>&copy; 2014 por Minhas Empresa</footer>
      <?php $this->endBody() ?>
      </body>
      </html>
      <?php $this->endPage() ?>



      Podemos utilizar layouts aninhados

      <?php $this->beginContent('@app/views/layouts/base.php'); ?>

      ...conteúdoo do layout filho aqui...

      <?php $this->endContent(); ?>

      
      podemos definir blocos no meio do layout também
      <?php $this->beginBlock('bloco1'); ?>

      ...conteúdoo do bloco1...

      <?php $this->endBlock(); ?>

      ...

      <?php $this->beginBlock('bloco3'); ?>

      ... conteúdoo do bloco3...

      <?php $this->endBlock(); ?>

      
      dai no layout temos que colocar o content do bloco também;
      ...
      <?php if (isset($this->blocks['bloco1'])): ?>
          <?= $this->blocks['bloco1'] ?>
      <?php else: ?>
          ... conteúdoo padrãoo para o bloco1 ...
      <?php endif; ?>


    Temos TEMAS, de widgets/modules e herança de temas

    ----------TODO-----------
    continuando na estrutura da documentação

    Config de title dapágina normal, tipo layout

    <?php
      $this->title = 'Título da Minha Página';
    ?>

    e dentro do layout encoded
    <title><?= Html::encode($this->title) ?></title>

    META TAGS 
    <?php
    $this->registerMetaTag(['name' => 'keywords', 'content' => 'yii, framework, php']);
    ?>

    KEYWORDS 
    <meta name="keywords" content="yii, framework, php">

    TAG LINKS
      $this->registerLinkTag([
      'title' => 'Notícias sobre o Yii',
      'rel' => 'alternate',
      'type' => 'application/rss+xml',
      'href' => 'http://www.yiiframework.com/rss.xml/',
    ]);

    codigo acima vai da nisso aqui:
    <link title="Notícias sobre o Yii" rel="alternate" type="application/rss+xml" href="http://www.yiiframework.com/rss.xml/">

    View também tem seus EVENTOS
    EVENT_BEFORE_RENDER
    EVENT_AFTER_RENDER
    EVENT_BEGIN_PAGE
    EVENT_END_PAGE
    EVENT_BEGIN_BODY
    EVENT_END_BODY


    exemplo de renderizar data com yii2 com php
    \Yii::$app->view->on(View::EVENT_END_BODY, function () {
     echo date('Y-m-d');
    });

    Página estáticas são aquelas que não existem nada de param de database ou vem do
    form.

    public function actionAbout()
    {
        return $this->render('about');
    }

    para repetir varias paginas estaticas podemos colocar uma action"externa" standalone.


    namespace app\controllers;

    use yii\web\Controller;

    class SiteController extends Controller
    {
        public function actions()
        {
            return [
                'page' => [
                    'class' => 'yii\web\ViewAction',
                ],
            ];
        }
    }


  BOAS PRATICAS da view
  Views são responsáveis por apresentar models (modelos) no formato que os usuários finais desejam. Em geral, views:

  devem conter principalmente código de apresentação, tal como o HTML, e trechos simples de PHP para percorrer, formatar e renderizar dados.
  não devem conter código de consulta ao banco de dados. Consultas assim devem ser feitas nos models.
  devem evitar acessar diretamente os dados da requisição, tais como $_GET e $_POST pois essa tarefa cabe aos controllers. Se os dados da requisição forem necessários, deverão ser fornecidos às views pelos controllers.
  podem ler as propriedades dos models, mas não devem alterá-las.
  Para tornar as views mais gerenciáveis, evite criar views muito complexas ou que contenham muito código redundante. Você pode usar as seguintes técnicas para atingir este objetivo:

  use layouts para representar as seções de apresentação comuns (por exemplo, cabeçalho e rodapé).
  divida uma view complicada em varias outras menores. As views menores podem ser renderizadas e montadas em uma maior usando os métodos descritos anteriormente.
  crie e use widgets como blocos de construção das views.
  crie e use as classes helper (auxiliares) para transformar e formatar os dados nas views.

  

  MODULES

  ==========================================
    # SEGURANÇA

      !!AUTENTICAÇÃO!!(https://www.yiiframework.com/doc/guide/2.0/pt-br/security-authentication)
      
      processo de verificação de identidade do usuário, nome/token/etc
      ---yii\web\user 

            return [
            'components' => [
                'user' => [
                    'identityClass' => 'app\models\User',
                ],
            ],
        ];

      no caso precisamos da getAuthKey() e validateAuthKey(), para validar usuario, porém
      neste link temos outros métodos, e também se gravamos em cookie o user.

      Para logar um usuário, você pode usar o seguinte código:

      // encontrar uma identidade de usuário com o nome de usuário especificado.
      // observe que você pode querer checar a senha se necessário
      $identity = User::findOne(['username' => $username]);

      // logar o usuário
      Yii::$app->user->login($identity);

      Para realizar o logout de um usuário, simplesmente chame:

      Yii::$app->user->logout();

      ele também destruirá todos os dados da sessão do usuário. 
      Se você quiser guardar os dados da sessão, você deve chamar 
      Yii::$app->user->logout(false).

      existe também EVENTOS para autenticação
      EVENT_BEFORE_LOGIN
      EVENT_AFTER_LOGIN
      EVENT_BEFORE_LOGOUT
      EVENT_AFTER_LOGOUT
    


    !!AUTORIZAÇÃO!! (https://www.yiiframework.com/doc/guide/2.0/pt-br/security-authorization)

    verifica se o user tem permissão para fazer algo dentro da app.
    oferece o Filtro de Controle de Acesso(ACF) e Controle de Acesso Baseado em Role (RBAC)

    ACF apenas no controller, varias rules, e permissões que o usuário poderá fazer.
    behaviors = comportamento

    use yii\web\Controller;
    use yii\filters\AccessControl;

    class SiteController extends Controller
    {
      public function behaviors()
      {
          return [
              'access' => [
                  'class' => AccessControl::className(),
                  'only' => ['login', 'logout', 'signup'],
                  'rules' => [
                      [
                          'allow' => true,
                          'actions' => ['login', 'signup'],
                          'roles' => ['?'],
                      ],
                      [
                          'allow' => true,
                          'actions' => ['logout'],
                          'roles' => ['@'],
                      ],
                  ],
              ],
          ];
      }
      // ...
    }


    deny callbacks

      [
    'class' => AccessControl::className(),
    ...
    'denyCallback' => function ($rule, $action) {
        throw new \Exception('Você não está autorizado a acessar esta página');
        }
      ]

    
    temos um exemplo também de matchCallBack, lógica de validação de acesso,
    no caso, uma página disponível somente em uma certa data.

    use yii\filters\AccessControl;

    class SiteController extends Controller
    {
      public function behaviors()
      {
          return [
              'access' => [
                  'class' => AccessControl::className(),
                  'only' => ['special-callback'],
                  'rules' => [
                      [
                          'actions' => ['special-callback'],
                          'allow' => true,
                          'matchCallback' => function ($rule, $action) {
                              return date('d-m') === '31-10';
                          }
                      ],
                  ],
              ],
          ];
      }

      // Match callback chamada! Esta página pode ser acessado somente a cada 31 de outubro
      public function actionSpecialCallback()
      {
          return $this->render('happy-halloween');
      }
    }


    RBAC
      uma role representa coleção de permissão.(criar posts, atualizar posts etc);
      pode ser atribuída a um ou vários usuários.

  então temos a config do phpManager ou DbManager, que é feito pela config em components
  ++rbac (rolesPadrões);





