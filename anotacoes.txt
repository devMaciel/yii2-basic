# Start Forms
  --SiteController: criar o model request(post) validate, view
  --Model: Formulario de Registro, model rules
  --View: Formulário(widgets)
  --View: Resposta do formulário

# Banco de Dados, ActiveRecord(sintaxe tipo eloquent(laravel))
  --Criar ActiveRecord (models), [Customer]
  --Checar conexão (config.db)
  ----querybuilder https://www.yiiframework.com/doc/guide/2.0/pt-br/db-query-builder#query-methods

  DB Browser SQLITE
  --schema/table
  --model: pais
  --PaisController: active record query's
  --'dsn' => 'sqlite:teste.sqlite', (cria banco em web->testesql)
  --view: pasta da action e index, view render db

# Gerando código com GII (https://www.yiiframework.com/doc/guide/2.0/pt-br/start-gii)
  --Models 
  --generate/overwrite - tableName - ModelClassName (pais-Pais), ctrl+c ou overwrite.

  --generate crud
  Model Class
    app\models\Pais
  Search Model Class
    app\models\PaisSearch
  Controller Class
    app\controllers\PaisController
  View Path
    @app/views/pais
  
  --criar namespace do models, o PaisSearch é a nova do crud, adicona o controller
    e a view, já criamos o controller model e view, e precisamos dar overwrite, 
    para criar os códigos template com support ao crud.

  urlparam: ?r=pais/index.
  urlparam-pais(update/delete): ?r=pais%2Fview&id=SS

# Seguindo em Frente (https://www.yiiframework.com/doc/guide/2.0/pt-br/start-looking-ahead)
- Docs (classes) - https://www.yiiframework.com/doc/api/2.0/index
- Wiki (forum/stack somente o yii2) - https://www.yiiframework.com/wiki?tag=yii2
- O Guia - https://www.yiiframework.com/doc/guide/2.0/pt-br
- Plugins/Extensões do yii2 - https://www.yiiframework.com/extensions

# Estrutura da Aplicação
- https://www.yiiframework.com/doc/guide/2.0/pt-br/structure-overview
-- Defined(const) em scripts de entrada, (modo web, console)
  EXEMPLO DO SCRIPT DE entrada
    require __DIR__ . '/../vendor/autoload.php';
    require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

    // carrega a configuração da aplicação
    $config = require __DIR__ . '/../config/web.php';

    // instancia e configura a aplicação
    (new yii\web\Application($config))->run();
  
  temos este arquivo rodando nosso basic app, temos as constantes/autoloads/vendor.

  Propiedades da App, required.
  id;basePath, 
    id geralmente ja vem um, a nao ser que tenha mais de uma app.
    basePath, caminho da app, do codfont, podemos criar aliases(atalhos), base path(@app)

    Exemplo de ALIASES
    [
      [
        'aliases' => [
          '@name1' => 'path/to/path1',
          '@name2' => 'path/to/path2',
      ],
    ]

  bootstrap da app
  -array de componentes, modulos, regras da app, que pode ser carregado junto com a app.
    exemplo do debug e o gii

  outras propriedades:
  --catchAll, pega todas requisições web para mostrar.
  --components - consegue armazenar lista de components, como cache/users/autologin etc
    tipo um bootstraping
  --ControllerMap, pega o controller e configura algumas coisas, como csrf token.
  --ControllerNamespace, como nome ja diz, consegue modificar o namespace do controller.
  --language, muda linguangem para o usuario final, padrão. 
  --modules, modules e configurações, ex: da config da database.
  --names/--params/--sourceLanguage/--timeZone/--version/--charset
    --defaultRoute/--extensions(plugins)
  
  --layout, layout da app, headers/footers etc, /--layoutPath
  --runtimePath, arquivos temporários/cache
  --viewpath/--vendorPath

  EVENTOS DA APLICAÇÃO
  [
    'on beforeRequest' => function ($event) {
        // ...
    },
  ]

  EVENT_BEFORE_REQUEST (antes do post)
  EVENT_AFTER_REQUEST  (depois do post)
  EVENT_BEFORE_ACTION   (antes de executar cada action controller)
  EVENT_AFTER_ACTION    (depois de executar cada action controller)

  LIFE CICLE
  -Script de entrada, carrega as config como array
  
  -- cria uma nova instancia da app
  --- preInit() config alta prioridade como o basePath
  --- config das propriedades da app
  --- init() chama o bootstrap() roda os components de inicialização

  ---- yii2 app run..
  ---- dispara os eventos, os before
  ---- resolve as rotas, params, model, controllers actions
  ---- dispara os eventos after 
  ---- envia resposta pro final user.

  ----- status code e completa o processamento.

  MVC
  Controllers/Rotas
  --Rotas é baseado na action e nos controllers
  Segue alguns exemplos, assumindo que o namespace do controller tenha por 
  padrão o valor app\controllers:

  article torna-se app\controllers\ArticleController;
  post-comment torna-se app\controllers\PostCommentController;
  admin/post-comment torna-se app\controllers\admin\PostCommentController;
  adminPanels/post-comment torna-se app\controllers\adminPanels\PostCommentController.

  também é possível mapear os controllers, para seguir um padrão, quando vem de crosssite.
  [
    'controllerMap' => [
        // declara o controller "account" usando um nome de classe
        'account' => 'app\controllers\UserController',

        // declara o controller "article" usando uma configuração em array
        'article' => [
            'class' => 'app\controllers\PostController',
            'enableCsrfValidation' => false,
        ],
    ],
  ]

  Segue algumas boas práticas em destaque. Os controllers:

  podem acessar os dados de uma requisição;

  podem chamar os métodos dos models e outros componentes de serviço com dados 
  da requisição;
  podem usar as views para compor as respostas;

  NÃO devem processar os dados da requisição - isto deve ser feito na 
  camada model (modelo);

  devem evitar inserir códigos HTML ou outro código de apresentação - é 
  melhor que sejam feitos nas views.

  Models
  -temos nossos request;rules/validations/atributos, nossa conexão com algumas
    tabela do db que passa pro controller dps como variável/const.

  atribuição em massa, podemos fazer apenas com atributos seguros(safe)
  public function rules()
  {
      return [
          [['title', 'description'], 'safe'],
      ];
  }

  não seguros podemos colocar !
  public function scenarios()
  {
      return [
          'login' => ['username', 'password', '!secret'],
      ];
  }

  na exportação de dados, são convertidos em arrays, porém podemos especificar depois
  para retornar um outro tipo de dado.

  boas praticas no model
  Em resumo, os models (modelos):

  podem conter atributos para representar os dados de negócio;
  podem conter regras de validação para garantir a validade e integridade dos dados;
  podem conter métodos para implementar lógicas de negócio;
  NÃO devem acessar diretamente as requisições, sessões ou quaisquer dados do ambiente do usuário. Os models (modelos) devem receber estes dados a partir dos controllers (controladores);
  devem evitar inserir HTML ou outros códigos de apresentação – isto deve ser feito nas views (visões);
  devem evitar ter muitos cenários em um único model (modelo).

  Views 
  --Segurança, sobre Html::encode, codifica o nome de usuario antes de exibi-lo

      <?php
      use yii\helpers\Html;
      ?>

      <div class="username">
          <?= Html::encode($user->name) ?>
      </div>

    Exibir conteúdo html, filtrar conteudo primeiro, ele é mais lento, então é melhor
    guardar em cache, se for usar muitas vezes.

      <?php
      use yii\helpers\HtmlPurifier;
      ?>

      <div class="post">
          <?= HtmlPurifier::process($post->text) ?>
      </div>

    
    além da render() temos outros tipos de render()...

    Nos controllers, você pode chamar os seguintes métodos para renderizar as views:

    render(): renderiza uma view nomeada e aplica um layout ao resultado da renderização.
    renderPartial(): renderiza uma view nomeada sem qualquer layout.
    renderAjax(): renderiza uma view nomeada sem qualquer layout e injeta todos os arquivos JS/CSS registrados. É geralmente utilizado em respostas de requisições Web Ajax.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.
    renderContent(): renderiza um conteúdo estático que será incorporado no layout selecionado. Este método está disponível desde a versão 2.0.1.

    na renderização de widgets podemos utiliar as seguintes:
    render(): renderiza uma view nomeada.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.

    podemos renderizar uma view dentro de outra:
    render(): renderiza uma view nomeada.
    renderAjax(): renderiza uma view nomeada sem qualquer layout e injeta todos os arquivos JS/CSS registrados. É geralmente utilizado em respostas de requisições Web Ajax.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.

    <?= $this->render('_visao-geral') ?>

    renderização de outros lugares, no código
    // exibe a view "@app/views/site/license.php"
    echo \Yii::$app->view->renderFile('@app/views/site/license.php');

    Compartilhando Dados entre as Views
    O componente view fornece a propriedade params que você pode usar para compartilhar dados entre as views.

    Por exemplo, em uma view sobre, você pode ter o seguinte código que especifica o seguimento atual do "rastro de navegação" (breadcrumbs):

    $this->params['breadcrumbs'][] = 'Sobre nós';
    Em seguida, no arquivo layout, que também é uma view, você pode exibir o "rastro de navegação" (breadcrumbs) usando os dados passados pela propriedade params:

    <?= yii\widgets\Breadcrumbs::widget([
        'links' => isset($this->params['breadcrumbs']) ? $this->params['breadcrumbs'] : [],
    ]) ?>




    Exemplo de layout, header/footer - content

    <?php
      use yii\helpers\Html;

      /* @var $this yii\web\View */
      /* @var $content string */
      ?>
      <?php $this->beginPage() ?>
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8"/>
          <?= Html::csrfMetaTags() ?>
          <title><?= Html::encode($this->title) ?></title>
          <?php $this->head() ?>
      </head>
      <body>
      <?php $this->beginBody() ?>
          <header>Minha Empresa</header>
          <?= $content ?>
          <footer>&copy; 2014 por Minhas Empresa</footer>
      <?php $this->endBody() ?>
      </body>
      </html>
      <?php $this->endPage() ?>



      Podemos utilizar layouts aninhados

      <?php $this->beginContent('@app/views/layouts/base.php'); ?>

      ...conteúdoo do layout filho aqui...

      <?php $this->endContent(); ?>

      
      podemos definir blocos no meio do layout também
      <?php $this->beginBlock('bloco1'); ?>

      ...conteúdoo do bloco1...

      <?php $this->endBlock(); ?>

      ...

      <?php $this->beginBlock('bloco3'); ?>

      ... conteúdoo do bloco3...

      <?php $this->endBlock(); ?>

      
      dai no layout temos que colocar o content do bloco também;
      ...
      <?php if (isset($this->blocks['bloco1'])): ?>
          <?= $this->blocks['bloco1'] ?>
      <?php else: ?>
          ... conteúdoo padrãoo para o bloco1 ...
      <?php endif; ?>


    Temos TEMAS, de widgets/modules e herança de temas

    ----------TODO-----------
    continuando na estrutura da documentação

    Config de title dapágina normal, tipo layout

    <?php
      $this->title = 'Título da Minha Página';
    ?>

    e dentro do layout encoded
    <title><?= Html::encode($this->title) ?></title>

    META TAGS 
    <?php
    $this->registerMetaTag(['name' => 'keywords', 'content' => 'yii, framework, php']);
    ?>

    KEYWORDS 
    <meta name="keywords" content="yii, framework, php">

    TAG LINKS
      $this->registerLinkTag([
      'title' => 'Notícias sobre o Yii',
      'rel' => 'alternate',
      'type' => 'application/rss+xml',
      'href' => 'http://www.yiiframework.com/rss.xml/',
    ]);

    codigo acima vai da nisso aqui:
    <link title="Notícias sobre o Yii" rel="alternate" type="application/rss+xml" href="http://www.yiiframework.com/rss.xml/">

    View também tem seus EVENTOS
    EVENT_BEFORE_RENDER
    EVENT_AFTER_RENDER
    EVENT_BEGIN_PAGE
    EVENT_END_PAGE
    EVENT_BEGIN_BODY
    EVENT_END_BODY


    exemplo de renderizar data com yii2 com php
    \Yii::$app->view->on(View::EVENT_END_BODY, function () {
     echo date('Y-m-d');
    });

    Página estáticas são aquelas que não existem nada de param de database ou vem do
    form.

    public function actionAbout()
    {
        return $this->render('about');
    }

    para repetir varias paginas estaticas podemos colocar uma action"externa" standalone.


    namespace app\controllers;

    use yii\web\Controller;

    class SiteController extends Controller
    {
        public function actions()
        {
            return [
                'page' => [
                    'class' => 'yii\web\ViewAction',
                ],
            ];
        }
    }


  BOAS PRATICAS da view
  Views são responsáveis por apresentar models (modelos) no formato que os usuários finais desejam. Em geral, views:

  devem conter principalmente código de apresentação, tal como o HTML, e trechos simples de PHP para percorrer, formatar e renderizar dados.
  não devem conter código de consulta ao banco de dados. Consultas assim devem ser feitas nos models.
  devem evitar acessar diretamente os dados da requisição, tais como $_GET e $_POST pois essa tarefa cabe aos controllers. Se os dados da requisição forem necessários, deverão ser fornecidos às views pelos controllers.
  podem ler as propriedades dos models, mas não devem alterá-las.
  Para tornar as views mais gerenciáveis, evite criar views muito complexas ou que contenham muito código redundante. Você pode usar as seguintes técnicas para atingir este objetivo:

  use layouts para representar as seções de apresentação comuns (por exemplo, cabeçalho e rodapé).
  divida uma view complicada em varias outras menores. As views menores podem ser renderizadas e montadas em uma maior usando os métodos descritos anteriormente.
  crie e use widgets como blocos de construção das views.
  crie e use as classes helper (auxiliares) para transformar e formatar os dados nas views.

  

  MODULES/FILTROS/
      filtro é tipo aqueles comportamentos(behaviors) na parte de auth também.
    contentNegotiator também filtras os dados, com se recebesse response em xml ou json.

    use yii\filters\ContentNegotiator;
    use yii\web\Response;

    public function behaviors()
    {
        return [
            [
                'class' => ContentNegotiator::className(),
                'formats' => [
                    'application/json' => Response::FORMAT_JSON,
                    'application/xml' => Response::FORMAT_XML,
                ],
                'languages' => [
                    'en-US',
                    'de',
                ],
            ],
        ];
    }

    PageCache, temos cache de página tbm, e fica dentro dos behaviors
    RateLimiter/VerbFilter

    Cors(cross origin resource sharing) acesso vindo de outros sites,
    podemos restringir acesso somente a um dominio, no caso o nosso tbm.


    WIDGETS 
      temos vários widgets, tipo uns plugins ou mini components, para usar na view
      datepicker, os forms.

    exemplo:
   
    namespace app\components;

    use yii\base\Widget;
    use yii\helpers\Html;

    class HelloWidget extends Widget
    {
        public $message;

        public function init()
        {
            parent::init();
            if ($this->message === null) {
                $this->message = 'Hello World';
            }
        }

        public function run()
        {
            return Html::encode($this->message);
        }
    }
    Para usar este widget, simplesmente insira o código a seguir em uma view (visão):

    <?php
    use app\components\HelloWidget;
      ?>
    <?= HelloWidget::widget(['message' => 'Good morning']) ?>

    Aqui temos o exemplo com buffer
    namespace app\components;

    use yii\base\Widget;
    use yii\helpers\Html;

    class HelloWidget extends Widget
    {
        public function init()
        {
            parent::init();
            ob_start();
        }

        public function run()
        {
            $content = ob_get_clean();
            return Html::encode($content);
        }
    }

    Como você pode ver, o buffer de saída do PHP é iniciado no método init() 
    para que qualquer conteúdo entre as chamadas de init() e run() possam ser 
    capturadas, processadas e retornadas em run().

    widgets é mais pra reuso de código na view, deve seguir o padrão MVC
    são autossuficientes e podem ser removidos da view sem fazer qualquer outra coisa.


  ASSETS
  Um asset no Yii é um arquivo que pode ser referenciado em uma página Web.
  parecido com do laravel, assets que podemos pegar nossos scripts de css ou js

  asset bundle, é uma coleção de assets, localizados em um diretório;
  exemplo:

  <?php

  namespace app\assets;

  use yii\web\AssetBundle;

  class AppAsset extends AssetBundle
  {
      public $basePath = '@webroot';
      public $baseUrl = '@web';
      public $css = [
          'css/site.css',
      ];
      public $js = [
      ];
      public $depends = [
          'yii\web\YiiAsset',
          'yii\bootstrap\BootstrapAsset',
      ];
  }

  então temos todas aquelas coisas, de asset js/css. e outras coisas.
  -sourcePath
  -basePath
  -baseUrl-js-css-depends-jsOptions
  -cssOptions
  -publishOptions

  Observação: Não use o @webroot/assets como o caminho da fonte. 
  Este diretório é usado por padrão pelo gerenciador de asset para 
  salvar os arquivos de asset publicados a partir de seu local de origem. 
  Qualquer conteúdo deste diretório será considerado como temporário e podem 
  estar sujeitos a serem deletados.

  <?php
  namespace app\assets;

  use yii\web\AssetBundle;

  class FontAwesomeAsset extends AssetBundle 
  {
      public $sourcePath = '@bower/font-awesome'; 
      public $css = [ 
          'css/font-awesome.min.css', 
      ]; 
      
      public function init()
      {
          parent::init();
          $this->publishOptions['beforeCopy'] = function ($from, $to) {
              $dirname = basename(dirname($from));
              return $dirname === 'fonts' || $dirname === 'css';
          };
      }
  }  
  O exemplo anterior define um asset bundle para o pacode de "fontawesome". 
  Ao especificar a opção de publicação beforeCopy, apenas os subdiretórios 
  fonts e css serão publicados.

  Assets do BOWER E NPM, pacotes js são gerenciados pelo Bower e NPM.

  temos o Cache Busting, que deixa os assets em cache, porém é preciso configurar
  também um timestamp para ele poder procurar o asset mais recente, caso adicione mais
  coisa depois no ambiente de produção

    return [
      // ...
      'components' => [
          'assetManager' => [
              'appendTimestamp' => true,
          ],
      ],
  ];

  dai temos até conversões de assets, mais configs etc. que podemso utilizar
  less/scss/stylus/coffeescript/typescript

  podemos e devemos combinar/comprimir nossos assets, para evitar muitas requisições http

  Localize todos os asset bundles em sua aplicação que você deseja combinar e comprimir.

  Divida estes bundles em um ou alguns grupos. Observe que cada bundle pode apenas 
  pertencer a um único grupo.

  Combinar/Comprimir os arquivos CSS de cada grupo em um único arquivo. 

  Faça isto de forma semelhante para os arquivos JavaScript.

  Defina um novo asset bundle para cada grupo:
  Defina as propriedade css e js com os arquivos CSS e JavaScript combinados, 
  respectivamente.

  Personalize os asset bundles de cada grupo definindo as suas propriedades 
  css e js como vazias e definindo a sua propriedade depends para ser o 
  novo asset bundle criado para o grupo.

  podemos fazer isto com as ferramentas, (CLOSURE COMPILER, YUI COMPRESSOR)

  da pra agrupar assset bundles também, como allshared/allfrontend/allbackend

  EXTENSÕES 
    tipo nossas dependencies, nos arquivos json, que pegamos com composer mesmo.
    composer.json q temos todo objeto com varios negocios, dependencias, até TAGS
    {
        // nome do pacote
        "name": "yiisoft/yii2-imagine",

        // tipo de pacote
        "type": "yii2-extension",

        "description": "The Imagine integration for the Yii framework",
        "keywords": ["yii2", "imagine", "image", "helper"],
        "license": "BSD-3-Clause",
        "support": {
            "issues": "https://github.com/yiisoft/yii2/issues?labels=ext%3Aimagine",
            "forum": "http://www.yiiframework.com/forum/",
            "wiki": "http://www.yiiframework.com/wiki/",
            "irc": "irc://irc.freenode.net/yii",
            "source": "https://github.com/yiisoft/yii2"
        },
        "authors": [
            {
                "name": "Antonio Ramirez",
                "email": "amigo.cobos@gmail.com"
            }
        ],

        // dependências do pacote
        "require": {
            "yiisoft/yii2": "~2.0.0",
            "imagine/imagine": "v0.5.0"
        },

        // especifica as classes autoloading 
        "autoload": {
            "psr-4": {
                "yii\\imagine\\": ""
            }
        }
    }


    namespace deve ser nomeado seguindo o padrão psr-4 ou psr-0
    não pode utilizar 'yii,yii2,yiisoft' como nome do vendor, pq são palavras 
    reservadas do codigo nativo do yii.
    

    existem extensoes nativas também, que estão no packagist.
    https://www.yiiframework.com/doc/guide/2.0/pt-br/structure-extensions
    
    apidoc - gerar api de doc do framework
    authclient - auth de clientes, contas etc
    bootstrap - widgets que encapsulam os components e plugins
    codeception - suporte a testes
    debug - debug o yii
    elasticsearch - consultas/pesquisas básicas, implementa tbm o active record.
    faker - dados falsos para gerar pra testar ou sei lá
    gii - gerador de código, que já vimos
    httpclient - httpclient v;
    imagine - funcoes de manipulação de imagens
    jui - conjunto de widgets
    mongodb - suporte pra uso do db mongodb
    redis - suporte para uso do redis, consulta basica, activerecord,cache..
    smarty - motor de template-
    sphinx - suporte pra uso do sphinx, mesma coisa de cima praticamente
    swiftmailer - fornece recursos para envio de emails
    twig- motor de template tbm.


  ==========================================
    # TRATANDO REQUISIÇÕES  

    visão geral de como funciona em imagem.
    depois falamos da inicialização - bootstrapping
    roteamento e criação de url, que é feita pelo UrlManager
    que já vimos também sobre o prettyUrl

      use yii\helpers\Url;

      // Url::to() chama UrlManager::createUrl() para criar uma URL
      $url = Url::to(['post/view', 'id' => 100]);
    
    que geralmente fica assim
      /index.php?r=post/view&id=100
      /index.php/post/100
      /posts/100

  rotemando vai criando 'automaticamente' com base no controller view etc
  precisamos nomear as pastas corretamentas e feita pelas actions.

  temos rotaPadrão
    [
      // ...
      'defaultRoute' => 'main/index',
    ];
  
  rota catchAll
    pega todas rotas, talvez para fazer manutenção
    [
      // ...
      'catchAll' => ['site/offline'],
    ];

  Para Criar URL's temos o Url::to

    use yii\helpers\Url;

  // cria uma URL para uma rota: /index.php?r=post/index
  echo Url::to(['post/index']);

  // cria uma URL para uma rota com parâmetros: /index.php?r=post/view&id=100
  echo Url::to(['post/view', 'id' => 100]);

  // cria uma URL ancorada: /index.php?r=post/view&id=100#content
  echo Url::to(['post/view', 'id' => 100, '#' => 'content']);

  // cria uma URL absoluta: http://www.example.com/index.php?r=post/index
  echo Url::to(['post/index'], true);

  // cria uma URL absoluta usando https: https://www.example.com/index.php?r=post/index
  echo Url::to(['post/index'], 'https');


  podemos setar alias também para url não relacionadas.

  use yii\helpers\Url;

    // rota atual requerida: /index.php?r=admin/post/index
    echo Url::to();

    // uma alias da URL: http://example.com
    Yii::setAlias('@example', 'http://example.com/');
    echo Url::to('@example');

    // uma URL absoluta: http://example.com/images/logo.gif
    echo Url::to('/images/logo.gif', true);


  além to url::to() temos outras aqui.

    use yii\helpers\Url;

    // URL da página inicial: /index.php?r=site/index
    echo Url::home();

    // URL base, útil se a aplicação for implementada em uma subpasta da pasta raiz do servidor Web
    echo Url::base();

    // A URL canônica da requisição atual
    // Veja mais detalhes em https://en.wikipedia.org/wiki/Canonical_link_element
    echo Url::canonical();

    // Obtêm a URL da requisição anterior para reutilizá-la em requisições futuras
    Url::remember();
    echo Url::previous();

  
    para usar as PRETTY URL

      [
          'components' => [
              'urlManager' => [
                  'enablePrettyUrl' => true,
                  'showScriptName' => false,
                  'enableStrictParsing' => false,
                  'rules' => [
                      // ...
                  ],
              ],
          ],
      ]

  então temos mais coisas aqui sobre as regras da url e param nomeados
  https://www.yiiframework.com/doc/guide/2.0/pt-br/runtime-routing

  temos o sufixo na url.

      [
        'components' => [
            'urlManager' => [
                'enablePrettyUrl' => true,
                'showScriptName' => false,
                'enableStrictParsing' => true,
                'suffix' => '.html',
                'rules' => [
                    // ...
                    [
                        'pattern' => 'posts',
                        'route' => 'post/index',
                        'suffix' => '.json',
                    ],
                ],
            ],
        ],
    ]

  
  métodos HTTP

    [
      'PUT,POST post/<id:\d+>' => 'post/create',
      'DELETE post/<id:\d+>' => 'post/delete',
      'post/<id:\d+>' => 'post/view',
    ] 

  temos como criar classes de regras, que vem da UrlRule, mas é flexível para alterar
  é uma mãozinha.
  
  caso a url use o mesmo prefixo em seus padrões e rotas, temos o groupUrlRule.
  


  REQUISIÇÕES

  temos nossos parâmetros de requisição, $_GET $_POST.

      $request = Yii::$app->request;

    $get = $request->get(); 
    // equivalente à: $get = $_GET;

    $id = $request->get('id');   
    // equivalente à: $id = isset($_GET['id']) ? $_GET['id'] : null;

    $id = $request->get('id', 1);   
    // equivalente à: $id = isset($_GET['id']) ? $_GET['id'] : 1;

    $post = $request->post(); 
    // equivalente à: $post = $_POST;

    $name = $request->post('name');   
    // equivalente à: $name = isset($_POST['name']) ? $_POST['name'] : null;

    $name = $request->post('name', '');   
    // equivalente à: $name = isset($_POST['name']) ? $_POST['name'] : '';

    temos ai algumas coisitas.

  para restful api, enviados pleo metodos put patch.
  $request = Yii::$app->request;

  // retorna todos os parâmetros 
  $params = $request->bodyParams;

  // retorna o parâmetro "id"
  $param = $request->getBodyParam('id');


  métodos de requisição
  $request = Yii::$app->request;
  if ($request->isAjax) { /* a requisição é uma requisição Ajax */ }
  if ($request->isGet)  { /* o método da requisição é GET */ }
  if ($request->isPost) { /* o método da requisição é POST */ }
  if ($request->isPut)  { /* o método da requisição é PUT */ }
  
  URLs da requisição
    temos pelo componente request, muitas formas de inspecionar a atual url da request.

    url - retorna a url sem info de protocolos e dominio 
      (/admin/index.php/product?id=100)

    absoluteUrl - url completoa, incluindo info do protocolo e dominio
      (http://example.com/admin/index.php/product?id=100)
    
    hostInfo - retorn o que são as info de protocolo e dominio
      (http://example.com)

    pathInfo - informa depois do script de etnrada e antes da interroção(query string)
      (/product)

    queryString - retorna a info depois da query string
      (id=100)

    baseUrl - retorna a info depois do dominio e antes do script de entrada
      (/admin)

    scriptUrl - retorna a info depois do dominio ate o script de entrada.
      (/admin/index.php)

    serverName - retorna o dominio da url
      (example.com)

    serverPort - retorna qual ap orta utilizada pelo servidor web
      (80)


  Header(cabeçalho) HTTP

  // $headers é um objeto de yii\web\HeaderCollection 
  $headers = Yii::$app->request->headers;

  // retorna o valor do cabeçalho Accept
  $accept = $headers->get('Accept');

  if ($headers->has('User-Agent')) { /* existe o cabeçalho User-Agent */ }

  assim como algumas outras coisas como
  -userAgent
  -contentType
  -acceptableContentTypes
  -acceptableLanguages

  Informações do Cliente ( host e IP )
  $userHost = Yii::$app->request->userHost;
  $userIP = Yii::$app->request->userIP;

  RESPOSTAS(RESPONSES) 
  https://www.yiiframework.com/doc/guide/2.0/pt-br/runtime-responses
    temos o status code
    Yii::$app->response->statusCode = 200;

  alguns verbos http mais comuns
  400 - bad request
  404 - not found
  409 - conflit HttpException
  403 - forbidden ..
  410 - gone
  405 - method not allowed
  406 - not accepttable
  500 - server error
  429 - too many request
  401 - unauthorized
  415 - unsupported media type

  sobre http headers, response HeaderCollection

  Response Body

    Yii::$app->response->content = 'hello world!';

  também podemos formatar como vai vir a 'data'

    $response = Yii::$app->response;
    $response->format = \yii\web\Response::FORMAT_JSON;
    $response->data = ['message' => 'hello world'];

  yii suporta
  -html
  -xml
  -json
  -jsonp 
  -raw

  public function actionInfo()
  {
      \Yii::$app->response->format = \yii\web\Response::FORMAT_JSON;
      return [
          'message' => 'hello world',
          'code' => 100,
      ];
  }

  temos nosso Redirect, e status code.
  
  public function actionOld()
  {
      return $this->redirect('http://example.com/new', 301);
  }

  \Yii::$app->response->redirect('http://example.com/new', 301)->send();

  para x-redirect - ajax(async)
  https://www.yiiframework.com/doc/api/2.0/yii-web-response#redirect()-detail


  Enviando Files
  public function actionDownload()
  {
      return \Yii::$app->response->sendFile('path/to/file.txt');
  }

  se chamar de outro lugar que nao for do actionMethod
    \Yii::$app->response->sendFile('path/to/file.txt')->send();

  
  Enviando Resposta, tem a estrutura de como é enviado as response.


  SESSÕES E COOKIES
  para abrir e fechar sessões.

  $session = Yii::$app->session;

  // verifica se a sessão está pronta para abrir
  if ($session->isActive) ...

  // abre uma sessão
  $session->open();

  // fecha uma sessão
  $session->close();

  // destrói todos os dados registrados em uma sessão.
  $session->destroy();

  
  para acessar dados da sessão

  $session = Yii::$app->session;

  // obter uma variável de sessão. Os exemplos abaixo são equivalentes:
  $language = $session->get('language');
  $language = $session['language'];
  $language = isset($_SESSION['language']) ? $_SESSION['language'] : null;

  // definir uma variável de sessão. Os exemplos abaixo são equivalentes:
  $session->set('language', 'en-US');
  $session['language'] = 'en-US';
  $_SESSION['language'] = 'en-US';

  // remover uma variável de sessão. Os exemplos abaixo são equivalentes:
  $session->remove('language');
  unset($session['language']);
  unset($_SESSION['language']);

  // verifica se a variável de sessão existe. Os exemplos abaixo são equivalentes:
  if ($session->has('language')) ...
  if (isset($session['language'])) ...
  if (isset($_SESSION['language'])) ...

  // percorrer todas as variáveis de sessão. Os exemplos abaixo são equivalentes:
  foreach ($session as $name => $value) ...
  foreach ($_SESSION as $name => $value) ...


  Session de arrays
  $session = Yii::$app->session;

  // o seguinte código não funciona
  $session['captcha']['number'] = 5;
  $session['captcha']['lifetime'] = 3600;

  // o seguinte código funciona:
  $session['captcha'] = [
      'number' => 5,
      'lifetime' => 3600,
  ];

  // o seguinte código também funciona:
  echo $session['captcha']['lifetime'];



  temos soluções diferente pelo yii
  $session = Yii::$app->session;

  // use diretamente $_SESSION (certifique-se que Yii::$app->session->open() tenha sido chamado)
  $_SESSION['captcha']['number'] = 5;
  $_SESSION['captcha']['lifetime'] = 3600;

  // obter todo o array primeiro, modificá-lo e depois salvá-lo
  $captcha = $session['captcha'];
  $captcha['number'] = 5;
  $captcha['lifetime'] = 3600;
  $session['captcha'] = $captcha;

  // use ArrayObject em vez de array
  $session['captcha'] = new \ArrayObject;
  ...
  $session['captcha']['number'] = 5;
  $session['captcha']['lifetime'] = 3600;

  // armazenar dados de array utilizando chaves com um prefixo comum
  $session['captcha.number'] = 5;
  $session['captcha.lifetime'] = 3600;


  podemos salvar em session personalizadas, porem requer mais configurações
  como armazenar direto em cache ou db, porém é preciso criar database e outras
  configurações.

  Dados Flash
  -dado especial de sessao, só estão disponivies na proxima requisição e serão 
    automaticamente excluido depois. geralmente implementado para mensagens

    $session = Yii::$app->session;

    // Request #1
    // defini uma mensagem flash chamada "postDeleted"
    $session->setFlash('postDeleted', 'You have successfully deleted your post.');

    // Request #2
    // exibe uma mensagem flash chamada "postDeleted"
    echo $session->getFlash('postDeleted');

    // Request #3
    // $result será falso uma vez que a mensagem flash foi automaticamente excluída
    $result = $session->hasFlash('postDeleted');


    podemos utilizar isto juntamente com o ALERT widget
    echo Alert::widget([
      'options' => ['class' => 'alert-info'],
      'body' => Yii::$app->session->getFlash('postDeleted'),
    ]);

    Temos os COOKIES.
      // pega a coleção de cookie  (yii\web\CookieCollection) do componente "request"
    $cookies = Yii::$app->request->cookies;

    // pega o valor do cookie "language". se o cookie não existir, retorna "en" como o valor padrão.
    $language = $cookies->getValue('language', 'en');

    // um caminho alternativo para pegar o valor do cookie "language"
    if (($cookie = $cookies->get('language')) !== null) {
        $language = $cookie->value;
    }

    // você também pode usar $cookies como um array
    if (isset($cookies['language'])) {
        $language = $cookies['language']->value;
    }

    // verifica se existe um cookie "language"
    if ($cookies->has('language')) ...
    if (isset($cookies['language'])) ...


    Enviando Cookies para o usuário final
    // pega a coleção de cookie (yii\web\CookieCollection) do componente "response"
    $cookies = Yii::$app->response->cookies;

    // adicionar um novo cookie a resposta que será enviado
    $cookies->add(new \yii\web\Cookie([
        'name' => 'language',
        'value' => 'zh-CN',
    ]));

    // remove um cookie
    $cookies->remove('language');
    // outra alternativa para remover um cookie
    unset($cookies['language']);

    temos também a validação de cookie
    tudo que vier pelo setcookie ou $_COOKIE nao serão validados.

    return [
        'components' => [
            'request' => [
                'cookieValidationKey' => 'fill in a secret key here',
            ],
        ],
    ];


  TRATAMENTO DE ERROS
  YII_ENABLE_ERROR_HANDLER é true, no script de entrada.
      return [
      'components' => [
          'errorHandler' => [
              'maxSourceLines' => 20,
          ],
      ],
    ];

    retorna isto ai de cima e podemos fazer com try catch esse tratament de errors
      use Yii;
      use yii\base\ErrorException;

      try {
        10/0;
      } catch (ErrorException $e) {
        Yii::warning("Division by zero.");
      }


  podemos dar throw error caso usuario faça uma requisição invalida ou inesperada.
  o manipulador de erro dira o status code corretamente.

  use yii\web\NotFoundHttpException;

  throw new NotFoundHttpException();

  o YII_DEBUG em dev fica true, em producao setams pra false. que vai personalizar 
  a exibição de erro corretamente. utiliza a view;
  @yii/views/errorHandler/error.php
  @yii/views/errorHandler/exception.php

  depois na url temos como tratar errors usando action configurando etc.
  https://www.yiiframework.com/doc/guide/2.0/pt-br/runtime-handling-errors


  GERENCIAMENTO DE LOGS

    yii fornece logs personalizaveis.
    -registrar mensagens de log 
    -configurar o destino do log 
    -examinar as msg de erro exportadas

    POdemos gravar mensagens com
    Yii::debug() - grava msg para reastrear como um determinado trecho de codfont
    Yii::info() - grava msg q transmit algumas informações uteis
    Yii::warning() - grava msg de aviso que indica algo inesperado aconteceu
    Yii::error() - grava fatalerror

    Destinos de log
    - é uma instancia de classe, filtra niveis e categoria e exporta pra algum meio.
    ex:banco de dados etc.
    --é preciso configurar component da aplicação dai.
          return [
        // o componente  "log" deve ser carregado durante o tempo de inicialização
        'bootstrap' => ['log'],
        
        'components' => [
            'log' => [
                'targets' => [
                    [
                        'class' => 'yii\log\DbTarget',
                        'levels' => ['error', 'warning'],
                    ],
                    [
                        'class' => 'yii\log\EmailTarget',
                        'levels' => ['error'],
                        'categories' => ['yii\db\*'],
                        'message' => [
                          'from' => ['log@example.com'],
                          'to' => ['admin@example.com', 'developer@example.com'],
                          'subject' => 'Database errors at example.com',
                        ],
                    ],
                ],
            ],
        ],
      ];

      este componente de log deve ser carregado durante a inicialização, por isto
      ele fica no boostrap.

      os logs podem ser dispachados pra varios lugares.
      -é preciso consultar a API, por exemplo
      --envia pra um banco de dados, ou email, ou em arquivos, ou em syslog do php.

      Filtragem de mensagem
      -error
      -warning
      -info
      -trace
      -profile

      podemos formatar mensagem, por padrão É
      Timestamp [IP address][User ID][Session ID][Severity Level][Category] Message Text

      e temos mais outras coisas complexas com log, como nivel de rastreio
      libertação e exportação de mensagens, alternar destino de log, criar novos Destinos
      perfil de desempenho

    
  ==========================================
    # CONCEITOS CHAVES 
      
      Componentes
      -propriedades
      -eventos
      -behaviors(comportamento)

      ja vimos lá no getting started
      <?php

        namespace yii\components\MyClass;

        use yii\base\BaseObject;

        class MyClass extends BaseObject
        {
          public $prop1;
          public $prop2;

          public function __construct($param1, $param2, $config = [])
          {
              // ... initialization before configuration is applied

              parent::__construct($config);
          }

          public function init()
          {
              parent::init();

              // ... initialization after configuration is applied
          }
        }

      configurando o component
      $component = new MyClass(1, 2, ['prop1' => 3, 'prop2' => 4]);
      // alternatively
      $component = \Yii::createObject([
        'class' => MyClass::className(),
        'prop1' => 3,
        'prop2' => 4,
      ], [1, 2]);


    PROPRIEDADES 

    temos os métodos getter and setter  
    namespace app\components;

      use yii\base\BaseObject;

      class Foo extends BaseObject
      {
          private $_label;

          public function getLabel()
          {
              return $this->_label;
          }

          public function setLabel($value)
          {
              $this->_label = trim($value);
          }
      }


    tem até uns atalhos.

    // equivalent to $label = $object->getLabel();
    $label = $object->label;

    // equivalent to $object->setLabel('abc');
    $object->label = 'abc';

  tem uma parada com trim() que fazendo aqueles bang ali não precisa chamar na maioria
  das calls.

  
  EVENTOS
  -permitem que você injete código personalizado dentro de outro código existente em 
  determinado pontos de execução

  function ($event) {
   // $event is an object of yii\base\Event or a child class
  }

  $event tem:
  -nome do evento
  -objeto chamador
  -dados personalizados

  adicionando manipuladores de evento
  $foo = new Foo;

  // esse manipulador é uma função global
  $foo->on(Foo::EVENT_HELLO, 'function_name');

  // esse manipulador é um método de objeto
  $foo->on(Foo::EVENT_HELLO, [$object, 'methodName']);

  // esse manipulador é um método estático da classe
  $foo->on(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

  // esse manipulador é uma função anônima
  $foo->on(Foo::EVENT_HELLO, function ($event) {
    // Código ...
  });


  --------------------------------------------
  // O código a seguir mostrará "abc" quando o evento for disparado
  // porque $event->data contêm os dados passados no terceiro parâmetro do "on"
  $foo->on(Foo::EVENT_HELLO, 'function_name', 'abc');

  function function_name($event) {
    echo $event->data;
  }


  Disparando eventos:
  namespace app\components;

  use yii\base\Component;
  use yii\base\Event;

  class Foo extends Component
  {
    const EVENT_HELLO = 'hello';

    public function bar()
    {
        $this->trigger(self::EVENT_HELLO);
    }
  }
  Com o código acima, todas as chamadas para bar () irão disparar um evento 
  chamado hello.


  outro exemplo com evento..
  namespace app\components;

  use yii\base\Component;
  use yii\base\Event;

  class MessageEvent extends Event
  {
    public $message;
  }

  class Mailer extends Component
  {
    const EVENT_MESSAGE_SENT = 'messageSent';

    public function send($message)
    {
        // ...sending $message...

        $event = new MessageEvent;
        $event->message = $message;
        $this->trigger(self::EVENT_MESSAGE_SENT, $event);
    }
  }

  trigger(), chama todos os manipuladores ligados ao evento passado.


  para desvincular manipuladores de eventos.

    // o manipulador é uma função global
  $foo->off(Foo::EVENT_HELLO, 'function_name');

  // o manipulador é um método de objeto
  $foo->off(Foo::EVENT_HELLO, [$object, 'methodName']);

  // o manipulador é um método de estático da Classe
  $foo->off(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

  // o manipulador é uma função anônima
  $foo->off(Foo::EVENT_HELLO, $anonymousFunction);


  ou desvincula todos manipuladores do evento mesmo.
  $foo->off(Foo::EVENT_HELLO);

  
  
  --podemos chamar eventos a níveis de classe também.
  use yii\base\Event;

  Event::on(Foo::className(), Foo::EVENT_HELLO, function ($event) {
    var_dump($event->sender);  // displays "null"
  });

  Event::trigger(Foo::className(), Foo::EVENT_HELLO);

  --para desvincular o evento.
  // desvincula $handler
  Event::off(Foo::className(), Foo::EVENT_HELLO, $handler);

  // Desvincula todos os manipuladores de Foo::EVENT_HELLO
  Event::off(Foo::className(), Foo::EVENT_HELLO);


  Eventos Globais existem, podemos chamar para todo APP
  use Yii;
  use yii\base\Event;
  use app\components\Foo;

  Yii::$app->on('bar', function ($event) {
    echo get_class($event->sender);  // Mostra na tela "app\components\Foo"
  });

  Yii::$app->trigger('bar', new Event(['sender' => new Foo]));



  BEHAVIORS 


  namespace app\components;

  use yii\base\Behavior;

  class MyBehavior extends Behavior
  {
    public $prop1;

    private $_prop2;

    public function getProp2()
    {
        return $this->_prop2;
    }

    public function setProp2($value)
    {
        $this->_prop2 = $value;
    }

    public function foo()
    {
        // ...
    }
  }


  temos propriedades como variáveis, e comportamento diferentes
  parecido com getter/setter


  aqui um exemplo de como colocar behavior no codigo
  public function behaviors()
   {
       return [
           // behavior anônimo, somente o nome da classe
           MyBehavior::className(),

           // behavior nomeado, somente o nome da classe
           'myBehavior2' => MyBehavior::className(),

           // behavior anônimo, array de configuração
           [
               'class' => MyBehavior::className(),
               'prop1' => 'value1',
               'prop2' => 'value2',
           ],

           // behavior nomeado, array de configuração
           'myBehavior4' => [
               'class' => MyBehavior::className(),
               'prop1' => 'value1',
               'prop2' => 'value2',
           ]
       ];

    
    podemos também colocar vários behaviors, com attach.
    $component->attachBehaviors([
    'myBehavior1' => new MyBehavior,  // um behavior nomeado
      MyBehavior::className(),          // um behavior anônimo 
    ]);



    então podemos utilizar behavior parecido com components, behavior vai ta nas propriedades
    do component e chamamos ele

      // "prop1" é uma propriedade definida na classe behavior 
    echo $component->prop1;
    $component->prop1 = $value;

    podemos desvincular behaviors. single ou all
    temos o timestampBehavior, praticamente timestamp.

    Behavior vs Traits
    behavior se comporta como classe, são comfiguráveis
    traits são mais eficiente q behavior, porém requerem mais tempo e memoria.



    CONFIGURAÇÕES   

      aqui temos varias configurações, por exemplo do banco de dados, dsn etc.
      e temos muitos outros tipos de config. no caso do template basic.


    temos a configuração de widget
    use yii\widgets\Menu;

    echo Menu::widget([
        'activateItems' => false,
        'items' => [
            ['label' => 'Home', 'url' => ['site/index']],
            ['label' => 'Products', 'url' => ['product/index']],
            ['label' => 'Login', 'url' => ['site/login'], 'visible' => Yii::$app->user->isGuest],
        ],
    ]);

    que no caso podemos colocar na view.

    os arquivos de configuração estão em web.php
    assim como as constantes de ambiente.


    ALIASES (apelidos)
    --apelidos dos caminhos geralmente

      // um alias de um caminho de arquivo
    Yii::setAlias('@foo', '/caminho/para/foo');

    // um alias de uma URL
    Yii::setAlias('@bar', 'http://www.exemplo.com.br');


  Você pode definir um alias usando outro alias (tanto raiz quanto derivado):

  Yii::setAlias('@foobar', '@foo/bar');
  -------------------

  também podemos recuperar com get
    Yii::getAlias('@foo/test/arquivo.php');  // exibe: /caminho/para/foo/test/arquivo.php
    Yii::getAlias('@foo/bar/arquivo.php');   // exibe: /caminho2/bar/arquivo.php

  existem alias já predefinidos
  -@yii
  -@app
  -@runtime
  -@webroot
  -@web
  -@vendor
  -@bower
  -@npm 


  um alias e automaticamente criado quando instalamos uma extensão.
  exemplo de como fica..

  Yii::setAlias('@yii/jui', 'VendorPath/yiisoft/yii2-jui');




  AUTOLOADING DE CLASSES  
  -ele é feito no arquivo yii.php, automaticamente;
  utiliza o autoloader do composer.


  SERVICE LOCATOR
  -Um service locator é um objeto que sabe como fornecer todos os tipos de serviços 
  (ou componentes) que uma aplicação pode precisar.

  aqui mais ou menos como funciona na classe, e depois chamando a classe.
  class SolrServiceBuilder
  {
      public static function build($ip)
      {
          return function () use ($ip) {
              $solr = new app\components\SolrService($ip);
              // ... outras inicializações ...
              return $solr;
          };
      }
  }

  return [
      // ...
      'components' => [
          // ...
          'search' => SolrServiceBuilder::build('127.0.0.1'),
      ],
  ];


  CONTAINER DE INJEÇÃO DE DEPENDÊNCIA 
  - é um objeto que sabe como instanciar e configurar objetos 
    e todas as suas dependências

   yii\di\Container
   -injeção de construtor
   -injeção de setter e propriedade
   -injeção de php callable

  mais sobre DI 
    https://www.yiiframework.com/doc/guide/2.0/pt-br/concept-di-container

  
  ==========================================
    # TRABALHANDO COM BANCO DE DADOS 






  ==========================================
    # SEGURANÇA

      !!AUTENTICAÇÃO!!(https://www.yiiframework.com/doc/guide/2.0/pt-br/security-authentication)
      
      processo de verificação de identidade do usuário, nome/token/etc
      ---yii\web\user 

            return [
            'components' => [
                'user' => [
                    'identityClass' => 'app\models\User',
                ],
            ],
        ];

      no caso precisamos da getAuthKey() e validateAuthKey(), para validar usuario, porém
      neste link temos outros métodos, e também se gravamos em cookie o user.

      Para logar um usuário, você pode usar o seguinte código:

      // encontrar uma identidade de usuário com o nome de usuário especificado.
      // observe que você pode querer checar a senha se necessário
      $identity = User::findOne(['username' => $username]);

      // logar o usuário
      Yii::$app->user->login($identity);

      Para realizar o logout de um usuário, simplesmente chame:

      Yii::$app->user->logout();

      ele também destruirá todos os dados da sessão do usuário. 
      Se você quiser guardar os dados da sessão, você deve chamar 
      Yii::$app->user->logout(false).

      existe também EVENTOS para autenticação
      EVENT_BEFORE_LOGIN
      EVENT_AFTER_LOGIN
      EVENT_BEFORE_LOGOUT
      EVENT_AFTER_LOGOUT
    


    !!AUTORIZAÇÃO!! (https://www.yiiframework.com/doc/guide/2.0/pt-br/security-authorization)

    verifica se o user tem permissão para fazer algo dentro da app.
    oferece o Filtro de Controle de Acesso(ACF) e Controle de Acesso Baseado em Role (RBAC)

    ACF apenas no controller, varias rules, e permissões que o usuário poderá fazer.
    behaviors = comportamento

    use yii\web\Controller;
    use yii\filters\AccessControl;

    class SiteController extends Controller
    {
      public function behaviors()
      {
          return [
              'access' => [
                  'class' => AccessControl::className(),
                  'only' => ['login', 'logout', 'signup'],
                  'rules' => [
                      [
                          'allow' => true,
                          'actions' => ['login', 'signup'],
                          'roles' => ['?'],
                      ],
                      [
                          'allow' => true,
                          'actions' => ['logout'],
                          'roles' => ['@'],
                      ],
                  ],
              ],
          ];
      }
      // ...
    }


    deny callbacks

      [
    'class' => AccessControl::className(),
    ...
    'denyCallback' => function ($rule, $action) {
        throw new \Exception('Você não está autorizado a acessar esta página');
        }
      ]

    
    temos um exemplo também de matchCallBack, lógica de validação de acesso,
    no caso, uma página disponível somente em uma certa data.

    use yii\filters\AccessControl;

    class SiteController extends Controller
    {
      public function behaviors()
      {
          return [
              'access' => [
                  'class' => AccessControl::className(),
                  'only' => ['special-callback'],
                  'rules' => [
                      [
                          'actions' => ['special-callback'],
                          'allow' => true,
                          'matchCallback' => function ($rule, $action) {
                              return date('d-m') === '31-10';
                          }
                      ],
                  ],
              ],
          ];
      }

      // Match callback chamada! Esta página pode ser acessado somente a cada 31 de outubro
      public function actionSpecialCallback()
      {
          return $this->render('happy-halloween');
      }
    }


    RBAC
      uma role representa coleção de permissão.(criar posts, atualizar posts etc);
      pode ser atribuída a um ou vários usuários.

  então temos a config do phpManager ou DbManager, que é feito pela config em components
  ++rbac (rolesPadrões);





