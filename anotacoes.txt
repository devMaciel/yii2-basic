# Start Forms
  --SiteController: criar o model request(post) validate, view
  --Model: Formulario de Registro, model rules
  --View: Formulário(widgets)
  --View: Resposta do formulário

# Banco de Dados, ActiveRecord(sintaxe tipo eloquent(laravel))
  --Criar ActiveRecord (models), [Customer]
  --Checar conexão (config.db)
  ----querybuilder https://www.yiiframework.com/doc/guide/2.0/pt-br/db-query-builder#query-methods

  DB Browser SQLITE
  --schema/table
  --model: pais
  --PaisController: active record query's
  --'dsn' => 'sqlite:teste.sqlite', (cria banco em web->testesql)
  --view: pasta da action e index, view render db

# Gerando código com GII (https://www.yiiframework.com/doc/guide/2.0/pt-br/start-gii)
  --Models 
  --generate/overwrite - tableName - ModelClassName (pais-Pais), ctrl+c ou overwrite.

  --generate crud
  Model Class
    app\models\Pais
  Search Model Class
    app\models\PaisSearch
  Controller Class
    app\controllers\PaisController
  View Path
    @app/views/pais
  
  --criar namespace do models, o PaisSearch é a nova do crud, adicona o controller
    e a view, já criamos o controller model e view, e precisamos dar overwrite, 
    para criar os códigos template com support ao crud.

  urlparam: ?r=pais/index.
  urlparam-pais(update/delete): ?r=pais%2Fview&id=SS

# Seguindo em Frente (https://www.yiiframework.com/doc/guide/2.0/pt-br/start-looking-ahead)
- Docs (classes) - https://www.yiiframework.com/doc/api/2.0/index
- Wiki (forum/stack somente o yii2) - https://www.yiiframework.com/wiki?tag=yii2
- O Guia - https://www.yiiframework.com/doc/guide/2.0/pt-br
- Plugins/Extensões do yii2 - https://www.yiiframework.com/extensions

# Estrutura da Aplicação
- https://www.yiiframework.com/doc/guide/2.0/pt-br/structure-overview
-- Defined(const) em scripts de entrada, (modo web, console)
  EXEMPLO DO SCRIPT DE entrada
    require __DIR__ . '/../vendor/autoload.php';
    require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

    // carrega a configuração da aplicação
    $config = require __DIR__ . '/../config/web.php';

    // instancia e configura a aplicação
    (new yii\web\Application($config))->run();
  
  temos este arquivo rodando nosso basic app, temos as constantes/autoloads/vendor.

  Propiedades da App, required.
  id;basePath, 
    id geralmente ja vem um, a nao ser que tenha mais de uma app.
    basePath, caminho da app, do codfont, podemos criar aliases(atalhos), base path(@app)

    Exemplo de ALIASES
    [
      [
        'aliases' => [
          '@name1' => 'path/to/path1',
          '@name2' => 'path/to/path2',
      ],
    ]

  bootstrap da app
  -array de componentes, modulos, regras da app, que pode ser carregado junto com a app.
    exemplo do debug e o gii

  outras propriedades:
  --catchAll, pega todas requisições web para mostrar.
  --components - consegue armazenar lista de components, como cache/users/autologin etc
    tipo um bootstraping
  --ControllerMap, pega o controller e configura algumas coisas, como csrf token.
  --ControllerNamespace, como nome ja diz, consegue modificar o namespace do controller.
  --language, muda linguangem para o usuario final, padrão. 
  --modules, modules e configurações, ex: da config da database.
  --names/--params/--sourceLanguage/--timeZone/--version/--charset
    --defaultRoute/--extensions(plugins)
  
  --layout, layout da app, headers/footers etc, /--layoutPath
  --runtimePath, arquivos temporários/cache
  --viewpath/--vendorPath

  EVENTOS DA APLICAÇÃO
  [
    'on beforeRequest' => function ($event) {
        // ...
    },
  ]

  EVENT_BEFORE_REQUEST (antes do post)
  EVENT_AFTER_REQUEST  (depois do post)
  EVENT_BEFORE_ACTION   (antes de executar cada action controller)
  EVENT_AFTER_ACTION    (depois de executar cada action controller)

  LIFE CICLE
  -Script de entrada, carrega as config como array
  
  -- cria uma nova instancia da app
  --- preInit() config alta prioridade como o basePath
  --- config das propriedades da app
  --- init() chama o bootstrap() roda os components de inicialização

  ---- yii2 app run..
  ---- dispara os eventos, os before
  ---- resolve as rotas, params, model, controllers actions
  ---- dispara os eventos after 
  ---- envia resposta pro final user.

  ----- status code e completa o processamento.

  MVC
  Controllers/Rotas
  --Rotas é baseado na action e nos controllers
  Segue alguns exemplos, assumindo que o namespace do controller tenha por 
  padrão o valor app\controllers:

  article torna-se app\controllers\ArticleController;
  post-comment torna-se app\controllers\PostCommentController;
  admin/post-comment torna-se app\controllers\admin\PostCommentController;
  adminPanels/post-comment torna-se app\controllers\adminPanels\PostCommentController.

  também é possível mapear os controllers, para seguir um padrão, quando vem de crosssite.
  [
    'controllerMap' => [
        // declara o controller "account" usando um nome de classe
        'account' => 'app\controllers\UserController',

        // declara o controller "article" usando uma configuração em array
        'article' => [
            'class' => 'app\controllers\PostController',
            'enableCsrfValidation' => false,
        ],
    ],
  ]

  Segue algumas boas práticas em destaque. Os controllers:

  podem acessar os dados de uma requisição;

  podem chamar os métodos dos models e outros componentes de serviço com dados 
  da requisição;
  podem usar as views para compor as respostas;

  NÃO devem processar os dados da requisição - isto deve ser feito na 
  camada model (modelo);

  devem evitar inserir códigos HTML ou outro código de apresentação - é 
  melhor que sejam feitos nas views.

  Models
  -temos nossos request;rules/validations/atributos, nossa conexão com algumas
    tabela do db que passa pro controller dps como variável/const.

  atribuição em massa, podemos fazer apenas com atributos seguros(safe)
  public function rules()
  {
      return [
          [['title', 'description'], 'safe'],
      ];
  }

  não seguros podemos colocar !
  public function scenarios()
  {
      return [
          'login' => ['username', 'password', '!secret'],
      ];
  }

  na exportação de dados, são convertidos em arrays, porém podemos especificar depois
  para retornar um outro tipo de dado.

  boas praticas no model
  Em resumo, os models (modelos):

  podem conter atributos para representar os dados de negócio;
  podem conter regras de validação para garantir a validade e integridade dos dados;
  podem conter métodos para implementar lógicas de negócio;
  NÃO devem acessar diretamente as requisições, sessões ou quaisquer dados do ambiente do usuário. Os models (modelos) devem receber estes dados a partir dos controllers (controladores);
  devem evitar inserir HTML ou outros códigos de apresentação – isto deve ser feito nas views (visões);
  devem evitar ter muitos cenários em um único model (modelo).

  Views 
  --Segurança, sobre Html::encode, codifica o nome de usuario antes de exibi-lo

      <?php
      use yii\helpers\Html;
      ?>

      <div class="username">
          <?= Html::encode($user->name) ?>
      </div>

    Exibir conteúdo html, filtrar conteudo primeiro, ele é mais lento, então é melhor
    guardar em cache, se for usar muitas vezes.

      <?php
      use yii\helpers\HtmlPurifier;
      ?>

      <div class="post">
          <?= HtmlPurifier::process($post->text) ?>
      </div>

    
    além da render() temos outros tipos de render()...

    Nos controllers, você pode chamar os seguintes métodos para renderizar as views:

    render(): renderiza uma view nomeada e aplica um layout ao resultado da renderização.
    renderPartial(): renderiza uma view nomeada sem qualquer layout.
    renderAjax(): renderiza uma view nomeada sem qualquer layout e injeta todos os arquivos JS/CSS registrados. É geralmente utilizado em respostas de requisições Web Ajax.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.
    renderContent(): renderiza um conteúdo estático que será incorporado no layout selecionado. Este método está disponível desde a versão 2.0.1.

    na renderização de widgets podemos utiliar as seguintes:
    render(): renderiza uma view nomeada.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.

    podemos renderizar uma view dentro de outra:
    render(): renderiza uma view nomeada.
    renderAjax(): renderiza uma view nomeada sem qualquer layout e injeta todos os arquivos JS/CSS registrados. É geralmente utilizado em respostas de requisições Web Ajax.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.

    <?= $this->render('_visao-geral') ?>

    renderização de outros lugares, no código
    // exibe a view "@app/views/site/license.php"
    echo \Yii::$app->view->renderFile('@app/views/site/license.php');

    Compartilhando Dados entre as Views
    O componente view fornece a propriedade params que você pode usar para compartilhar dados entre as views.

    Por exemplo, em uma view sobre, você pode ter o seguinte código que especifica o seguimento atual do "rastro de navegação" (breadcrumbs):

    $this->params['breadcrumbs'][] = 'Sobre nós';
    Em seguida, no arquivo layout, que também é uma view, você pode exibir o "rastro de navegação" (breadcrumbs) usando os dados passados pela propriedade params:

    <?= yii\widgets\Breadcrumbs::widget([
        'links' => isset($this->params['breadcrumbs']) ? $this->params['breadcrumbs'] : [],
    ]) ?>




    Exemplo de layout, header/footer - content

    <?php
      use yii\helpers\Html;

      /* @var $this yii\web\View */
      /* @var $content string */
      ?>
      <?php $this->beginPage() ?>
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8"/>
          <?= Html::csrfMetaTags() ?>
          <title><?= Html::encode($this->title) ?></title>
          <?php $this->head() ?>
      </head>
      <body>
      <?php $this->beginBody() ?>
          <header>Minha Empresa</header>
          <?= $content ?>
          <footer>&copy; 2014 por Minhas Empresa</footer>
      <?php $this->endBody() ?>
      </body>
      </html>
      <?php $this->endPage() ?>



      Podemos utilizar layouts aninhados

      <?php $this->beginContent('@app/views/layouts/base.php'); ?>

      ...conteúdoo do layout filho aqui...

      <?php $this->endContent(); ?>

      
      podemos definir blocos no meio do layout também
      <?php $this->beginBlock('bloco1'); ?>

      ...conteúdoo do bloco1...

      <?php $this->endBlock(); ?>

      ...

      <?php $this->beginBlock('bloco3'); ?>

      ... conteúdoo do bloco3...

      <?php $this->endBlock(); ?>

      
      dai no layout temos que colocar o content do bloco também;
      ...
      <?php if (isset($this->blocks['bloco1'])): ?>
          <?= $this->blocks['bloco1'] ?>
      <?php else: ?>
          ... conteúdoo padrãoo para o bloco1 ...
      <?php endif; ?>


    Temos TEMAS, de widgets/modules e herança de temas

    ----------TODO-----------
    continuando na estrutura da documentação

    Config de title dapágina normal, tipo layout

    <?php
      $this->title = 'Título da Minha Página';
    ?>

    e dentro do layout encoded
    <title><?= Html::encode($this->title) ?></title>

    META TAGS 
    <?php
    $this->registerMetaTag(['name' => 'keywords', 'content' => 'yii, framework, php']);
    ?>

    KEYWORDS 
    <meta name="keywords" content="yii, framework, php">

    TAG LINKS
      $this->registerLinkTag([
      'title' => 'Notícias sobre o Yii',
      'rel' => 'alternate',
      'type' => 'application/rss+xml',
      'href' => 'http://www.yiiframework.com/rss.xml/',
    ]);

    codigo acima vai da nisso aqui:
    <link title="Notícias sobre o Yii" rel="alternate" type="application/rss+xml" href="http://www.yiiframework.com/rss.xml/">

    View também tem seus EVENTOS
    EVENT_BEFORE_RENDER
    EVENT_AFTER_RENDER
    EVENT_BEGIN_PAGE
    EVENT_END_PAGE
    EVENT_BEGIN_BODY
    EVENT_END_BODY


    exemplo de renderizar data com yii2 com php
    \Yii::$app->view->on(View::EVENT_END_BODY, function () {
     echo date('Y-m-d');
    });

    Página estáticas são aquelas que não existem nada de param de database ou vem do
    form.

    public function actionAbout()
    {
        return $this->render('about');
    }

    para repetir varias paginas estaticas podemos colocar uma action"externa" standalone.


    namespace app\controllers;

    use yii\web\Controller;

    class SiteController extends Controller
    {
        public function actions()
        {
            return [
                'page' => [
                    'class' => 'yii\web\ViewAction',
                ],
            ];
        }
    }


  BOAS PRATICAS da view
  Views são responsáveis por apresentar models (modelos) no formato que os usuários finais desejam. Em geral, views:

  devem conter principalmente código de apresentação, tal como o HTML, e trechos simples de PHP para percorrer, formatar e renderizar dados.
  não devem conter código de consulta ao banco de dados. Consultas assim devem ser feitas nos models.
  devem evitar acessar diretamente os dados da requisição, tais como $_GET e $_POST pois essa tarefa cabe aos controllers. Se os dados da requisição forem necessários, deverão ser fornecidos às views pelos controllers.
  podem ler as propriedades dos models, mas não devem alterá-las.
  Para tornar as views mais gerenciáveis, evite criar views muito complexas ou que contenham muito código redundante. Você pode usar as seguintes técnicas para atingir este objetivo:

  use layouts para representar as seções de apresentação comuns (por exemplo, cabeçalho e rodapé).
  divida uma view complicada em varias outras menores. As views menores podem ser renderizadas e montadas em uma maior usando os métodos descritos anteriormente.
  crie e use widgets como blocos de construção das views.
  crie e use as classes helper (auxiliares) para transformar e formatar os dados nas views.

  

  MODULES/FILTROS/
      filtro é tipo aqueles comportamentos(behaviors) na parte de auth também.
    contentNegotiator também filtras os dados, com se recebesse response em xml ou json.

    use yii\filters\ContentNegotiator;
    use yii\web\Response;

    public function behaviors()
    {
        return [
            [
                'class' => ContentNegotiator::className(),
                'formats' => [
                    'application/json' => Response::FORMAT_JSON,
                    'application/xml' => Response::FORMAT_XML,
                ],
                'languages' => [
                    'en-US',
                    'de',
                ],
            ],
        ];
    }

    PageCache, temos cache de página tbm, e fica dentro dos behaviors
    RateLimiter/VerbFilter

    Cors(cross origin resource sharing) acesso vindo de outros sites,
    podemos restringir acesso somente a um dominio, no caso o nosso tbm.


    WIDGETS 
      temos vários widgets, tipo uns plugins ou mini components, para usar na view
      datepicker, os forms.

    exemplo:
   
    namespace app\components;

    use yii\base\Widget;
    use yii\helpers\Html;

    class HelloWidget extends Widget
    {
        public $message;

        public function init()
        {
            parent::init();
            if ($this->message === null) {
                $this->message = 'Hello World';
            }
        }

        public function run()
        {
            return Html::encode($this->message);
        }
    }
    Para usar este widget, simplesmente insira o código a seguir em uma view (visão):

    <?php
    use app\components\HelloWidget;
      ?>
    <?= HelloWidget::widget(['message' => 'Good morning']) ?>

    Aqui temos o exemplo com buffer
    namespace app\components;

    use yii\base\Widget;
    use yii\helpers\Html;

    class HelloWidget extends Widget
    {
        public function init()
        {
            parent::init();
            ob_start();
        }

        public function run()
        {
            $content = ob_get_clean();
            return Html::encode($content);
        }
    }

    Como você pode ver, o buffer de saída do PHP é iniciado no método init() 
    para que qualquer conteúdo entre as chamadas de init() e run() possam ser 
    capturadas, processadas e retornadas em run().

    widgets é mais pra reuso de código na view, deve seguir o padrão MVC
    são autossuficientes e podem ser removidos da view sem fazer qualquer outra coisa.


  ASSETS
  Um asset no Yii é um arquivo que pode ser referenciado em uma página Web.
  parecido com do laravel, assets que podemos pegar nossos scripts de css ou js

  asset bundle, é uma coleção de assets, localizados em um diretório;
  exemplo:

  <?php

  namespace app\assets;

  use yii\web\AssetBundle;

  class AppAsset extends AssetBundle
  {
      public $basePath = '@webroot';
      public $baseUrl = '@web';
      public $css = [
          'css/site.css',
      ];
      public $js = [
      ];
      public $depends = [
          'yii\web\YiiAsset',
          'yii\bootstrap\BootstrapAsset',
      ];
  }

  então temos todas aquelas coisas, de asset js/css. e outras coisas.
  -sourcePath
  -basePath
  -baseUrl-js-css-depends-jsOptions
  -cssOptions
  -publishOptions

  Observação: Não use o @webroot/assets como o caminho da fonte. 
  Este diretório é usado por padrão pelo gerenciador de asset para 
  salvar os arquivos de asset publicados a partir de seu local de origem. 
  Qualquer conteúdo deste diretório será considerado como temporário e podem 
  estar sujeitos a serem deletados.

  <?php
  namespace app\assets;

  use yii\web\AssetBundle;

  class FontAwesomeAsset extends AssetBundle 
  {
      public $sourcePath = '@bower/font-awesome'; 
      public $css = [ 
          'css/font-awesome.min.css', 
      ]; 
      
      public function init()
      {
          parent::init();
          $this->publishOptions['beforeCopy'] = function ($from, $to) {
              $dirname = basename(dirname($from));
              return $dirname === 'fonts' || $dirname === 'css';
          };
      }
  }  
  O exemplo anterior define um asset bundle para o pacode de "fontawesome". 
  Ao especificar a opção de publicação beforeCopy, apenas os subdiretórios 
  fonts e css serão publicados.

  Assets do BOWER E NPM, pacotes js são gerenciados pelo Bower e NPM.

  temos o Cache Busting, que deixa os assets em cache, porém é preciso configurar
  também um timestamp para ele poder procurar o asset mais recente, caso adicione mais
  coisa depois no ambiente de produção

    return [
      // ...
      'components' => [
          'assetManager' => [
              'appendTimestamp' => true,
          ],
      ],
  ];

  dai temos até conversões de assets, mais configs etc. que podemso utilizar
  less/scss/stylus/coffeescript/typescript

  podemos e devemos combinar/comprimir nossos assets, para evitar muitas requisições http

  Localize todos os asset bundles em sua aplicação que você deseja combinar e comprimir.

  Divida estes bundles em um ou alguns grupos. Observe que cada bundle pode apenas 
  pertencer a um único grupo.

  Combinar/Comprimir os arquivos CSS de cada grupo em um único arquivo. 

  Faça isto de forma semelhante para os arquivos JavaScript.

  Defina um novo asset bundle para cada grupo:
  Defina as propriedade css e js com os arquivos CSS e JavaScript combinados, 
  respectivamente.

  Personalize os asset bundles de cada grupo definindo as suas propriedades 
  css e js como vazias e definindo a sua propriedade depends para ser o 
  novo asset bundle criado para o grupo.

  podemos fazer isto com as ferramentas, (CLOSURE COMPILER, YUI COMPRESSOR)

  da pra agrupar assset bundles também, como allshared/allfrontend/allbackend

  EXTENSÕES 
    tipo nossas dependencies, nos arquivos json, que pegamos com composer mesmo.
    composer.json q temos todo objeto com varios negocios, dependencias, até TAGS
    {
        // nome do pacote
        "name": "yiisoft/yii2-imagine",

        // tipo de pacote
        "type": "yii2-extension",

        "description": "The Imagine integration for the Yii framework",
        "keywords": ["yii2", "imagine", "image", "helper"],
        "license": "BSD-3-Clause",
        "support": {
            "issues": "https://github.com/yiisoft/yii2/issues?labels=ext%3Aimagine",
            "forum": "http://www.yiiframework.com/forum/",
            "wiki": "http://www.yiiframework.com/wiki/",
            "irc": "irc://irc.freenode.net/yii",
            "source": "https://github.com/yiisoft/yii2"
        },
        "authors": [
            {
                "name": "Antonio Ramirez",
                "email": "amigo.cobos@gmail.com"
            }
        ],

        // dependências do pacote
        "require": {
            "yiisoft/yii2": "~2.0.0",
            "imagine/imagine": "v0.5.0"
        },

        // especifica as classes autoloading 
        "autoload": {
            "psr-4": {
                "yii\\imagine\\": ""
            }
        }
    }


    namespace deve ser nomeado seguindo o padrão psr-4 ou psr-0
    não pode utilizar 'yii,yii2,yiisoft' como nome do vendor, pq são palavras 
    reservadas do codigo nativo do yii.
    

    existem extensoes nativas também, que estão no packagist.
    https://www.yiiframework.com/doc/guide/2.0/pt-br/structure-extensions
    
    apidoc - gerar api de doc do framework
    authclient - auth de clientes, contas etc
    bootstrap - widgets que encapsulam os components e plugins
    codeception - suporte a testes
    debug - debug o yii
    elasticsearch - consultas/pesquisas básicas, implementa tbm o active record.
    faker - dados falsos para gerar pra testar ou sei lá
    gii - gerador de código, que já vimos
    httpclient - httpclient v;
    imagine - funcoes de manipulação de imagens
    jui - conjunto de widgets
    mongodb - suporte pra uso do db mongodb
    redis - suporte para uso do redis, consulta basica, activerecord,cache..
    smarty - motor de template-
    sphinx - suporte pra uso do sphinx, mesma coisa de cima praticamente
    swiftmailer - fornece recursos para envio de emails
    twig- motor de template tbm.


  ==========================================
    # TRATANDO REQUISIÇÕES  

    visão geral de como funciona em imagem.
    depois falamos da inicialização - bootstrapping
    roteamento e criação de url, que é feita pelo UrlManager
    que já vimos também sobre o prettyUrl

      use yii\helpers\Url;

      // Url::to() chama UrlManager::createUrl() para criar uma URL
      $url = Url::to(['post/view', 'id' => 100]);
    
    que geralmente fica assim
      /index.php?r=post/view&id=100
      /index.php/post/100
      /posts/100

  rotemando vai criando 'automaticamente' com base no controller view etc
  precisamos nomear as pastas corretamentas e feita pelas actions.

  temos rotaPadrão
    [
      // ...
      'defaultRoute' => 'main/index',
    ];
  
  rota catchAll
    pega todas rotas, talvez para fazer manutenção
    [
      // ...
      'catchAll' => ['site/offline'],
    ];

  Para Criar URL's temos o Url::to

    use yii\helpers\Url;

  // cria uma URL para uma rota: /index.php?r=post/index
  echo Url::to(['post/index']);

  // cria uma URL para uma rota com parâmetros: /index.php?r=post/view&id=100
  echo Url::to(['post/view', 'id' => 100]);

  // cria uma URL ancorada: /index.php?r=post/view&id=100#content
  echo Url::to(['post/view', 'id' => 100, '#' => 'content']);

  // cria uma URL absoluta: http://www.example.com/index.php?r=post/index
  echo Url::to(['post/index'], true);

  // cria uma URL absoluta usando https: https://www.example.com/index.php?r=post/index
  echo Url::to(['post/index'], 'https');


  podemos setar alias também para url não relacionadas.

  use yii\helpers\Url;

    // rota atual requerida: /index.php?r=admin/post/index
    echo Url::to();

    // uma alias da URL: http://example.com
    Yii::setAlias('@example', 'http://example.com/');
    echo Url::to('@example');

    // uma URL absoluta: http://example.com/images/logo.gif
    echo Url::to('/images/logo.gif', true);


  além to url::to() temos outras aqui.

    use yii\helpers\Url;

    // URL da página inicial: /index.php?r=site/index
    echo Url::home();

    // URL base, útil se a aplicação for implementada em uma subpasta da pasta raiz do servidor Web
    echo Url::base();

    // A URL canônica da requisição atual
    // Veja mais detalhes em https://en.wikipedia.org/wiki/Canonical_link_element
    echo Url::canonical();

    // Obtêm a URL da requisição anterior para reutilizá-la em requisições futuras
    Url::remember();
    echo Url::previous();

  
    para usar as PRETTY URL

      [
          'components' => [
              'urlManager' => [
                  'enablePrettyUrl' => true,
                  'showScriptName' => false,
                  'enableStrictParsing' => false,
                  'rules' => [
                      // ...
                  ],
              ],
          ],
      ]

  então temos mais coisas aqui sobre as regras da url e param nomeados
  https://www.yiiframework.com/doc/guide/2.0/pt-br/runtime-routing

  temos o sufixo na url.

      [
        'components' => [
            'urlManager' => [
                'enablePrettyUrl' => true,
                'showScriptName' => false,
                'enableStrictParsing' => true,
                'suffix' => '.html',
                'rules' => [
                    // ...
                    [
                        'pattern' => 'posts',
                        'route' => 'post/index',
                        'suffix' => '.json',
                    ],
                ],
            ],
        ],
    ]

  
  métodos HTTP

    [
      'PUT,POST post/<id:\d+>' => 'post/create',
      'DELETE post/<id:\d+>' => 'post/delete',
      'post/<id:\d+>' => 'post/view',
    ] 

  temos como criar classes de regras, que vem da UrlRule, mas é flexível para alterar
  é uma mãozinha.
  
  caso a url use o mesmo prefixo em seus padrões e rotas, temos o groupUrlRule.
  


  REQUISIÇÕES

  temos nossos parâmetros de requisição, $_GET $_POST.

      $request = Yii::$app->request;

    $get = $request->get(); 
    // equivalente à: $get = $_GET;

    $id = $request->get('id');   
    // equivalente à: $id = isset($_GET['id']) ? $_GET['id'] : null;

    $id = $request->get('id', 1);   
    // equivalente à: $id = isset($_GET['id']) ? $_GET['id'] : 1;

    $post = $request->post(); 
    // equivalente à: $post = $_POST;

    $name = $request->post('name');   
    // equivalente à: $name = isset($_POST['name']) ? $_POST['name'] : null;

    $name = $request->post('name', '');   
    // equivalente à: $name = isset($_POST['name']) ? $_POST['name'] : '';

    temos ai algumas coisitas.

  para restful api, enviados pleo metodos put patch.
  $request = Yii::$app->request;

  // retorna todos os parâmetros 
  $params = $request->bodyParams;

  // retorna o parâmetro "id"
  $param = $request->getBodyParam('id');


  métodos de requisição
  $request = Yii::$app->request;
  if ($request->isAjax) { /* a requisição é uma requisição Ajax */ }
  if ($request->isGet)  { /* o método da requisição é GET */ }
  if ($request->isPost) { /* o método da requisição é POST */ }
  if ($request->isPut)  { /* o método da requisição é PUT */ }
  
  URLs da requisição
    temos pelo componente request, muitas formas de inspecionar a atual url da request.

    url - retorna a url sem info de protocolos e dominio 
      (/admin/index.php/product?id=100)

    absoluteUrl - url completoa, incluindo info do protocolo e dominio
      (http://example.com/admin/index.php/product?id=100)
    
    hostInfo - retorn o que são as info de protocolo e dominio
      (http://example.com)

    pathInfo - informa depois do script de etnrada e antes da interroção(query string)
      (/product)

    queryString - retorna a info depois da query string
      (id=100)

    baseUrl - retorna a info depois do dominio e antes do script de entrada
      (/admin)

    scriptUrl - retorna a info depois do dominio ate o script de entrada.
      (/admin/index.php)

    serverName - retorna o dominio da url
      (example.com)

    serverPort - retorna qual ap orta utilizada pelo servidor web
      (80)


  Header(cabeçalho) HTTP

  // $headers é um objeto de yii\web\HeaderCollection 
  $headers = Yii::$app->request->headers;

  // retorna o valor do cabeçalho Accept
  $accept = $headers->get('Accept');

  if ($headers->has('User-Agent')) { /* existe o cabeçalho User-Agent */ }

  assim como algumas outras coisas como
  -userAgent
  -contentType
  -acceptableContentTypes
  -acceptableLanguages

  Informações do Cliente ( host e IP )
  $userHost = Yii::$app->request->userHost;
  $userIP = Yii::$app->request->userIP;

  RESPOSTAS(RESPONSES) 
  https://www.yiiframework.com/doc/guide/2.0/pt-br/runtime-responses
    temos o status code
    Yii::$app->response->statusCode = 200;

  alguns verbos http mais comuns
  400 - bad request
  404 - not found
  409 - conflit HttpException
  403 - forbidden ..
  410 - gone
  405 - method not allowed
  406 - not accepttable
  500 - server error
  429 - too many request
  401 - unauthorized
  415 - unsupported media type

  sobre http headers, response HeaderCollection

  Response Body

    Yii::$app->response->content = 'hello world!';

  também podemos formatar como vai vir a 'data'

    $response = Yii::$app->response;
    $response->format = \yii\web\Response::FORMAT_JSON;
    $response->data = ['message' => 'hello world'];

  yii suporta
  -html
  -xml
  -json
  -jsonp 
  -raw

  public function actionInfo()
  {
      \Yii::$app->response->format = \yii\web\Response::FORMAT_JSON;
      return [
          'message' => 'hello world',
          'code' => 100,
      ];
  }

  temos nosso Redirect, e status code.
  
  public function actionOld()
  {
      return $this->redirect('http://example.com/new', 301);
  }

  \Yii::$app->response->redirect('http://example.com/new', 301)->send();

  para x-redirect - ajax(async)
  https://www.yiiframework.com/doc/api/2.0/yii-web-response#redirect()-detail


  Enviando Files
  public function actionDownload()
  {
      return \Yii::$app->response->sendFile('path/to/file.txt');
  }

  se chamar de outro lugar que nao for do actionMethod
    \Yii::$app->response->sendFile('path/to/file.txt')->send();

  
  Enviando Resposta, tem a estrutura de como é enviado as response.


  SESSÕES E COOKIES
  para abrir e fechar sessões.

  $session = Yii::$app->session;

  // verifica se a sessão está pronta para abrir
  if ($session->isActive) ...

  // abre uma sessão
  $session->open();

  // fecha uma sessão
  $session->close();

  // destrói todos os dados registrados em uma sessão.
  $session->destroy();

  
  para acessar dados da sessão

  $session = Yii::$app->session;

  // obter uma variável de sessão. Os exemplos abaixo são equivalentes:
  $language = $session->get('language');
  $language = $session['language'];
  $language = isset($_SESSION['language']) ? $_SESSION['language'] : null;

  // definir uma variável de sessão. Os exemplos abaixo são equivalentes:
  $session->set('language', 'en-US');
  $session['language'] = 'en-US';
  $_SESSION['language'] = 'en-US';

  // remover uma variável de sessão. Os exemplos abaixo são equivalentes:
  $session->remove('language');
  unset($session['language']);
  unset($_SESSION['language']);

  // verifica se a variável de sessão existe. Os exemplos abaixo são equivalentes:
  if ($session->has('language')) ...
  if (isset($session['language'])) ...
  if (isset($_SESSION['language'])) ...

  // percorrer todas as variáveis de sessão. Os exemplos abaixo são equivalentes:
  foreach ($session as $name => $value) ...
  foreach ($_SESSION as $name => $value) ...


  Session de arrays
  $session = Yii::$app->session;

  // o seguinte código não funciona
  $session['captcha']['number'] = 5;
  $session['captcha']['lifetime'] = 3600;

  // o seguinte código funciona:
  $session['captcha'] = [
      'number' => 5,
      'lifetime' => 3600,
  ];

  // o seguinte código também funciona:
  echo $session['captcha']['lifetime'];



  temos soluções diferente pelo yii
  $session = Yii::$app->session;

  // use diretamente $_SESSION (certifique-se que Yii::$app->session->open() tenha sido chamado)
  $_SESSION['captcha']['number'] = 5;
  $_SESSION['captcha']['lifetime'] = 3600;

  // obter todo o array primeiro, modificá-lo e depois salvá-lo
  $captcha = $session['captcha'];
  $captcha['number'] = 5;
  $captcha['lifetime'] = 3600;
  $session['captcha'] = $captcha;

  // use ArrayObject em vez de array
  $session['captcha'] = new \ArrayObject;
  ...
  $session['captcha']['number'] = 5;
  $session['captcha']['lifetime'] = 3600;

  // armazenar dados de array utilizando chaves com um prefixo comum
  $session['captcha.number'] = 5;
  $session['captcha.lifetime'] = 3600;


  podemos salvar em session personalizadas, porem requer mais configurações
  como armazenar direto em cache ou db, porém é preciso criar database e outras
  configurações.

  Dados Flash
  -dado especial de sessao, só estão disponivies na proxima requisição e serão 
    automaticamente excluido depois. geralmente implementado para mensagens

    $session = Yii::$app->session;

    // Request #1
    // defini uma mensagem flash chamada "postDeleted"
    $session->setFlash('postDeleted', 'You have successfully deleted your post.');

    // Request #2
    // exibe uma mensagem flash chamada "postDeleted"
    echo $session->getFlash('postDeleted');

    // Request #3
    // $result será falso uma vez que a mensagem flash foi automaticamente excluída
    $result = $session->hasFlash('postDeleted');


    podemos utilizar isto juntamente com o ALERT widget
    echo Alert::widget([
      'options' => ['class' => 'alert-info'],
      'body' => Yii::$app->session->getFlash('postDeleted'),
    ]);

    Temos os COOKIES.
      // pega a coleção de cookie  (yii\web\CookieCollection) do componente "request"
    $cookies = Yii::$app->request->cookies;

    // pega o valor do cookie "language". se o cookie não existir, retorna "en" como o valor padrão.
    $language = $cookies->getValue('language', 'en');

    // um caminho alternativo para pegar o valor do cookie "language"
    if (($cookie = $cookies->get('language')) !== null) {
        $language = $cookie->value;
    }

    // você também pode usar $cookies como um array
    if (isset($cookies['language'])) {
        $language = $cookies['language']->value;
    }

    // verifica se existe um cookie "language"
    if ($cookies->has('language')) ...
    if (isset($cookies['language'])) ...


    Enviando Cookies para o usuário final
    // pega a coleção de cookie (yii\web\CookieCollection) do componente "response"
    $cookies = Yii::$app->response->cookies;

    // adicionar um novo cookie a resposta que será enviado
    $cookies->add(new \yii\web\Cookie([
        'name' => 'language',
        'value' => 'zh-CN',
    ]));

    // remove um cookie
    $cookies->remove('language');
    // outra alternativa para remover um cookie
    unset($cookies['language']);

    temos também a validação de cookie
    tudo que vier pelo setcookie ou $_COOKIE nao serão validados.

    return [
        'components' => [
            'request' => [
                'cookieValidationKey' => 'fill in a secret key here',
            ],
        ],
    ];


  TRATAMENTO DE ERROS
  YII_ENABLE_ERROR_HANDLER é true, no script de entrada.
      return [
      'components' => [
          'errorHandler' => [
              'maxSourceLines' => 20,
          ],
      ],
    ];

    retorna isto ai de cima e podemos fazer com try catch esse tratament de errors
      use Yii;
      use yii\base\ErrorException;

      try {
        10/0;
      } catch (ErrorException $e) {
        Yii::warning("Division by zero.");
      }


  podemos dar throw error caso usuario faça uma requisição invalida ou inesperada.
  o manipulador de erro dira o status code corretamente.

  use yii\web\NotFoundHttpException;

  throw new NotFoundHttpException();

  o YII_DEBUG em dev fica true, em producao setams pra false. que vai personalizar 
  a exibição de erro corretamente. utiliza a view;
  @yii/views/errorHandler/error.php
  @yii/views/errorHandler/exception.php

  depois na url temos como tratar errors usando action configurando etc.
  https://www.yiiframework.com/doc/guide/2.0/pt-br/runtime-handling-errors


  GERENCIAMENTO DE LOGS

    yii fornece logs personalizaveis.
    -registrar mensagens de log 
    -configurar o destino do log 
    -examinar as msg de erro exportadas

    POdemos gravar mensagens com
    Yii::debug() - grava msg para reastrear como um determinado trecho de codfont
    Yii::info() - grava msg q transmit algumas informações uteis
    Yii::warning() - grava msg de aviso que indica algo inesperado aconteceu
    Yii::error() - grava fatalerror

    Destinos de log
    - é uma instancia de classe, filtra niveis e categoria e exporta pra algum meio.
    ex:banco de dados etc.
    --é preciso configurar component da aplicação dai.
          return [
        // o componente  "log" deve ser carregado durante o tempo de inicialização
        'bootstrap' => ['log'],
        
        'components' => [
            'log' => [
                'targets' => [
                    [
                        'class' => 'yii\log\DbTarget',
                        'levels' => ['error', 'warning'],
                    ],
                    [
                        'class' => 'yii\log\EmailTarget',
                        'levels' => ['error'],
                        'categories' => ['yii\db\*'],
                        'message' => [
                          'from' => ['log@example.com'],
                          'to' => ['admin@example.com', 'developer@example.com'],
                          'subject' => 'Database errors at example.com',
                        ],
                    ],
                ],
            ],
        ],
      ];

      este componente de log deve ser carregado durante a inicialização, por isto
      ele fica no boostrap.

      os logs podem ser dispachados pra varios lugares.
      -é preciso consultar a API, por exemplo
      --envia pra um banco de dados, ou email, ou em arquivos, ou em syslog do php.

      Filtragem de mensagem
      -error
      -warning
      -info
      -trace
      -profile

      podemos formatar mensagem, por padrão É
      Timestamp [IP address][User ID][Session ID][Severity Level][Category] Message Text

      e temos mais outras coisas complexas com log, como nivel de rastreio
      libertação e exportação de mensagens, alternar destino de log, criar novos Destinos
      perfil de desempenho

    
  ==========================================
    # CONCEITOS CHAVES 
      
      Componentes
      -propriedades
      -eventos
      -behaviors(comportamento)

      ja vimos lá no getting started
      <?php

        namespace yii\components\MyClass;

        use yii\base\BaseObject;

        class MyClass extends BaseObject
        {
          public $prop1;
          public $prop2;

          public function __construct($param1, $param2, $config = [])
          {
              // ... initialization before configuration is applied

              parent::__construct($config);
          }

          public function init()
          {
              parent::init();

              // ... initialization after configuration is applied
          }
        }

      configurando o component
      $component = new MyClass(1, 2, ['prop1' => 3, 'prop2' => 4]);
      // alternatively
      $component = \Yii::createObject([
        'class' => MyClass::className(),
        'prop1' => 3,
        'prop2' => 4,
      ], [1, 2]);


    PROPRIEDADES 

    temos os métodos getter and setter  
    namespace app\components;

      use yii\base\BaseObject;

      class Foo extends BaseObject
      {
          private $_label;

          public function getLabel()
          {
              return $this->_label;
          }

          public function setLabel($value)
          {
              $this->_label = trim($value);
          }
      }


    tem até uns atalhos.

    // equivalent to $label = $object->getLabel();
    $label = $object->label;

    // equivalent to $object->setLabel('abc');
    $object->label = 'abc';

  tem uma parada com trim() que fazendo aqueles bang ali não precisa chamar na maioria
  das calls.

  
  EVENTOS
  -permitem que você injete código personalizado dentro de outro código existente em 
  determinado pontos de execução

  function ($event) {
   // $event is an object of yii\base\Event or a child class
  }

  $event tem:
  -nome do evento
  -objeto chamador
  -dados personalizados

  adicionando manipuladores de evento
  $foo = new Foo;

  // esse manipulador é uma função global
  $foo->on(Foo::EVENT_HELLO, 'function_name');

  // esse manipulador é um método de objeto
  $foo->on(Foo::EVENT_HELLO, [$object, 'methodName']);

  // esse manipulador é um método estático da classe
  $foo->on(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

  // esse manipulador é uma função anônima
  $foo->on(Foo::EVENT_HELLO, function ($event) {
    // Código ...
  });


  --------------------------------------------
  // O código a seguir mostrará "abc" quando o evento for disparado
  // porque $event->data contêm os dados passados no terceiro parâmetro do "on"
  $foo->on(Foo::EVENT_HELLO, 'function_name', 'abc');

  function function_name($event) {
    echo $event->data;
  }


  Disparando eventos:
  namespace app\components;

  use yii\base\Component;
  use yii\base\Event;

  class Foo extends Component
  {
    const EVENT_HELLO = 'hello';

    public function bar()
    {
        $this->trigger(self::EVENT_HELLO);
    }
  }
  Com o código acima, todas as chamadas para bar () irão disparar um evento 
  chamado hello.


  outro exemplo com evento..
  namespace app\components;

  use yii\base\Component;
  use yii\base\Event;

  class MessageEvent extends Event
  {
    public $message;
  }

  class Mailer extends Component
  {
    const EVENT_MESSAGE_SENT = 'messageSent';

    public function send($message)
    {
        // ...sending $message...

        $event = new MessageEvent;
        $event->message = $message;
        $this->trigger(self::EVENT_MESSAGE_SENT, $event);
    }
  }

  trigger(), chama todos os manipuladores ligados ao evento passado.


  para desvincular manipuladores de eventos.

    // o manipulador é uma função global
  $foo->off(Foo::EVENT_HELLO, 'function_name');

  // o manipulador é um método de objeto
  $foo->off(Foo::EVENT_HELLO, [$object, 'methodName']);

  // o manipulador é um método de estático da Classe
  $foo->off(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

  // o manipulador é uma função anônima
  $foo->off(Foo::EVENT_HELLO, $anonymousFunction);


  ou desvincula todos manipuladores do evento mesmo.
  $foo->off(Foo::EVENT_HELLO);

  
  
  --podemos chamar eventos a níveis de classe também.
  use yii\base\Event;

  Event::on(Foo::className(), Foo::EVENT_HELLO, function ($event) {
    var_dump($event->sender);  // displays "null"
  });

  Event::trigger(Foo::className(), Foo::EVENT_HELLO);

  --para desvincular o evento.
  // desvincula $handler
  Event::off(Foo::className(), Foo::EVENT_HELLO, $handler);

  // Desvincula todos os manipuladores de Foo::EVENT_HELLO
  Event::off(Foo::className(), Foo::EVENT_HELLO);


  Eventos Globais existem, podemos chamar para todo APP
  use Yii;
  use yii\base\Event;
  use app\components\Foo;

  Yii::$app->on('bar', function ($event) {
    echo get_class($event->sender);  // Mostra na tela "app\components\Foo"
  });

  Yii::$app->trigger('bar', new Event(['sender' => new Foo]));



  BEHAVIORS 


  namespace app\components;

  use yii\base\Behavior;

  class MyBehavior extends Behavior
  {
    public $prop1;

    private $_prop2;

    public function getProp2()
    {
        return $this->_prop2;
    }

    public function setProp2($value)
    {
        $this->_prop2 = $value;
    }

    public function foo()
    {
        // ...
    }
  }


  temos propriedades como variáveis, e comportamento diferentes
  parecido com getter/setter


  aqui um exemplo de como colocar behavior no codigo
  public function behaviors()
   {
       return [
           // behavior anônimo, somente o nome da classe
           MyBehavior::className(),

           // behavior nomeado, somente o nome da classe
           'myBehavior2' => MyBehavior::className(),

           // behavior anônimo, array de configuração
           [
               'class' => MyBehavior::className(),
               'prop1' => 'value1',
               'prop2' => 'value2',
           ],

           // behavior nomeado, array de configuração
           'myBehavior4' => [
               'class' => MyBehavior::className(),
               'prop1' => 'value1',
               'prop2' => 'value2',
           ]
       ];

    
    podemos também colocar vários behaviors, com attach.
    $component->attachBehaviors([
    'myBehavior1' => new MyBehavior,  // um behavior nomeado
      MyBehavior::className(),          // um behavior anônimo 
    ]);



    então podemos utilizar behavior parecido com components, behavior vai ta nas propriedades
    do component e chamamos ele

      // "prop1" é uma propriedade definida na classe behavior 
    echo $component->prop1;
    $component->prop1 = $value;

    podemos desvincular behaviors. single ou all
    temos o timestampBehavior, praticamente timestamp.

    Behavior vs Traits
    behavior se comporta como classe, são comfiguráveis
    traits são mais eficiente q behavior, porém requerem mais tempo e memoria.



    CONFIGURAÇÕES   

      aqui temos varias configurações, por exemplo do banco de dados, dsn etc.
      e temos muitos outros tipos de config. no caso do template basic.


    temos a configuração de widget
    use yii\widgets\Menu;

    echo Menu::widget([
        'activateItems' => false,
        'items' => [
            ['label' => 'Home', 'url' => ['site/index']],
            ['label' => 'Products', 'url' => ['product/index']],
            ['label' => 'Login', 'url' => ['site/login'], 'visible' => Yii::$app->user->isGuest],
        ],
    ]);

    que no caso podemos colocar na view.

    os arquivos de configuração estão em web.php
    assim como as constantes de ambiente.


    ALIASES (apelidos)
    --apelidos dos caminhos geralmente

      // um alias de um caminho de arquivo
    Yii::setAlias('@foo', '/caminho/para/foo');

    // um alias de uma URL
    Yii::setAlias('@bar', 'http://www.exemplo.com.br');


  Você pode definir um alias usando outro alias (tanto raiz quanto derivado):

  Yii::setAlias('@foobar', '@foo/bar');
  -------------------

  também podemos recuperar com get
    Yii::getAlias('@foo/test/arquivo.php');  // exibe: /caminho/para/foo/test/arquivo.php
    Yii::getAlias('@foo/bar/arquivo.php');   // exibe: /caminho2/bar/arquivo.php

  existem alias já predefinidos
  -@yii
  -@app
  -@runtime
  -@webroot
  -@web
  -@vendor
  -@bower
  -@npm 


  um alias e automaticamente criado quando instalamos uma extensão.
  exemplo de como fica..

  Yii::setAlias('@yii/jui', 'VendorPath/yiisoft/yii2-jui');




  AUTOLOADING DE CLASSES  
  -ele é feito no arquivo yii.php, automaticamente;
  utiliza o autoloader do composer.


  SERVICE LOCATOR
  -Um service locator é um objeto que sabe como fornecer todos os tipos de serviços 
  (ou componentes) que uma aplicação pode precisar.

  aqui mais ou menos como funciona na classe, e depois chamando a classe.
  class SolrServiceBuilder
  {
      public static function build($ip)
      {
          return function () use ($ip) {
              $solr = new app\components\SolrService($ip);
              // ... outras inicializações ...
              return $solr;
          };
      }
  }

  return [
      // ...
      'components' => [
          // ...
          'search' => SolrServiceBuilder::build('127.0.0.1'),
      ],
  ];


  CONTAINER DE INJEÇÃO DE DEPENDÊNCIA 
  - é um objeto que sabe como instanciar e configurar objetos 
    e todas as suas dependências

   yii\di\Container
   -injeção de construtor
   -injeção de setter e propriedade
   -injeção de php callable

  mais sobre DI 
    https://www.yiiframework.com/doc/guide/2.0/pt-br/concept-di-container

  
  ==========================================
    # TRABALHANDO COM BANCO DE DADOS 

  no yii temos alguns db que já podemos fazer conexão mais facilmente
  -mysql
  -mariadb
  -sqlite
  -postgree
  -cubrid
  -oracle
  -mssql

  temos todas configs para cada um.

  podemos criar nossas query's mas nao diz aonde.
  // return a set of rows. each row is an associative array of column names and values.
  // an empty array is returned if the query returned no results
  $posts = Yii::$app->db->createCommand('SELECT * FROM post')
              ->queryAll();

  // return a single row (the first row)
  // false is returned if the query has no result
  $post = Yii::$app->db->createCommand('SELECT * FROM post WHERE id=1')
            ->queryOne();

  // return a single column (the first column)
  // an empty array is returned if the query returned no results
  $titles = Yii::$app->db->createCommand('SELECT title FROM post')
              ->queryColumn();

  // return a scalar value
  // false is returned if the query has no result
  $count = Yii::$app->db->createCommand('SELECT COUNT(*) FROM post')
              ->queryScalar();


  BINDING PARAMETERS

  para uma questao melhor de segurança/validação, podemos dar bind nos values/param
  que recebem.
  $post = Yii::$app->db->createCommand('SELECT * FROM post WHERE id=:id AND status=:status')
           ->bindValue(':id', $_GET['id'])
           ->bindValue(':status', 1)
           ->queryOne();



  NON SQL Query's 
  // INSERT (table name, column values)
  Yii::$app->db->createCommand()->insert('user', [
      'name' => 'Sam',
      'age' => 30,
  ])->execute();

  // UPDATE (table name, column values, condition)
  Yii::$app->db->createCommand()->update('user', ['status' => 1], 'age > 30')->execute();

  // DELETE (table name, condition)
  Yii::$app->db->createCommand()->delete('user', 'status = 0')->execute();


  temos batch insert para adicionar algum comando.
  // table name, column names, column values
  Yii::$app->db->createCommand()->batchInsert('user', ['name', 'age'], [
      ['Tom', 30],
      ['Jane', 20],
      ['Linda', 25],
  ])->execute();


  no database schema é feito com o yii DAO, e alguns métodos.
  createTable(): creating a table
  renameTable(): renaming a table
  dropTable(): removing a table
  truncateTable(): removing all rows in a table
  addColumn(): adding a column
  renameColumn(): renaming a column
  dropColumn(): removing a column
  alterColumn(): altering a column
  addPrimaryKey(): adding a primary key
  dropPrimaryKey(): removing a primary key
  addForeignKey(): adding a foreign key
  dropForeignKey(): removing a foreign key
  createIndex(): creating an index
  dropIndex(): removing an index

  exemplo de uso:
  // CREATE TABLE
  Yii::$app->db->createCommand()->createTable('post', [
      'id' => 'pk',
      'title' => 'string',
      'text' => 'text',
  ]);



  QUERY BUILDER 

  $rows = (new \yii\db\Query())
   ->select(['id', 'email'])
   ->from('user')
   ->where(['last_name' => 'Smith'])
   ->limit(10)
   ->all();


  temos nosso select()
    $query->select(['id', 'email']);

    // equivalente a:

    $query->select('id, email')

    em subquery's temos.
    $subQuery = (new Query())->select('COUNT(*)')->from('user');

    // SELECT `id`, (SELECT COUNT(*) FROM `user`) AS `count` FROM `post`
    $query = (new Query())->select(['id', 'count' => $subQuery])->from('post');


    from()
      // SELECT * FROM `user`
      $query->from('user');

    where()
      $query->where('status=1');

      // ou usar parâmetro para vincular os valores dinamicamente 
      $query->where('status=:status', [':status' => $status]);

    ----------
    // Perigoso! NÃO faça isto a menos que você esteja muito certo que o $status deve ser um número inteiro.
    $query->where("status=$status");

    Ao usar parâmetro, você pode chamar params() ou addParams() para especificar os parâmetros separadamente.

    $query->where('status=:status')
      ->addParams([':status' => $status]);


  Formato Hash
    Formato HASH é mais usado para especificar múltiplos AND - sub-condições 
    concatenadas, sendo cada uma afirmação simples de igualdade. 
    É escrito como um array cujas chaves são nomes de coluna e os valores 
    correspondem ao conteúdo destas colunas. Por exemplo:

    // ...WHERE (`status` = 10) AND (`type` IS NULL) AND (`id` IN (4, 8, 15))
    $query->where([
      'status' => 10,
      'type' => null,
      'id' => [4, 8, 15],
    ]);


  Filtrar Condições
  -Ao construir condições WHERE a partir de entradas de usuários finais, 
    você geralmente deseja ignorar os valores vazios. 

  // $username and $email são inputs dos usuário finais 
  $query->filterWhere([
    'username' => $username,
    'email' => $email,
  ]);


  orderBy()
  groupBy()
  having()
  limit() e offset()
  join()
  union()

  MÉTODOS QUERY
  all() - array de linhas, pares nome-valor
  one() - retorna primeira linha do resultado
  column() - primeira coluna do resultado
  scalar() - retorna valor a escalar localizado na 1ºlinha e coluna do 1ºresultado.
  exists() - retorna valor indica se a consulta contém qualquer resultado
  count() - retorna a quantidade de resultados da query.


  podemos mostrar o commando pra ver o que está sendo a query.
  $command = (new \yii\db\Query())
   ->select(['id', 'email'])
   ->from('user')
   ->where(['last_name' => 'Smith'])
   ->limit(10)
   ->createCommand();
   
  // mostra a instrução SQL 
  echo $command->sql;

  // Mostra os parâmetros que serão ligados
  print_r($command->params);

  // retorna todas as linhas do resultado da query
  $rows = $command->queryAll();



  temos o indexBy(), temos sintax com anonymousFunction

  // retorna [100 => ['id' => 100, 'username' => '...', ...], 101 => [...], 103 => [...], ...]
  $query = (new \yii\db\Query())
    ->from('user')
    ->limit(10)
    ->indexBy('id')
    ->all();


  BATCH QUERY, com foreach.
  use yii\db\Query;

  $query = (new Query())
    ->from('user')
    ->orderBy('id');

  foreach ($query->batch() as $users) {
    // $users é um array de 100 ou menos linha da tabela user
  }

  // ou se você quiser fazer uma iteração da linha uma por uma
  foreach ($query->each() as $user) {
    // $user representa uma linha de dados a partir da tabela user
  }



  !!ACTIVE RECORD!!
  como se fosse query também. construtor de consulta.
  só que é feito por classe.

  $customer = new Customer();
  $customer->name = 'Qiang';
  $customer->save();

  tem support para os mesmos bancos citados acima.

  -------------------
  namespace app\models;

  use yii\db\ActiveRecord;

  class Customer extends ActiveRecord
  {
    const STATUS_INACTIVE = 0;
    const STATUS_ACTIVE = 1;
    
    /**
      * @return string the name of the table associated with this ActiveRecord class.
      */
    public static function tableName()
    {
        return 'customer';
    }
  }
  -----------------------

  a consulta de dados é parecida com a do query builder, mas temos que utilizar
  a classe da active record.

  // retorna um único customer cujo ID é 123
  // SELECT * FROM `customer` WHERE `id` = 123
  $customer = Customer::find()
    ->where(['id' => 123])
    ->one();

  // retorna todos customers ativos e os ordena por seus IDs
  // SELECT * FROM `customer` WHERE `status` = 1 ORDER BY `id`
  $customers = Customer::find()
    ->where(['status' => Customer::STATUS_ACTIVE])
    ->orderBy('id')
    ->all();

  // retorna a quantidade de customers ativos
  // SELECT COUNT(*) FROM `customer` WHERE `status` = 1
  $count = Customer::find()
    ->where(['status' => Customer::STATUS_ACTIVE])
    ->count();

  // retorna todos customers em um array indexado pelos seus IDs
  // SELECT * FROM `customer`
  $customers = Customer::find()
    ->indexBy('id')
    ->all();


  -------------------------------
  -findOne()
  -findAll()


  // retorna um único customer cujo ID é 123
  // SELECT * FROM `customer` WHERE `id` = 123
  $customer = Customer::findOne(123);

  // retorna customers cujo ID é 100, 101, 123 or 124
  // SELECT * FROM `customer` WHERE `id` IN (100, 101, 123, 124)
  $customers = Customer::findAll([100, 101, 123, 124]);

  // retorna um customer ativo cujo ID é 123
  // SELECT * FROM `customer` WHERE `id` = 123 AND `status` = 1
  $customer = Customer::findOne([
    'id' => 123,
    'status' => Customer::STATUS_ACTIVE,
  ]);

  // retorna todos os customers inativos
  // SELECT * FROM `customer` WHERE `status` = 0
  $customers = Customer::findAll([
    'status' => Customer::STATUS_INACTIVE,
  ]);

----------------------------------------

  TRANSFORMANDO DADOS
    já que é uma classe podemos já retornar os dados limpos para usar na view
    por exemplo a data que vem com formato americano.

      class Customer extends ActiveRecord
    {
      // ...

      public function getBirthdayText()
      {
          return date('Y/m/d', $this->birthday);
      }
      
      public function setBirthdayText($value)
      {
          $this->birthday = strtotime($value);
      }
    }


  podemos retornar em array, (json nao sei se pode direto, mas pra converter depois
    para objeto)

    // retorna todos os `customers`
    // cada `customer` retornado é associado a um array
    $customers = Customer::find()
      ->asArray()
      ->all();


  para SALVAR DADOS quase a mesma coisa.

  // insere uma nova linha de dados
  $customer = new Customer();
  $customer->name = 'James';
  $customer->email = 'james@example.com';
  $customer->save();

  // atualiza uma linha de dados existente
  $customer = Customer::findOne(123);
  $customer->email = 'james@newexample.com';
  $customer->save();



  UPDATE Counter

  $post = Post::findOne(100);
  // UPDATE `post` SET `view_count` = `view_count` + 1 WHERE `id` = 100
  $post->updateCounters(['view_count' => 1]);


  DEFAULT VALUES, wat
  $customer = new Customer();
  $customer->loadDefaultValues();
  // $customer->xyz will be assigned the default value declared when defining the "xyz" column
 

  em formato json chama assim
  $query->andWhere(['=', 'json', new ArrayExpression(['foo' => 'bar'])


  UPDATING Multiple rows
  // UPDATE `customer` SET `status` = 1 WHERE `email` LIKE `%@example.com%`
  Customer::updateAll(['status' => Customer::STATUS_ACTIVE], ['like', 'email', '@example.com']);


  DELETE
  $customer = Customer::findOne(123);
  $customer->delete();

  DELETE ALL 
  Customer::deleteAll(['status' => Customer::STATUS_INACTIVE]);

  -----------------------------------

  TRABALHANDO COM TRANSACTION
  -praticamente uma function(transaction) são várias query's juntas
  utilizada no active record.

  podemos fazer com uma anonymousFunction ou começar com static class e fazer
  um try catch

  $customer = Customer::findOne(123);

  Customer::getDb()->transaction(function($db) use ($customer) {
      $customer->id = 200;
      $customer->save();
      // ...other DB operations...
  });

  // or alternatively

  $transaction = Customer::getDb()->beginTransaction();
  try {
      $customer->id = 200;
      $customer->save();
      // ...other DB operations...
      $transaction->commit();
  } catch(\Exception $e) {
      $transaction->rollBack();
      throw $e;
  } catch(\Throwable $e) {
      $transaction->rollBack();
      throw $e;
  }

  ----------------------------------------------

  tem outras coisas com o "OptimisticLock"
  meio que salva em um hidden form, quando for salvar e verifica,
  se tem duas ações editando a mesma coisa no banco, para não dar 
  staleobject error.


  --------------------------------------------------------

  Podemos trabalhar com "Relações" no DB

  class Customer extends ActiveRecord
  {
      // ...

      public function getOrders()
      {
          return $this->hasMany(Order::className(), ['customer_id' => 'id']);
      }
  }

  class Order extends ActiveRecord
  {
      // ...

      public function getCustomer()
      {
          return $this->hasOne(Customer::className(), ['id' => 'customer_id']);
      }
  }


  -hasMany()
  -hasOne()


  e aquui temos como pegar pelo active record, e retornar arrays
  praticamente activerecord é a classe, então tem os métodos getters setters
  $customer->orders; // is an array of `Order` objects
  $customer->getOrders(); // returns an ActiveQuery instance

  -------------------------------------------

  Dynamic Relational Query.... especifico, talvez n seja mt bom para algumas coisas
  a não ser em alguma função especifica mesmo.
  $customer = Customer::findOne(123);

  // SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal` > 200 ORDER BY `id`
  $orders = $customer->getOrders()
      ->where(['>', 'subtotal', 200])
      ->orderBy('id')
      ->all();

  
  -------------------------------------------


  temos também
  Relações via Junction table 
  Chaining relation,

  -------------------------------

  temos o uso do with(). exemplo:

  Query sem o with():
  faz 100 sql statement,1 por 1

    // SELECT * FROM `customer` LIMIT 100
  $customers = Customer::find()->limit(100)->all();

  foreach ($customers as $customer) {
      // SELECT * FROM `order` WHERE `customer_id` = ...
      $orders = $customer->orders;
  }

  Com with() junta tudo em uma query e reduz o processamento.
  // SELECT * FROM `customer` LIMIT 100;
  // SELECT * FROM `orders` WHERE `customer_id` IN (...)
  $customers = Customer::find()
      ->with('orders')
      ->limit(100)
      ->all();

  foreach ($customers as $customer) {
      // no SQL executed
      $orders = $customer->orders;
  }

  ------------------------------------------
  mais exemplos:

    // eager loading both "orders" and "country"
  $customers = Customer::find()->with('orders', 'country')->all();
  // equivalent to the array syntax below
  $customers = Customer::find()->with(['orders', 'country'])->all();
  // no SQL executed 
  $orders= $customers[0]->orders;
  // no SQL executed 
  $country = $customers[0]->country;

  // eager loading "orders" and the nested relation "orders.items"
  $customers = Customer::find()->with('orders.items')->all();
  // access the items of the first order of the first customer
  // no SQL executed
  $items = $customers[0]->orders[0]->items;


  -----------------------------------------------
  Aqui um exemplo completo com a sintax e query original do db.

  // SELECT `customer`.* FROM `customer`
  // LEFT JOIN `order` ON `order`.`customer_id` = `customer`.`id`
  // WHERE `order`.`status` = 1
  // 
  // SELECT * FROM `order` WHERE `customer_id` IN (...)
  $customers = Customer::find()
      ->select('customer.*')
      ->leftJoin('order', '`order`.`customer_id` = `customer`.`id`')
      ->where(['order.status' => Order::STATUS_ACTIVE])
      ->with('orders')
      ->all();

  

  -----------------------------------------------
  temos ALIASES para db também. porém fácil de se perder.

    $query->joinWith([
      'orders' => function ($q) {
          $q->from(['o' => Order::tableName()]);
      },
  ])

  -----------------------------------------------


  INVERSE RELATION, temos outra function.
  class Customer extends ActiveRecord
  {
      public function getOrders()
      {
          return $this->hasMany(Order::className(), ['customer_id' => 'id'])->inverseOf('customer');
      }
  }

  // SELECT * FROM `customer` WHERE `id` = 123
  $customer = Customer::findOne(123);

  // SELECT * FROM `order` WHERE `customer_id` = 123
  $order = $customer->orders[0];

  // No SQL will be executed
  $customer2 = $order->customer;

  // displays "same"
  echo $customer2 === $customer ? 'same' : 'not the same';


  -----------------------------------------------------


  SAVING RELATIONS, usamos o link() ao inves de save();
  ---maneira errada.
    $customer = Customer::findOne(123);
  $order = new Order();
  $order->subtotal = 100;
  // ...

  // setting the attribute that defines the "customer" relation in Order
  $order->customer_id = $customer->id;
  $order->save();

  ---maneira correta
  $customer = Customer::findOne(123);
  $order = new Order();
  $order->subtotal = 100;
  // ...

  $order->link('customer', $customer);

  ----------------------------------------------------

  tem opção de CROSS-DB RELATIONS tbm.. mais complexo..
  customizar Query's também
  Extra fields..
  -------------------------------------------------------

  
  MIGRATIONS
  -- para migrar para o db, nossas tabelas criadas por codigo.
    temos o básico de toda migration, e cria o prefix com timestamp.

    -create new migrations;
    -apply migrations;
    -revert migrations;
    -re-apply migrations;
    -show migration history and status.


  utilizamos o terminal com os comandos:
  !!caso não encontre podemos utilizar o 
    php yii migrate/create create_news_table
  !!
  
  -Criar Migration-
    yii migrate/create <name> 
      ex: (yii migrate/create create_news_table)

  Como fica a classe de migration criada.
    <?php

    use yii\db\Migration;

    class m150101_185401_create_news_table extends Migration
    {
        public function up()
        {

        }

        public function down()
        {
            echo "m101129_185401_create_news_table cannot be reverted.\n";

            return false;
        }

        /*
        // Use safeUp/safeDown to run migration code within a transaction
        public function safeUp()
        {
        }

        public function safeDown()
        {
        }
        */
    }
  

    ----------------------------------------------------------------
    Aqui temos a API com os comandos que podemos utilizar;
    https://www.yiiframework.com/doc/api/2.0/yii-db-schemabuildertrait

    -------------------

    Também pelo command line podemos especificar as linhas
      yii migrate/create create_post_table --fields="title:string,body:text"
    
    cria-se 'automaticamente' nossas tables.
    podemos passar parâmetros junto.

      yii migrate/create create_post_table --fields="title:string(12):notNull:unique,body:text"


    até as foreign key podem ser criadas pelo command line
      yii migrate/create create_post_table --fields="author_id:integer:notNull:foreignKey(user),category_id:integer:defaultValue(1):foreignKey,title:string,body:text"

    então nesse caso até poderia ser bom.


    DROP TABLE na function up()
       yii migrate/create drop_post_table --fields="title:string(12):notNull:unique,body:text"

    possível também pelo command line

        class m150811_220037_drop_post_table extends Migration
        {
            public function up()
            {
                $this->dropTable('post');
            }

            public function down()
            {
                $this->createTable('post', [
                    'id' => $this->primaryKey(),
                    'title' => $this->string(12)->notNull()->unique(),
                    'body' => $this->text()
                ]);
            }
        }


    Adicionar Colunas também..
    ADD COLUMN
      yii migrate/create add_position_column_to_post_table --fields="position:integer"

    e DROP COLUMN
      yii migrate/create drop_position_column_from_post_table --fields="position:integer"

    JUNCTION TABLE
      yii migrate/create create_junction_table_for_post_and_tag_tables --fields="created_at:dateTime"

    TRANSACTION MIGRATIONS

      <?php
      use yii\db\Migration;

      class m150101_185401_create_news_table extends Migration
      {
          public function safeUp()
          {
              $this->createTable('news', [
                  'id' => $this->primaryKey(),
                  'title' => $this->string()->notNull(),
                  'content' => $this->text(),
              ]);

              $this->insert('news', [
                  'title' => 'test 1',
                  'content' => 'content 1',
              ]);
          }

          public function safeDown()
          {
              $this->delete('news', ['id' => 1]);
              $this->dropTable('news');
          }
      }


    
    DATABASE ACESSING METHODS
    -execute(): executing a SQL statement
    -insert(): inserting a single row
    -batchInsert(): inserting multiple rows
    -update(): updating rows
    -upsert(): inserting a single row or updating it if it exists (since 2.0.14)
    -delete(): deleting rows
    -createTable(): creating a table
    -renameTable(): renaming a table
    -dropTable(): removing a table
    -truncateTable(): removing all rows in a table
    -addColumn(): adding a column
    -renameColumn(): renaming a column
    -dropColumn(): removing a column
    -alterColumn(): altering a column
    -addPrimaryKey(): adding a primary key
    -dropPrimaryKey(): removing a primary key
    -addForeignKey(): adding a foreign key
    -dropForeignKey(): removing a foreign key
    -createIndex(): creating an index
    -dropIndex(): removing an index
    -addCommentOnColumn(): adding comment to column
    -dropCommentFromColumn(): dropping comment from column
    -addCommentOnTable(): adding comment to table
    -dropCommentFromTable(): dropping comment from table



    para aplicar as migrations só dar migrate
      yii migrate
        ou
      php yii migrate


    podemos escolher numero de migrations para se fazer também
      yii migrate 3 (migra 3 tables só e assim vai indo)

    para reverter as migrations temos outros comandos
    REVERTING MIGRATIONS
      yii migrate/down     # revert the most recently applied migration
      yii migrate/down 3   # revert the most 3 recently applied migrations

    nem todas são reversiveis, ainda mais trabalhando com banco relacional,
    então tem que tomar cuidado.


    tambḿe podemos reverter as migrations e upar novamente no banco
    com REDOING MIGRATIONS
      yii migrate/redo        # redo the last applied migration
      yii migrate/redo 3      # redo the last 3 applied migrations

    
    REFRESHING MIGRATIONS
      praticamente deleta todas tables e foreign keys. e aplica tudo novamente do inicio
      yii migrate/fresh       # truncate the database and apply all migrations from the beginning
    
    
    LISTAR MIGRATIONS
      yii migrate/history     # showing the last 10 applied migrations
      yii migrate/history 5   # showing the last 5 applied migrations
      yii migrate/history all # showing all applied migrations

      yii migrate/new         # showing the first 10 new migrations
      yii migrate/new 5       # showing the first 5 new migrations
      yii migrate/new all     # showing all new migrations
    
    
    podemos modificar a history da migration(timestamp) ao invés
    de refaze-la para criar outra timestamp, no caso de atualizar a migration etc.

    yii migrate/mark 150101_185401                      # using timestamp to specify the migration
    yii migrate/mark "2015-01-01 18:54:01"              # using a string that can be parsed by strtotime()
    yii migrate/mark m150101_185401_create_news_table   # using full name
    yii migrate/mark 1392853618                         # using UNIX timestamp


    Podemos personalizar migration nas configs
    -customizar/namespace/component/commandline/

    MIGRATING MULTIPLE DATABASES
      ... existe esta opção


 
  ==========================================
    # COLETANDO DADOS DE USUARIOS

    Active Record based forms.
    aqui criamos um model

    <?php

    class LoginForm extends \yii\base\Model
    {
        public $username;
        public $password;

        public function rules()
        {
            return [
                // define validation rules here
            ];
        }
    }


    já temos exemlo no loginForm e SiteController, e outros tipos para criar forms
    
    // a password input
    <?= $form->field($model, 'password')->passwordInput() ?>
    // adding a hint and a customized label
    <?= $form->field($model, 'username')->textInput()->hint('Please enter your name')->label('Name') ?>
    // creating a HTML5 email input element
    <?= $form->field($model, 'email')->input('email') ?>

    // allow multiple files to be uploaded:
    echo $form->field($model, 'uploadFile[]')->fileInput(['multiple'=>'multiple']);

    // allow multiple items to be checked:
    echo $form->field($model, 'items[]')->checkboxList(['a' => 'Item A', 'b' => 'Item B', 'c' => 'Item C']);


    Criando Listas.
    -Dropdown list
    -Radio lists
    -Checkbox lists

      $items = [
        1 => 'item 1', 
        2 => 'item 2'
      ] 

      $items = Category::find()
          ->select(['label'])
          ->indexBy('id')
          ->column();

    temos dropdowns
    /* @var $form yii\widgets\ActiveForm */

    echo $form->field($model, 'category')->dropdownList([
            1 => 'item 1', 
            2 => 'item 2'
        ],
        ['prompt'=>'Select Category']
    );

    --radiolist
    /* @var $form yii\widgets\ActiveForm */

    echo $form->field($model, 'category')->radioList([
        1 => 'radio 1', 
        2 => 'radio 2'
    ]);

    --checkboxList
    /* @var $form yii\widgets\ActiveForm */

    echo $form->field($model, 'category')->checkboxList([
        1 => 'checkbox 1', 
        2 => 'checkbox 2'
    ]);


    PJAX é tipo ajax, so que com forms, envia o form e retorna já a resposta sem
    dar o refresh na página.

    use yii\widgets\Pjax;
    use yii\widgets\ActiveForm;

    Pjax::begin([
        // Pjax options
    ]);
        $form = ActiveForm::begin([
            'options' => ['data' => ['pjax' => true]],
            // more ActiveForm options
        ]);

            // ActiveForm content

        ActiveForm::end();
    Pjax::end();

    Tip: Be careful with the links inside the Pjax widget since the 
    response will also be rendered inside the widget. To prevent this, 
    use the data-pjax="0" HTML attribute.


    VALIDANDO DADOS

    validamos input principalmente pelo model, com validate()
    $model = new \app\models\ContactForm();

    // populate model attributes with user inputs
    $model->load(\Yii::$app->request->post());
    // which is equivalent to the following:
    // $model->attributes = \Yii::$app->request->post('ContactForm');

    if ($model->validate()) {
        // all inputs are valid
    } else {
        // validation failed: $errors is an array containing error messages
        $errors = $model->errors;
    }

    junto com rules()
    public function rules()
    {
        return [
            // the name, email, subject and body attributes are required
            [['name', 'email', 'subject', 'body'], 'required'],

            // the email attribute should be a valid email address
            ['email', 'email'],
        ];
    }


    e essas rules vão retornra um 'array of rules'. formato de array.

    CUSTOMIZING ERROR MESSAGES
 
      dentro do array de rules temos um array->array, com key=>value
      ['message'=>'custom_message']

      public function rules()
      {
          return [
              ['username', 'required', 'message' => 'Please choose a username.'],
          ];
      }


      para quase tudo no framework temos eventos, validation também tem eventos.
      -beforeValidate()
      -afterValidate()
      como se fosse o life cicle mesmo.

      CONDITIONAL VALIDATON
        também temos dentro da validate() esta opção caso usemos.
        ['state', 'required', 'when' => function($model) {
            return $model->country == 'USA';
        }]

      podemos utilizar o trim()[tira os espaços brancos do input]
      dentro do validate, default() nao tenho certeza se vem com espaço em branco.

        return [
            [['username', 'email'], 'trim'],
            [['username', 'email'], 'default'],
        ];


      ----------------------------------------
      Aqui temos mais uma regrinha de validação
        ['age', 'trim'],
        ['age', 'default', 'value' => null],
        ['age', 'integer', 'min' => 0],
        ['age', 'filter', 'filter' => 'intval', 'skipOnEmpty' => true],

      empty inputs, preisam ser null para entra na database, caso precise ter o valor
      depois,
      skipOnEmpty, não vai colocar nada se o valor for vazio.

      ---------------------------------------
      HANDLING EMPTY INPUTS 

      por default, é uma emptystring, ou empty array ou null.

        return [
            // set "username" and "email" as null if they are empty
            [['username', 'email'], 'default'],

            // set "level" to be 1 if it is empty
            ['level', 'default', 'value' => 1],
        ];
    ------------------------------------------------------------------------
         ['agree', 'required', 'isEmpty' => function ($value) {
            return empty($value);
         }]

      podemos também nas validate, colocar um default value caso seja vazio. no caso
      em cima.

    ---------------

    AD HOC validation
      quando não temos a validação no model, podemos utilizar algumas já prontas
      no caso o do emailValidator()

      $email = 'test@example.com';
      $validator = new yii\validators\EmailValidator();

      if ($validator->validate($email, $error)) {
          echo 'Email is valid.';
      } else {
          echo $error;
      }
      
    -------------------------------


    Multiple Validations against several values.
    utilizamos o DynamicModel::
      public function actionSearch($name, $email)
      {
          $model = DynamicModel::validateData(['name' => $name, 'email' => $email], [
              [['name', 'email'], 'string', 'max' => 128],
              ['email', 'email'],
          ]);

          if ($model->hasErrors()) {
              // validation fails
          } else {
              // validation succeeds
          }
      }

      Dynamic model é possivel criar rules/validation como classe,
      por exemplo em um método da classe.

      public function actionSearch($name, $email)
      {
          $model = new DynamicModel(['name' => $name, 'email' => $email]);
          $model->addRule(['name', 'email'], 'string', ['max' => 128])
              ->addRule('email', 'email')
              ->validate();

          if ($model->hasErrors()) {
              // validation fails
          } else {
              // validation succeeds
          }
      }


  ---------------------------------------
  existem também INLINE-validator, caso colocamos mais condições na rules..
  STANDALONE sobreescreve a validação, com alguma condição, parecido com inline.
  utilizamos o addError() também.


  aqui temos exemplo validando sem pegar do model, praticamente cria as variáveis
  dentro da própria classe e utiliza elas.
  -----------------------------------------
  namespace app\models;

    use Yii;
    use yii\base\Model;
    use app\components\validators\CountryValidator;

    class EntryForm extends Model
    {
        public $name;
        public $email;
        public $country;

        public function rules()
        {
            return [
                [['name', 'email'], 'required'],
                ['country', CountryValidator::className()],
                ['email', 'email'],
            ];
        }
    }
  -----------------------------------------

  MULTIPLE ATTRIBUTES..
    no caso temos constantes na classe e utilizamos elas dentro do validator.
    -----------------------------------------
    class MigrationForm extends \yii\base\Model
    {
        /**
        * Minimal funds amount for one adult person
        */
        const MIN_ADULT_FUNDS = 3000;
        /**
        * Minimal funds amount for one child
        */
        const MIN_CHILD_FUNDS = 1500;

        public $personalSalary;
        public $spouseSalary;
        public $childrenCount;
        public $description;

        public function rules()
        {
            return [
                [['personalSalary', 'description'], 'required'],
                [['personalSalary', 'spouseSalary'], 'integer', 'min' => self::MIN_ADULT_FUNDS],
                ['childrenCount', 'integer', 'min' => 0, 'max' => 5],
                [['spouseSalary', 'childrenCount'], 'default', 'value' => 0],
                ['description', 'string'],
            ];
        }
    }
    -----------------------------------------


    Podemos CRIAR nosso próprio validator. um pouco complexo.
    doc: https://www.yiiframework.com/doc/guide/2.0/pt-br/input-validation

    ---------------------

    Com a funcionalidade do addError() podemos colocar erros de validação
    para várias variáveis em comum. exemplo:

    Nesse caso, simplesmente adicionamos a validação naquela variável. no caso
      poderia vir de um formulário ou coisa parecida.
        $this->addError('childrenCount', 'Your salary is not enough for children.');

    Podemos fazer desta forma também, para múltiplos campos/vars.
        $message = 'Your salary is not enough for children.';
        $this->addError('personalSalary', $message);
        $this->addError('wifeSalary', $message);
        $this->addError('childrenCount', $message);

    Ou quando existem muitas variáveis, é melhor fazer isto dentro do laço de repetição.
        $attributes = ['personalSalary', 'wifeSalary', 'childrenCount'];
        foreach ($attributes as $attribute) {
            $this->addError($attribute, 'Your salary is not enough for children.');
        }

    Também funciona o all(*), adiciona esse erro pra todos campos.
      $this->addError('*', 'Your salary is not enough for children.');


    fazendo deste jeito, os forms na VIEW ficam mais enxutos.
      <?= $form->errorSummary($model) ?>




    CLIENT-SIDE VALIDATION  
      são feito pelo model RULES() no backend.
      do frontend temos o validate() para os campos do formulários.

      aqui o exemplo de rules client-side.
      --------------------------------------------------
        namespace app\models;

        use yii\base\Model;
        use app\models\User;

        class LoginForm extends Model
        {
            public $username;
            public $password;

            public function rules()
            {
                return [
                    // username and password are both required
                    [['username', 'password'], 'required'],

                    // password is validated by validatePassword()
                    ['password', 'validatePassword'],
                ];
            }

            public function validatePassword()
            {
                $user = User::findByUsername($this->username);

                if (!$user || !$user->validatePassword($this->password)) {
                    $this->addError('password', 'Incorrect username or password.');
                }
            }
        }
      --------------------------------------------------


      Temos Client-Side Validation, com validator também.
      outra coisa mais complexa que não entendi porque utilizar validator no backend.
      mas caso precise, está na documentação.
       https://www.yiiframework.com/doc/guide/2.0/pt-br/input-validation

      --------------------------------------------------


      DEFERRED VALIDATION
        com async (ajax validation) mais complexo também, tem na doc.
      
      AJAX Validation
        para isto é preciso dar um enable, porque já é setado como false.
        podemos fazer para um form ou para todos.

      -form específico
      ---------------------------------
      use yii\widgets\ActiveForm;

      $form = ActiveForm::begin([
          'id' => 'registration-form',
      ]);

      echo $form->field($model, 'username', ['enableAjaxValidation' => true]);

      // ...

      ActiveForm::end();
      ---------------------------------

      -all forms
      ---------------------------------
      $form = ActiveForm::begin([
          'id' => 'contact-form',
          'enableAjaxValidation' => true,
      ]);
    

  RECEBENDO ARQUIVOS(UPLOAD)
    já vimos acima lago parecido no formulário.
    depois de feitas as rules pleo model, podemos ter a function de upload()
    caso exista um upload, vai criar na root folder a pasta de uploads.
    exemplo do código:

    --------------------------------------
    namespace app\models;

    use yii\base\Model;
    use yii\web\UploadedFile;

    class UploadForm extends Model
    {
        /**
        * @var UploadedFile
        */
        public $imageFile;

        public function rules()
        {
            return [
                [['imageFile'], 'file', 'skipOnEmpty' => false, 'extensions' => 'png, jpg'],
            ];
        }
        
        public function upload()
        {
            if ($this->validate()) {
                $this->imageFile->saveAs('uploads/' . $this->imageFile->baseName . '.' . $this->imageFile->extension);
                return true;
            } else {
                return false;
            }
        }
    }    

    --------------------------------------

    temos o fileValidator
    https://www.yiiframework.com/doc/api/2.0/yii-validators-filevalidator

    ------------------------------------

    Na VIEW temos este formulário feito por widgets com active form
    <?php
      use yii\widgets\ActiveForm;
      ?>

      <?php $form = ActiveForm::begin(['options' => ['enctype' => 'multipart/form-data']]) ?>

          <?= $form->field($model, 'imageFile')->fileInput() ?>

          <button>Submit</button>

      <?php ActiveForm::end() ?>

    --------------------------------------------

    Já no controller temos isto aqui.

    namespace app\controllers;

    use Yii;
    use yii\web\Controller;
    use app\models\UploadForm;
    use yii\web\UploadedFile;

    class SiteController extends Controller
    {
        public function actionUpload()
        {
            $model = new UploadForm();

            if (Yii::$app->request->isPost) {
                $model->imageFile = UploadedFile::getInstance($model, 'imageFile');
                if ($model->upload()) {
                    // file is uploaded successfully
                    return;
                }
            }

            return $this->render('upload', ['model' => $model]);
        }
    }

  ---------------------------------------------

  pegamos do model no controller o form de upload.

  Para fazer multiple uploads é um pocuo diferente, temos ainda as mesmas rules.
  porém no upload, temos que validar, e salvamos as files dentro do loop foreach. 
  segue em seguinte.

  ------------------------
  namespace app\models;

  use yii\base\Model;
  use yii\web\UploadedFile;

  class UploadForm extends Model
  {
      /**
      * @var UploadedFile[]
      */
      public $imageFiles;

      public function rules()
      {
          return [
              [['imageFiles'], 'file', 'skipOnEmpty' => false, 'extensions' => 'png, jpg', 'maxFiles' => 4],
          ];
      }
      
      public function upload()
      {
          if ($this->validate()) { 
              foreach ($this->imageFiles as $file) {
                  $file->saveAs('uploads/' . $file->baseName . '.' . $file->extension);
              }
              return true;
          } else {
              return false;
          }
      }
    }

  --------------------------------------------------
  
  na VIEW, precisamos colocar a opção para multiple files, no file input.
  vai salvar como array, fileInput->multiple, e imagesFIles[] como array.
  praticamente isto.

  ----------------------------
  <?php
    use yii\widgets\ActiveForm;
    ?>

    <?php $form = ActiveForm::begin(['options' => ['enctype' => 'multipart/form-data']]) ?>

        <?= $form->field($model, 'imageFiles[]')->fileInput(['multiple' => true, 'accept' => 'image/*']) ?>

        <button>Submit</button>

  <?php ActiveForm::end() ?>
  ----------------------------

  Agora no controller , muda o getInstace, para getInstances. na uploadFile
  e o UploadForm é imagesFiles, que armazena todas files.

  -----------------------------------------
  namespace app\controllers;

    use Yii;
    use yii\web\Controller;
    use app\models\UploadForm;
    use yii\web\UploadedFile;

    class SiteController extends Controller
    {
        public function actionUpload()
        {
            $model = new UploadForm();

            if (Yii::$app->request->isPost) {
                $model->imageFiles = UploadedFile::getInstances($model, 'imageFiles');
                if ($model->upload()) {
                    // file is uploaded successfully
                    return;
                }
            }

            return $this->render('upload', ['model' => $model]);
        }
    }

  ---------------------------------------

  COLLECTING TABULAR INPUT
    isso acontece quando temos multiplos models do mesmo tipo, em um único formulário.
    geralmente é feito isso com settings dentro do banco de dados.
    https://www.yiiframework.com/doc/guide/2.0/pt-br/input-tabular-input

  ------------------------------------------

  GETTING DATA FOR MULTIPLE MODELS
    Aqui também, quando temos multiplos models com informações complexas
    de outros banco de dados e não somente o mesmo. Docs
    https://www.yiiframework.com/doc/guide/2.0/pt-br/input-multiple-models

  ------------------------------------------

  EXTENDING ACTIVEFORM ON THE CLIENT SIDE
    aqui podemos utilizar dos EVENTS no active form. no caso, verificação de mensagem
    se desejos realmente enviar os dados, confirmação de envio etc.

    $('#contact-form').on('beforeSubmit', function (e) {
      if (!confirm("Everything is correct. Submit?")) {
        return false;
      }
      return true;
    });

    aqui parece um código jquery, antes de enviar o formulário, confirmamos com uma
    mensagem se tudo está correto, se for, avança ou cancela a ação.


    Então temos a explicação do life cicle, com
    doc(https://www.yiiframework.com/doc/guide/2.0/pt-br/input-form-javascript)
    -beforeValidate
    -afterValidate
    -beforeValidateAttribute
    -afterValidateAttribute
    -beforeSubmit
    -ajaxBeforeSend
    -ajaxComplete(quando completa a req ajax)

    
    que é parecido com os eventos de segurança de autenticação.

    aqui temos um form ajax padrão normal
    -------------------------------------------
    var $form = $('#formId');
    $form.on('beforeSubmit', function() {
        var data = $form.serialize();
        $.ajax({
            url: $form.attr('action'),
            type: 'POST',
            data: data,
            success: function (data) {
                // Implement successful
            },
            error: function(jqXHR, errMsg) {
                alert(errMsg);
            }
        });
        return false; // prevent default submit
    });
    -------------------------------------------

    temos como adicionar dinamicamente também, não entendi mt bem.
    https://www.yiiframework.com/doc/guide/2.0/pt-br/input-form-javascripts
    

  ==========================================
    # EXIBINDO DADOS

    FORMATAÇÃO DE DADOS
      usamos para algumas coisas, alguns exemplos abaixo.

      $formatter = \Yii::$app->formatter;

      // output: January 1, 2014
      echo $formatter->asDate('2014-01-01', 'long');
      
      // output: 12.50%
      echo $formatter->asPercent(0.125, 2);
      
      // output: <a href="mailto:cebe@example.com">cebe@example.com</a>
      echo $formatter->asEmail('cebe@example.com'); 

      // output: Yes
      echo $formatter->asBoolean(true); 
      // it also handles display of null values:

      // output: (not set)
      echo $formatter->asDate(null); 


      podemos configurar diretamente no component o 'formatter' e especificar como 
      deverá retornar sempre, ao invés de repetir toda vez a função do formater na view.

      return [
          'components' => [
              'formatter' => [
                  'dateFormat' => 'dd.MM.yyyy',
                  'decimalSeparator' => ',',
                  'thousandSeparator' => ' ',
                  'currencyCode' => 'EUR',
            ],
          ],
      ];

      -------------------------------------------

      Temos várias funções para formatar data/tempo
      -date
      -time
      -datetime
      -timestamp
      -relativeTime (1hour ago)
      -duration (1day, 2minutes)

      aqui o formatter na view, com as datas.
      echo Yii::$app->formatter->asDate('now', 'yyyy-MM-dd'); // 2014-10-06

      // PHP date()-format
      echo Yii::$app->formatter->asDate('now', 'php:Y-m-d'); // 2014-10-06

      temos alguns formatos que aparecem a data, se quisermos colocar
      segue o exemplo;

      short: will output 06/10/2014 for date and 15:58 for time;
      medium: will output 6 Oct 2014 and 15:58:42;
      long: will output 6 October 2014 and 15:58:42 GMT;
      full: will output Monday, 6 October 2014 and 15:58:42 GMT.

      -------------------------------------------

      Time Zones (unix,utc,cest)
        provavel que iremos utilizar utc quase sempre. mas..
        
        // formatting a UNIX timestamp as a time
        echo Yii::$app->formatter->asTime(1412599260); // 14:41:00

        // formatting a datetime string (in UTC) as a time 
        echo Yii::$app->formatter->asTime('2014-10-06 12:41:00'); // 14:41:00

        // formatting a datetime string (in CEST) as a time
        echo Yii::$app->formatter->asTime('2014-10-06 14:41:00 CEST'); // 14:41:00

      -------------------------------------------

      FORMATING NUMBERS
        temos support parecido com o que o db oferece. 
        os formatos são

      -integer
      -decimal
      -percent 
      -scientific
      -currency
      -size 
      -shortSize

      temos outros formatos que o yii consegue usar. além do date/time e numbers
      -raw
      -text
      -ntext(html encoded)
      -paragraphs
      -html
      -email
      -image
      -url
      -boolean

      NULL VALUES
        fica configurado com padrão do nullDisplay
          (https://www.yiiframework.com/doc/api/2.0/yii-i18n-formatter#$nullDisplay-detail)
      
      LOCALIZING DATE FORMAT
        a data vai ser formatada decorrente do "locale" que tiver configurado.
        segue o exemplo.

        Yii::$app->formatter->locale = 'en-US';
        echo Yii::$app->formatter->asDate('2014-01-01'); // output: January 1, 2014

        Yii::$app->formatter->locale = 'de-DE';
        echo Yii::$app->formatter->asDate('2014-01-01'); // output: 1. Januar 2014

        Yii::$app->formatter->locale = 'ru-RU';
        echo Yii::$app->formatter->asDate('2014-01-01'); // output: 1 января 2014 г.

      -------------------------------------------


    PAGINAÇÃO
      doc(https://www.yiiframework.com/doc/api/2.0/yii-data-pagination)

      já vimos no front como foi feito a paginação pelo "gii" com o CRUD Generator.

      -contagem total
      -quantidade por página
      -página atual

      exemplo:
      -------------------------------------------
      use yii\data\Pagination;

      // Cria uma query para pegar todos os artigos com status = 1

      $query = Article::find()->where(['status' => 1]);

      // pega o total de artigos (mas não baixa os dados ainda)

      $count = $query->count();

      // cria um objeto pagination com o total em $count

      $pagination = new Pagination(['totalCount' => $count]);

      // Lima a query usando a paginação e recupera os artigos

      $articles = $query->offset($pagination->offset)

          ->limit($pagination->limit)

          ->all();
      -------------------------------------------


      aqui é a lista de botões que o usuario pode clicar, feita pelo linkPager.
      use yii\widgets\LinkPager;

      echo LinkPager::widget([

          'pagination' => $pagination,

      ]);

      -------------------------------------------

      Podemos criar url manualmente, porém requer parâmetro e criará um
      formato apropriado contendo o parâmetro da pagina.

      // especifica a rota que o URL a ser criada deve usar

      // Se você não a especificar, a atual rota requerida será usado

      $pagination->route = 'article/index';

      // exibe: /index.php?r=article/index&page=100

      echo $pagination->createUrl(100);

      // exibe: /index.php?r=article/index&page=101

      echo $pagination->createUrl(101);
      

      -------------------------------------------


      ORDENAÇÃO
        quando exibimos varias linhas de dados é preciso ser ordenado de acrodo 
        com as colunas especificadas pelos usuarios finais.

        https://www.yiiframework.com/doc/guide/2.0/pt-br/output-sorting


      PROVEDORES DE DADOS
        junto com paginação ordenação, temos os datas providers para encapsulamento
        Um data provider é uma classe que implementa yii\data\DataProviderInterface. 
        Ele suporta principalmente a recuperação de dados paginados e ordenados. 
        Geralmente é usado para trabalhar com widgets de dados de modo que os usuários 
        finais possam interativamente paginar e ordenar dados.

        // cria o data provider configurando suas propriedades de paginação e ordenação
        $provider = new XyzDataProvider([
          'pagination' => [...],
          'sort' => [...],
        ]);

        // recupera dados paginados e ordenados
        $models = $provider->getModels();

        // obtém o número de itens de dados na página atual
        $count = $provider->getCount();

        // obtém o número total de itens de dados de todas as páginas
        $totalCount = $provider->getTotalCount();

      e temos mais dataproviders para outro tipo de coisas
      'active data provider'
      'sql data provider'
      'array data provider'
      'chave de dados'

      e podemos criar data providers personalizados.



    WIDGETS DE DADOS
      https://www.yiiframework.com/doc/guide/2.0/pt-br/output-data-widgets

      temos detailView, single data model. da um display no model no seu formato regular
      -------------------------------------------
          echo DetailView::widget([
          'model' => $model,
          'attributes' => [
              'title',                                           // title attribute (in plain text)
              'description:html',                                // description attribute formatted as HTML
              [                                                  // the owner name of the model
                  'label' => 'Owner',
                  'value' => $model->owner->name,            
                  'contentOptions' => ['class' => 'bg-red'],     // HTML attributes to customize value tag
                  'captionOptions' => ['tooltip' => 'Tooltip'],  // HTML attributes to customize label tag
              ],
              'created_at:datetime',                             // creation date formatted as datetime
          ],
      ]);

    -------------------------------------------


    Mas aqui temos com dataproviders, uma listView. aproveitando este Widget para dar
    output em datas.
      -------------------------------------------
        use yii\widgets\ListView;
        use yii\data\ActiveDataProvider;

        $dataProvider = new ActiveDataProvider([
            'query' => Post::find(),
            'pagination' => [
                'pageSize' => 20,
            ],
        ]);
        echo ListView::widget([
            'dataProvider' => $dataProvider,
            'itemView' => '_post',
        ]);
        The _post view file could contain the following:

        <?php
        use yii\helpers\Html;
        use yii\helpers\HtmlPurifier;
        ?>
        <div class="post">
            <h2><?= Html::encode($model->title) ?></h2>

            <?= HtmlPurifier::process($model->text) ?>    
        </div>
      -------------------------------------------

      temos grid view. que faz um sistema de grid com poucas linhas de código
      com alguma data.

      -------------------------------------------

        use yii\grid\GridView;
        use yii\data\ActiveDataProvider;

        $dataProvider = new ActiveDataProvider([
            'query' => Post::find(),
            'pagination' => [
                'pageSize' => 20,
            ],
        ]);
        echo GridView::widget([
            'dataProvider' => $dataProvider,
        ]);

      -------------------------------------------


      Grid Columns também. temos até classes columns e vai um monte.

      FILTERING DATA
          feito peloas colunas, como no crud generator, temos o model que faz
          tudo as rules, scenarios e searchs

          -------------------------------------------
          <?php

            namespace app\models;

            use Yii;
            use yii\base\Model;
            use yii\data\ActiveDataProvider;

            class PostSearch extends Post
            {
                public function rules()
                { 
                    // only fields in rules() are searchable
                    return [
                        [['id'], 'integer'],
                        [['title', 'creation_date'], 'safe'],
                    ];
                }

                public function scenarios()
                {
                    // bypass scenarios() implementation in the parent class
                    return Model::scenarios();
                }

                public function search($params)
                {
                    $query = Post::find();

                    $dataProvider = new ActiveDataProvider([
                        'query' => $query,
                    ]);

                    // load the search form data and validate
                    if (!($this->load($params) && $this->validate())) {
                        return $dataProvider;
                    }

                    // adjust the query by adding the filters
                    $query->andFilterWhere(['id' => $this->id]);
                    $query->andFilterWhere(['like', 'title', $this->title])
                          ->andFilterWhere(['like', 'creation_date', $this->creation_date]);

                    return $dataProvider;
                }
            }
            
            -------------------------------------------

            SEPARATE FILTER FORM
              dai vai indo mais complexo, olhar a documentação quando tiver nesta parte
              https://www.yiiframework.com/doc/guide/2.0/pt-br/output-data-widgets


            e mais e mais coisas em output data
            


        TRABALHANDO COM CLIENT SCRIPTS  
          quando temos html page static, e trabalhamos com ajax, essa pagina da doc
          da support pra js e css dinamico.
          https://www.yiiframework.com/doc/guide/2.0/pt-br/output-client-scripts

          -registering scripts
          -registering inline scripts
          -registering scripts files
          
          assim como no css
          -registering css
          -registering inline css
          -registering asset bundles

          podemos gerar dynamic js, com uma config global do js

          $options = [
          'appName' => Yii::$app->name,
          'baseUrl' => Yii::$app->request->baseUrl,
          'language' => Yii::$app->language,
          // ...
          ];
          $this->registerJs(
              "var yiiOptions = ".\yii\helpers\Json::htmlEncode($options).";",
              View::POS_HEAD,
              'yiiOptions'
          );

          The above code will register a <script>-tag containing the JavaScript variable definition, e.g.:

          var yiiOptions = {"appName":"My Yii Application","baseUrl":"/basic/web","language":"en"};


        TEMAS
          https://www.yiiframework.com/doc/guide/2.0/pt-br/output-theming
          
          temas são nossos layouts, que ficam no conjunto das view.

          return [
              'components' => [
                  'view' => [
                      'theme' => [
                          'basePath' => '@app/themes/basic',
                          'baseUrl' => '@web/themes/basic',
                          'pathMap' => [
                              '@app/views' => '@app/themes/basic',
                          ],
                      ],
                  ],
              ],
          ];


      temos "temas" para módulos, widgets;
      herança de temas, geralmente quando tem algum feriado ou algo do tipo
        'pathMap' => [
            '@app/views' => [
                '@app/themes/christmas',
                '@app/themes/basic',
            ],
        ]

      Neste caso, a view @app/views/site/index.php seria tematizada tanto como 
      @app/themes/christmas/site/index.php ou @app/themes/basic/site/index.php, 
      dependendo de qual arquivo de tema existir. Se os dois arquivos existirem, 
      o primeiro terá precedência. Na prática, você iria manter mais arquivos de temas 
      em @app/themes/basic e personalizar alguns deles em @app/themes/christmas.



  ==========================================
    # SEGURANÇA

      !!AUTENTICAÇÃO!!(https://www.yiiframework.com/doc/guide/2.0/pt-br/security-authentication)
      
      processo de verificação de identidade do usuário, nome/token/etc
      ---yii\web\user 

            return [
            'components' => [
                'user' => [
                    'identityClass' => 'app\models\User',
                ],
            ],
        ];

      no caso precisamos da getAuthKey() e validateAuthKey(), para validar usuario, porém
      neste link temos outros métodos, e também se gravamos em cookie o user.

      Para logar um usuário, você pode usar o seguinte código:

      // encontrar uma identidade de usuário com o nome de usuário especificado.
      // observe que você pode querer checar a senha se necessário
      $identity = User::findOne(['username' => $username]);

      // logar o usuário
      Yii::$app->user->login($identity);

      Para realizar o logout de um usuário, simplesmente chame:

      Yii::$app->user->logout();

      ele também destruirá todos os dados da sessão do usuário. 
      Se você quiser guardar os dados da sessão, você deve chamar 
      Yii::$app->user->logout(false).

      existe também EVENTOS para autenticação
      EVENT_BEFORE_LOGIN
      EVENT_AFTER_LOGIN
      EVENT_BEFORE_LOGOUT
      EVENT_AFTER_LOGOUT
    


    !!AUTORIZAÇÃO!! (https://www.yiiframework.com/doc/guide/2.0/pt-br/security-authorization)

    verifica se o user tem permissão para fazer algo dentro da app.
    oferece o Filtro de Controle de Acesso(ACF) e Controle de Acesso Baseado em Role (RBAC)

    ACF apenas no controller, varias rules, e permissões que o usuário poderá fazer.
    behaviors = comportamento

    use yii\web\Controller;
    use yii\filters\AccessControl;

    class SiteController extends Controller
    {
      public function behaviors()
      {
          return [
              'access' => [
                  'class' => AccessControl::className(),
                  'only' => ['login', 'logout', 'signup'],
                  'rules' => [
                      [
                          'allow' => true,
                          'actions' => ['login', 'signup'],
                          'roles' => ['?'],
                      ],
                      [
                          'allow' => true,
                          'actions' => ['logout'],
                          'roles' => ['@'],
                      ],
                  ],
              ],
          ];
      }
      // ...
    }


    deny callbacks

      [
    'class' => AccessControl::className(),
    ...
    'denyCallback' => function ($rule, $action) {
        throw new \Exception('Você não está autorizado a acessar esta página');
        }
      ]

    
    temos um exemplo também de matchCallBack, lógica de validação de acesso,
    no caso, uma página disponível somente em uma certa data.

    use yii\filters\AccessControl;

    class SiteController extends Controller
    {
      public function behaviors()
      {
          return [
              'access' => [
                  'class' => AccessControl::className(),
                  'only' => ['special-callback'],
                  'rules' => [
                      [
                          'actions' => ['special-callback'],
                          'allow' => true,
                          'matchCallback' => function ($rule, $action) {
                              return date('d-m') === '31-10';
                          }
                      ],
                  ],
              ],
          ];
      }

      // Match callback chamada! Esta página pode ser acessado somente a cada 31 de outubro
      public function actionSpecialCallback()
      {
          return $this->render('happy-halloween');
      }
    }


    RBAC
      uma role representa coleção de permissão.(criar posts, atualizar posts etc);
      pode ser atribuída a um ou vários usuários.

  então temos a config do phpManager ou DbManager, que é feito pela config em components
  ++rbac (rolesPadrões);


  TRABALHANDO COM PASSWORDS
    bcrypt, criando passwords com hash

    -------------------------------------------
     $hash = Yii::$app->getSecurity()->generatePasswordHash($password);
     -------------------------------------------

     e quando vamos logar mesma coisa, validamos a password com hash.
     
     -------------------------------------------

     if (Yii::$app->getSecurity()->validatePassword($password, $hash)) {
        // all good, logging user in
    } else {
        // wrong password
    }
    -------------------------------------------


    CRIPTOGRAFIA
      só uma revisão dos seguintes assuntos
    
      -generating random data
      -encryption adn decryption
      -confirming data integrity

    Generating Pseudorandom Data
      geralmente usado para gerar algum tipo de senha ou token, como esqueci senha
      ou algo que precise de algo provisório para poder ser trocado depois. segue
      o exemplo de como gerar:

      $key = Yii::$app->getSecurity()->generateRandomString();

    Encryption and Decryption

    -------------------------------------------
    // $data and $secretKey are obtained from the form
    $encryptedData = Yii::$app->getSecurity()->encryptByPassword($data, $secretKey);
    // store $encryptedData to database
    -------------------------------------------

    quando queremos ler a data entao
    -------------------------------------------
    // $secretKey is obtained from user input, $encryptedData is from the database
    $data = Yii::$app->getSecurity()->decryptByPassword($encryptedData, $secretKey);
    -------------------------------------------

    Confirming Data Integrity
      confirmando integridade de alguma 'data' que pode vir de third party, ou até
      mesmo corrompida

      // $secretKey our application or user secret, $genuineData obtained from a reliable source
      $data = Yii::$app->getSecurity()->hashData($genuineData, $secretKey);

      Checks if the data integrity has been compromised
      // $secretKey our application or user secret, $data obtained from an unreliable source
      $data = Yii::$app->getSecurity()->validateData($data, $secretKey);

    ----------------------------------------------------------------

    SEGURANÇA - BOAS PRATICAS
    (https://www.yiiframework.com/doc/guide/2.0/en/security-best-practices)
      princípios básicos.
      -Filter input
      -escape output

      FILTER INPUT
        sempre devemos checar o input se são dados válidos e que o programa aceita.
        aqui simula um erro, joga um erro proposital.

        $sortBy = $_GET['sort'];
        if (!in_array($sortBy, ['title', 'created_at', 'status'])) {
          throw new Exception('Invalid sort value.');
        }

      e isto vai tudo de trabalhando dados, com validação e verificação
      validate() rules()

      ESCAPE OUTPUT
        praticamente não tomar injection, ou alguem de fora injetar códigos nos
        nossos formulários

        https://www.owasp.org/index.php/Command_Injection
        https://www.owasp.org/index.php/Code_Injection
        https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)

        alguns exemplos de vulnerabilidade.

      
      SQL INJECTION é outra injeção que levamos se não tratarmos a execução dos dados
      corretamente.

      no php tínhamos o "?" para esconder o valor, e executamos com a variável.

      ----------------------------------------------------------------
      // query builder
      $userIDs = (new Query())
          ->select('id')
          ->from('user')
          ->where('status=:status', [':status' => $status])
          ->all();

      // DAO
      $userIDs = $connection
          ->createCommand('SELECT id FROM user where status=:status')
          ->bindValues([':status' => $status])
          ->queryColumn();
      ----------------------------------------------------------------

      Avoiding XSS 
        cross-site scripting

        no yii, utilizamos o avoid fazendo.
        1-data outputted como plain text
        2-data outputted como HTML

      PLAIN TEXT
        <?= \yii\helpers\Html::encode($username) ?>
      
      HTML
        <?= \yii\helpers\HtmlPurifier::process($description) ?>

      htmlPurifier, como já vimos é um pouco pesado, então as vezes é necessário
      salvar algumas views em cache.

      ----------------------------------------------------------------

      Avoiding CSRF
        no yii temos 
        
       1-Follow HTTP specification i.e. GET should not change application state. 
          See RFC2616 for more details.
       2-Keep Yii CSRF protection enabled.

       praticamente nosso csrf token que tinha no laravel, e na hora de modificar
       algum estado, não utilizar GET, porque geralmente é feito por PUT/PATCH/POST

      ----------------------------------------------------------------

       Avoiding file exposure
        geralmente nossas files de upload fica no root onde não aparece nossos arquivos,
        no caso nosso index starta dentro da page web/index.php

      ----------------------------------------------------------------

      Avoiding debug info and tools in production

        quando estivermos em modo de produção não deixar o debug ON, para evitar
        exposição de dados confidenciais da aplicação.

      ----------------------------------------------------------------

      Using secure connection over TLS
        utilizamos request com encrypt ida e volta. como servidor SSL 
        protected.

      ----------------------------------------------------------------
        
        Secure Server configuration

        checar todas configs do server, para ver se não tem algum exploit
        que alguém mal intencionado possa utilizar.

      ----------------------------------------------------------------
      
      Avoiding Host-header attacks

        https://www.yiiframework.com/doc/guide/2.0/en/security-best-practices
      
        isso já vai do host config.
        // Web Application configuration file
        return [
            'as hostControl' => [
                'class' => 'yii\filters\HostControl',
                'allowedHosts' => [
                    'example.com',
                    '*.example.com',
                ],
                'fallbackHostInfo' => 'https://example.com',
            ],
            // ...
        ];

  ==========================================
    # CACHING

    cache armazena informações para não ter que precisar requisitar novamente os dados.
      ----------------------------------------------------------------
      CACHE DE DADOS
        utilizamos a variável "$cache" mesmo

        // tentar recuperar $data do cache
        $data = $cache->get($key);

        if ($data === false) {

            // $data não foi encontrado no cache, calculá-la do zero

            // armazenar $data no cache para que esta possa ser recuperada na próxima vez
            $cache->set($key, $data);
        }

        // $data é acessível a partir daqui
      ----------------------------------------------------------------

      Components de Cache, components como sempre ficam nossas configs
      pro cache é a mesma coisa.
      ----------------------------------------------------------------
          'components' => [
          'cache' => [
              'class' => 'yii\caching\MemCache',
              'servers' => [
                  [
                      'host' => 'servidor1',
                      'port' => 11211,
                      'weight' => 100,
                  ],
                  [
                      'host' => 'servidor2',
                      'port' => 11211,
                      'weight' => 50,
                  ],
              ],
          ],
      ],
      ----------------------------------------------------------------

      podemos acessar com "Yii::$app->cache"

      então tem o sistema de cache suportados
      https://www.yiiframework.com/doc/guide/2.0/pt-br/caching-data

      Temos a própria API pro cache
        -get(): recupera um registro no cache usando uma chave específica. Retorna false caso o item não for encontrado no cache ou se o registro está expirado/invalidado.
        -set(): armazena um registro no cache identificado por uma chave.
        -add(): armazena um registro no cache identificado por uma chave se a chave não for encontrada em cache.
        -mget(): recupera múltiplos registros do cache com as chaves especificadas.
        -mset(): armazena múltiplos registros no cache. Cada item identificado por uma chave.
        -madd(): armazena múltiplos registros no cache. Cada item identificado por uma chave. Se a chave já existir em cache, o registro é ignorado.
        -exists(): retorna se a chave específica é encontrada no cache.
        -delete(): remove um registro do cache identificado por uma chave.
        -flush(): remove todos os registros do cache.

    $cache['var1'] = $valor1;  // equivalente a: $cache->set('var1', $valor1);
    $valor2 = $cache['var2'];  // equivalente a: $valor2 = $cache->get('var2');


    Expiraçao de cache, podemos controlar, com algum tipo de politica aplicada para
    remover o cache, com tempo de expiração, ou o espaço de cache está cheio..
    aqui um exemplo com expiração por tempo no cache.

    ----------------------------------------------------------------
    // Manter o registro em cache por até 45 segundos
    $cache->set($chave, $registro, 45);

    sleep(50);

    $data = $cache->get($chave);
    if ($registro === false) {
        // $registro está expirado ou não foi encontrado no sistema
    }
    ----------------------------------------------------------------

    DEPENDÊNCIASS DE CACHE
      exemplo: dependencia na data de modificação de arquivo, o arquivo foi 
      alterado, então qualquer arquivo com data ultrapassada no cache deve ser invalidado.

      // Criar uma dependência sobre a data de modificação do arquivo exemplo.txt.
      $dependencia = new \yii\caching\FileDependency(['fileName' => 'exemplo.txt']);

      // O registro expirará em 30 segundos.
      // Ele também pode ser invalidado antes, caso o exemplo.txt seja modificado.
      $cache->set($key, $data, 30, $dependency);

      // O cache verificará se o registro expirou.
      // E também verificará se a dependência associada foi alterada.
      // Ele retornará false se qualquer uma dessas condições seja atingida.
      $data = $cache->get($key);

      ----------------------------------------------------------------

      na Doc existe um sumário com as dependências de cache disponíveis;

      CACHE DE CONSULTA 
        é preciso cosultar em algum lugar, ou seja, em um banco de dados ou em
        um componente de aplicação. mais específico caso salve cache em algum lugar.

      ----------------------------------------------------------------
        $resultado = $bd->cache(function ($bd) {
          
            // O resultado da consulta SQL será entregue pelo cache
            // se o cache de consulta estiver sido habilitado e o resultado da consulta for encontrado em cache
            return $bd->createCommand('SELECT * FROM clientes WHERE id=1')->queryOne();

        });
      ----------------------------------------------------------------
  
      pode ser usado pelo data access objects(DAO - banco de dados) ou com
      as classes de Active Record.

      $resultado = Cliente::getDb()->cache(function ($bd) {
          return Cliente::find()->where(['id' => 1])->one();
      });

      e outras configurações que o cache de consulta tem,
      -enableQueryCache
      -queryCacheDuration
      -queryCache

      utilizamos o cache de consulta desta maneira.
      ----------------------------------------------------------------
      $duracao = 60;     // armazenar os resultados em cache por 60 segundos
      $dependencia = ...;  // alguma dependência opcional

      $result = $db->cache(function ($db) {

          // ... executar consultas SQL aqui ...

          return $result;

      }, $duracao, $dependencia);
      ----------------------------------------------------------------

      CACHE DE FRAGMENTOS
        praticamente fragmentar o cache, nesse trecho de código começamos
        um bloco para armazenar tudo em cache.. com begincache() endcache()
        ----------------------------------------------------------------
        if ($this->beginCache($id)) {

            // ... gere o conteúdo aqui ...

            $this->endCache();
        }
        ----------------------------------------------------------------

        aqui tem outros parâmetros depois do $id do begincache que é a duration
        por default é 60s.
        ----------------------------------------------------------------
        if ($this->beginCache($id, ['duration' => 3600])) {

            // ... gerar o conteúdo aqui ...

            $this->endCache();
        }
        ----------------------------------------------------------------

        cache pode ter dependências também.
        ----------------------------------------------------------------
        $dependency = [
            'class' => 'yii\caching\DbDependency',
            'sql' => 'SELECT MAX(atualizado_em) FROM post',
        ];

        if ($this->beginCache($id, ['dependency' => $dependency])) {

            // ... gere o conteúdo aqui ...

            $this->endCache();
        }
        ----------------------------------------------------------------

        ['variations'] como idioma também é possível
        https://www.yiiframework.com/doc/guide/2.0/pt-br/caching-fragment

        e outros conceitos como
        toggling caching
        nested caching
        conteúdo dinâmico
        

        CACHE DE PÁGINA
          fizemos por meio de components, para salvar uma página inteira no cache
          por tempo que desejarmos nos "behaviors"

          ----------------------------------------------------------------
          public function behaviors()
          {
              return [
                  [
                      'class' => 'yii\filters\PageCache',
                      'only' => ['index'],
                      'duration' => 60,
                      'variations' => [
                          \Yii::$app->language,
                      ],
                      'dependency' => [
                          'class' => 'yii\caching\DbDependency',
                          'sql' => 'SELECT COUNT(*) FROM post',
                      ],
                  ],
              ];
          }
          ----------------------------------------------------------------

          CACHE HTTP
          https://www.yiiframework.com/doc/guide/2.0/pt-br/caching-http

            funciona com requisições GET e HEAD sendo:
            -last-Modified
            -Etag 
            -Cache-Control 

            LAST-MODIFIED
              utiliza um timestamp, quando o navegador visita uma página pela
              primeira vez, é gerado esta pagina no server. caso não tenha tido 
              nenhuma alteração da página por meio de posts e for o mesmo conteúdo
              ele pega do cache e renderiza a página do cache.

            CABEÇALHO Etag
              (entity tag) usa um 'hash' para representar o conteúdo, se a página
              for alterada, o hash irá mudar também. e compara os dois hashs para ver
              se tem alguma alteração, caso tenha, irá remontar novamente a página.

            CACHE-CONTROL 
              especifica políticas gerais para a página.

            existe outros tópicos como
            -limitador de cache na sessão
            -implicações para SEO.

                
  ==========================================
    # WEB SERVICES RESTFUL 

        INTRODUÇÃO

        O Yii fornece um conjunto de ferramentas para simplificar a tarefa de implementar APIs RESTful Web Service. Em particular, o Yii suporta os seguintes recursos sobre APIs RESTful:

          -Prototipagem rápida com suporte para APIs comuns de Active Record;
          -Negociação de formato do Response (suporte JSON e XML por padrão);
          -Serialização de objeto configurável com suporte a campos de saída selecionáveis;
          -Formatação adequada para a coleção e dados e validação de erros;
          -Suporte a HATEOAS;
          -Roteamento eficiente com verificação dos verbs (métodos) HTTP;
          -Construído com suporte aos métodos OPTIONS e HEAD;
          -Autenticação e autorização;
          -Data caching e HTTP caching;
          -Limitação de taxa;

        https://www.yiiframework.com/doc/guide/2.0/pt-br/rest-quick-start
      


        RECURSOS 
          da api restful

          // retorna todos os campos declarados em fields()
          http://localhost/users

          // retorna apenas os campos id e email, desde que estejam declarados em fields()
          http://localhost/users?fields=id,email

          // retorna todos os campos de fields() e o campo profile se este estiver no extraFields()
          http://localhost/users?expand=profile

          // retorna apenas o campo id, email e profile, desde que estejam em fields() e extraFields()
          http://localhost/users?fields=id,email&expand=profile

        também há possibilidade de reescrever as fields.

        LINKS - existe o HATEOAS(hypermedia as the engine of applications state)
          é um conjunto de hyperlinks, servidas pela api.

        COLLECTIONS - são coleções de ista de objetos do mesmo tipo. parecido com 
        data provider.

        ----------------------------------------------------------------

        namespace app\controllers;

        use yii\rest\Controller;
        use yii\data\ActiveDataProvider;
        use app\models\Post;

        class PostController extends Controller
        {
          public function actionIndex()
          {
              return new ActiveDataProvider([
                  'query' => Post::find(),
              ]);
          }
        }

        ----------------------------------------------------------------

        Quando envia a resposta com a API RESTFUL, a pagina serializa como um array.


        CONTROLLERS
          é bem parecido com controladores normais, porém com restful api
          https://www.yiiframework.com/doc/guide/2.0/pt-br/rest-controllers

          podemos customizar as açoes req http
          ----------------------------------------------------------------
          public function actions()
          {
            $actions = parent::actions();

            // desabilita as ações "delete" e "create"
            unset($actions['delete'], $actions['create']);

            // customiza a preparação do  data provider com o método "prepareDataProvider()"
            $actions['index']['prepareDataProvider'] = [$this, 'prepareDataProvider'];

            return $actions;
          }

          public function prepareDataProvider()
          {
            // preparar e retornar um data provider para a ação "index"
          }
          ----------------------------------------------------------------

          para isso temos ações para verificar accesso também, exista na doc a sintax.
          que é feito por checkAccess() podemos customizar as mensagens e tudo mais também.


        ROTEAMENTO  
          temos nosso component na web com o UrlManager, com pretty url que 
          está comentado.

          temos os comandos:

          [
            'PUT,PATCH users/<id>' => 'user/update',
            'DELETE users/<id>' => 'user/delete',
            'GET,HEAD users/<id>' => 'user/view',
            'POST users' => 'user/create',
            'GET,HEAD users' => 'user/index',
            'users/<id>' => 'user/options',
            'users' => 'user/options',
          ]

          e os endpoints, que podemos acessar com a api restfull

            -GET /users: lista todos os usuários página por página;
            -HEAD /users: mostrar a informações gerais da listagem de usuários;
            -POST /users: cria um novo usuário;
            -GET /users/123: retorna detalhes do usuário 123;
            -HEAD /users/123: mostrar a informações gerais do usuário 123;
            -PATCH /users/123 and PUT /users/123: atualiza o usuário 123;
            -DELETE /users/123: deleta o usuário 123;
            -OPTIONS /users: exibe os métodos suportados pela URL /users;
            -OPTIONS /users/123: exibe os métodos suportados pela URL /users/123.

          podemos ativar/desativar algumas actions, e tambem podemos Adicionar
          extraPatterns..

          Limitando as actions
          [
            'class' => 'yii\rest\UrlRule',
            'controller' => 'user',
            'except' => ['delete', 'create', 'update'],
          ],

          Adicionando extraPatterns
          [
            'class' => 'yii\rest\UrlRule',
            'controller' => 'user',
            'extraPatterns' => [
                'GET search' => 'search',
            ],
          ]


          FORMATAÇÃO DE RESPOSTAS
            praticamente mais components para poder ver a resposta da api
            e serializar corretamente para ficar interessante a Formatação
            https://www.yiiframework.com/doc/guide/2.0/pt-br/rest-response-formatting

          
          AUTENTICAÇÃO
            API RESTful são stateless, não deve ser utilizado session e cookies.
            deve retornar um estado de autenticação, que nao pode ser mantido
            em session/cookies. feito com access token, existe toda uma lógica por
            tras para evitar ataques de fora, e é feito com https.
            https://www.yiiframework.com/doc/guide/2.0/pt-br/rest-authentication

            Autorização, vem depois de autenticado, o usuário ainda precisa ser
            verificado se tem autorização para modificar algo.


          LIMITADOR DE ACESSO
          https://www.yiiframework.com/doc/guide/2.0/pt-br/rest-rate-limiting
            limite de requisições que o usuário poderá fazer. podemos definir 
            quantas req poderá fazer; feito com o \RateLimiterInterface

            -getRateLimit() -max de pedido reqs
            -loadAllowance() -numero restante de reqs
            -saveAllowance() -salva nº restante de reqs e hora atual.

            fica dentro dos behaviors
            ----------------------------------------------------------------
            public function behaviors()
            {
              $behaviors = parent::behaviors();
              $behaviors['rateLimiter']['enableRateLimitHeaders'] = false;

              return $behaviors;
            }
            ----------------------------------------------------------------

          VERSIONAMENTO
          https://www.yiiframework.com/doc/guide/2.0/pt-br/rest-versioning
            podemos fazer com modules, dentro de pastas com versões. a estrutura
            fica deste jeito.

            api/
              common/
                  controllers/
                      UserController.php
                      PostController.php
                  models/
                      User.php
                      Post.php
              modules/
                  v1/
                      controllers/
                          UserController.php
                          PostController.php
                      models/
                          User.php
                          Post.php
                      Module.php
                  v2/
                      controllers/
                          UserController.php
                          PostController.php
                      models/
                          User.php
                          Post.php
                      Module.php

            temos nosso common de todas as versões, e segue a mesma estruturação de
            pastas para todas versoes, e o nome da versão é a pasta que salva todos
            dados das versões.


            TRATAMENTO DE ERROS

              utiliza os verb http, e o yii utiliza alguns status para mostrar
              o que foi feito. alguns são parecidos com o que já conhecemos
              mas outros tem algumas modificações do framework.

                -200: OK. Tudo funcionou conforme o esperado;
                -201: Um recurso foi criado com êxito em resposta a uma requisição POST. O cabeçalho location contém a URL que aponta para o recurso recém-criado;
                -204: A requisição foi tratada com sucesso e a resposta não contém nenhum conteúdo no corpo (por exemplo uma requisição DELETE);
                -304: O recurso não foi modificado. Você pode usar a versão em cache;
                -400: Requisição malfeita. Isto pode ser causado por várias ações por parte do usuário, tais como o fornecimento de um JSON inválido no corpo da requisição, fornecendo parâmetros inválidos, etc;
                -401: Falha de autenticação;
                -403: O usuário autenticado não tem permissão para acessar o recurso da API solicitado;
                -404: O recurso requisitado não existe;
                -405: Método não permitido. Favor verificar o cabeçalho Allow para conhecer os métodos HTTP permitidos;
                -415: Tipo de mídia não suportada. O número de versão ou o content type requisitado são inválidos;
                -422: Falha na validação dos dados (na resposta a uma requisição POST, por exemplo). Por favor, verifique o corpo da resposta para visualizar a mensagem detalhada do erro;
                -429: Excesso de requisições. A requisição foi rejeitada devido a limitação de taxa;
                -500: Erro interno do servidor. Isto pode ser causado por erros internos do programa.


              Podemos customizar as respostas de erros
              https://www.yiiframework.com/doc/guide/2.0/pt-br/rest-error-handling

              {
                "success": false,
                "data": {
                    "name": "Not Found Exception",
                    "message": "The requested resource was not found.",
                    "code": 0,
                    "status": 404
                }
              }

              porém é preciso ir nos components e response adicionar um código
              paa checar se foi enviado realmente e saiu a reposta esperada.
              com o on beforeSend.

  ==========================================
    # TESTES  
      Aqui fala basico de teste, porque faze-lo etc.
        -Criar um novo teste que descreve uma funcionalidade a ser implementada.
        -Execute o novo teste e verifique se ele falha. isto é esperado já que não há nenhuma implementação ainda.
        -Escrever um código simples para fazer o novo teste passar.
        -Executar todos os testes e garantir que todos eles passam.
        -Melhorar código e certificar-se de testes ainda estão OK.


      e também quando devemos e não devemos utilizar testes
      https://www.yiiframework.com/doc/guide/2.0/pt-br/test-overview

      CONFIGURANDO AMBIENTE DE TESTES
        -codeception é a ferramenta de testes

        dentro dele temos vários tipos de testes
        -unit(teste unitário, single code)
        -functional(cenario da perspectiva do usuario emulada no browser)
        -acceptance(cenario da perspectiva do usuario no browser)

        codeception já vem instalado no basic/advanced template.
          caso de algum problema, aqui é como instalar ele no projeto
          via composer.
          
          composer require --dev codeception/codeception
          composer require --dev codeception/specify
          composer require --dev codeception/verify

        
        TESTES UNITÁRIOS (https://www.yiiframework.com/doc/guide/2.0/pt-br/test-unit)

          temos outros links fora da documentação para começar a testar
          https://codeception.com/for/yii
          * https://codeception.com/docs/05-UnitTests
          https://phpunit.de/manual/6.5/en/writing-tests-for-phpunit.html

          temos estes 3 acima,
          e também doc para o basic/advanced
          e tbm do framework unit testing

        TESTES FUNCIONAIS
          é parecido com o de aceitação, so que ao inves de req http
          faz pelo POST e GET

          https://codeception.com/docs/04-FunctionalTests

        TESTES DE ACEITAÇÃO
          geralmente faz as mesmas coisas de cima, porém via browser e também
          de como usuario usa a interface, junto com ui/ux

          não tem nenhum link, praticamente e o mesmo do functional.

        
        FIXTURES
          não compreendi muito. sua proposta e setar o ambiente para um 
          estado fixo/conhecido, então seus testes consegue ser repetidos 
          e continuar rodando corretamente. 

          parece que consegue pegar os dados dinamicamente conforme vai trocando
          dentro de variáveis, e o testes mesmo mudando valores consegue rodar sem
          nenhum problema.
          https://www.yiiframework.com/doc/guide/2.0/pt-br/test-fixtures


  ==========================================
    #  TÓPICOS ESPECIAIS
        
        aqui também aparece o advanced template. o que está instalado é o basic.
        https://github.com/yiisoft/yii2-app-advanced/tree/master/docs/guide-pt-BR

        CONSTRUINDO APLICAÇÃO A PARTIR DO ZERO  
          como se fosse o getting started, fala como iniciar a aplicação etc.
          https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-start-from-scratch


        APLICAÇÕES DE CONSOLE 
          commando line "php yii"
          temos uma lista de opções como se fosse o php artisan do laravel.

          https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-console

          podemos criar também nossos próprios comandos. e outras customizações.

        VALIDADORES NATIVOS
          temos uma lista com varios validadores que o yii consegue utilizar
          https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-core-validators

          -boolean
          -captcha
          -compare
          -date
          -default
          -double 
          -each
          -email
          -exist
          -file
          -filter
          -image
          -in(level in range)
          -integer
          -match(expressão regular)
          -number
          -required
          -safe
          -string
          -trim
          -unique
          -url

      DOCKER
        aqui explica porque utilizar e também como instalar no yii
        praticamente usamos para virtualizar uma maquina, deixa máquina
        vazia simula um software identico no que irá rodar, podemos ter vários
        servidores e arquiteturas diferentes.

        https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-docker

        INTERNACIONALIZAÇÃO
          software pode-se adaptar a diversas regiões e linguagens, sem muitas
          mudanças

          -locale
          -language
          
          praticamente podemos traduzir tudo com Yii::t() ou no component verificar
          quais paginas podemos traduzir, ou traduzir tudo dentro do app, na config 
          que mostra na url abaixo. existem varios tipos de translations. de uma 
          simples frase até os widgets e as frameworks messages.
          https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-i18n


        ENVIO DE EMAIlS
          precisamos configurar primeiro nosso componentes 'mailer' deste jeito;
          https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-mailing

            ----------------------------------------------------------------
              return [
                //....
                'components' => [
                    'mailer' => [
                        'class' => 'yii\swiftmailer\Mailer',
                        'useFileTransport' => false,
                        'transport' => [
                            'class' => 'Swift_SmtpTransport',
                            'encryption' => 'tls',
                            'host' => 'your_mail_server_host',
                            'port' => 'your_smtp_port',
                            'username' => 'your_username',
                            'password' => 'your_password',
                        ],             
                    ],
                ],
            ];
            ----------------------------------------------------------------

            e praticamente podemos enviar deste jeito.
            
            Yii::$app->mailer->compose()
            ->setFrom('from@domain.com')
            ->setTo('to@domain.com')
            ->setSubject('Message subject')
            ->setTextBody('Plain text content')
            ->setHtmlBody('<b>HTML content</b>')
            ->send();


            ele utiliza como podemos ver o swiftmailer, então só configurar o
            envio, encryption/host/port e tudo mais.

            na página temos como criar uma instancia pra emails, e também
            como enviar múltiplos emails.

            composing email, podemos fazer com text html e outras coisas,
            mandar até algo parecido com uma página html

            também explica como enviar files, (file attachment)
            embedding images, que pega dos nossos arquivos.

            para testes temos, o yii\mail\BaseMailer::useFileTransport, que ao 
            invés de enviar o email, guarda nas nossas local files.


          AJUSTES DE DESEMPENHO  
            https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-performance-tuning

            uma delas é otimizar o php environment, ultimas versoes,
            caching.

            desativando debug mode, que é praticamente obrigatório quando o app está
            em produção.

            usando técnicas de armazenamento em cache.

            schema caching pode ser ativado nos components, de 'db', assim salvar
            informações relativas do schema(db), temos o 'enable,duration,name';

            Combinando e minimizando os assets, já vimos dos assets bundles, ou até
            mesmo compressar os arquivos. minimizando também.

            otimizando sessão storage, aqui recomenda quando tem muito acesso, até
            usar o DbSession storage, que armazena as sessions no banco de dados.

            otimizar a database, tanto na estrutura quanto nas requisições que fizemos
            com as query's dela.

            usar asArray nas active records, quando exige uma requisição muito grande.

            otimizar o autoloader do composer, geralmente o dump.
              command line "composer dumpautoload -o" 
            geralmente fizemos isto logo antes de colocar em produção.

            processar data offline (mais complexo, melhor ler na doc)
            Performance Profiling (algumas ferramentas disponiveis para checar
              como está a performance do app)
                -debug toolbar (para debugar a app)
                -blackfire (que é para os testes de performance)
                -XHProf (alguma coisa do php tbm)
                -Xdebug (mais ferramenta para performance)

            e escalar a aplicação, caso cresca muito, aqui vai algumas
            coisas que devem ser feitas.
            https://github.com/samdark/yii2-cookbook/blob/master/book/scaling.md


          AMBIENTE DE HOSPEDAGEM COMPARTILHADA
            https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-shared-hosting

            praticamente compartilhando as mesmas files localmente como servidor lan
            que já foi feito no incio aqui, renomeando webroot,
            na doc mostra como fazer isto para o template basic e advanced.

            session e cookies separados também tem uma config, geralmente para o 
            template advanced que separa o frontend e backend.

          
          USANDO TEMPLATE ENGINES
            por padrão é o php mesmo, tem outras que o framework suporta e sugere
            que são 'twig' e 'smarty', e podemos configurar no nosso component.

            e praticamente é isto, como configurar e como utilizar estão nos seus
            respectivos sites.
            https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-template-engines

          
          TRABALHANDO COM CÓDIGOS DE TERCEIROS
            geralmente códigos de tercerios vem através de pacotes pelo Composer.

            1-Modifique o arquivo composer.json da sua aplicação e informe quais 
              pacotes Composer você deseja instalar.
            2-Execute composer install para instalar os pacotes especificados.

            elas são carregadas automaticamentes pelo autoload de classes.

            caso baixamos alguma biblioteca. temos como configurar também. melhor
            ver pela documentação.
            https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-yii-integration


            podemos utilizar o Yii em sistemas de terceiros também, baixando via
            composer
                
                composer global require "fxp/composer-asset-plugin:^1.4.1"
                composer require yiisoft/yii2
                composer install

            também como fazer config esta pela documentação..
            podemos usar Yii2 com o Yii1.


          USANDO YII COMO UM MICROFRAMEWORK
            https://www.yiiframework.com/doc/guide/2.0/pt-br/tutorial-yii-as-micro-framework

            instando o yii de forma diferente, como micro-app.
            e aqui é como se fosse um getting started, utilizando como micro-framework
            sobre o sistema de controllers, e até as rest api.

  ==========================================
    #  WIDGETS

      todos widgets são da API DOC, não tem nesse helping document.
      então vou listar quais estão disponíveis.

    aqui aparece o widget e o lista com doc e suas propriedades, mas não tem
    nenhum tipo de imagem representativa. aqui os widgets que aparecem.

    -GRIDVIEW
    -LISTVIEW 
    -DETAILVIEW
    -ACTIVEFORM
    -PJAX
    -MENU
    -LINKPAGER
    -LINKSORTER
    -WIDGETS BOOTSTRAP
    -WIDGETS JQUERY UI

  ==========================================
    #  HELPERS, FUNÇÕES AUXILIARES

      exemplo de helper é aquele Enconde:: que vimos. na questão de segurança
      https://www.yiiframework.com/doc/guide/2.0/pt-br/helper-overview
     
      use yii\helpers\Html;
      echo Html::encode('Test > test');


    CORE HELPERS CLASSES
      -ArrayHelper
      -Console
      -FileHelper
      -FormatConverter
      -Html
      -HtmlPurifier
      -Imagine (provided by yii2-imagine extension)
      -Inflector
      -Json
      -Markdown
      -StringHelper
      -Url
      -VarDumper
    
      podemos também customizar nossos helpers, com classmaps e components,
      caso queiramos colocar alguma coisa a mais ou menos. depois ele tem alguma
      documentação de alguns helpers que devem ser mais complexos.

      ARRAY HELPER
        pegando os valores
        setando valores
        pegando um valor de um array
        checando a existencias de chaves do array
        retornando as colunas
        reindexando arrays
        buiding maps
        multidimensional sorting
        detectando arrays types 
        html encoding e decoding values
        merging arrays
        converting objects to arrays
        testing agains arrays

      HTML
        aqui fala mais da geração de tags html, que é bastante utilizado e temos
        o encode junto.
        ----------------------------------------------------------------
          HELPER
          <?= Html::tag('p', Html::encode($user->name), ['class' => 'username']) ?>

          O QUE É GERADO
          <p class="username">samdark</p>
        ----------------------------------------------------------------

        também podemos fazer gerando classes css
        ----------------------------------------------------------------
          $options = ['class' => 'btn btn-default'];

          if ($type === 'success') {
              Html::removeCssClass($options, 'btn-default');
              Html::addCssClass($options, 'btn-success');
          }

          echo Html::tag('div', 'Pwede na', $options);

          // if the value of $type is 'success' it will render
          // <div class="btn btn-success">Pwede na</div>
        ----------------------------------------------------------------


        para múltiplo css podemos fazer deste jeito.
        ----------------------------------------------------------------
        $options = ['class' => ['btn', 'btn-default']];

        echo Html::tag('div', 'Save', $options);
        // renders '<div class="btn btn-default">Save</div>'
        ----------------------------------------------------------------

        podemos usar da forma de array tbm, que tem na documentação e também
        podemos estilizar diretamente por alguma variável, segue o exemplo:
        ----------------------------------------------------------------
        $options = ['style' => ['width' => '100px', 'height' => '100px']];

        // gives style="width: 100px; height: 200px; position: absolute;"
        Html::addCssStyle($options, 'height: 200px; position: absolute;');

        // gives style="position: absolute;"
        Html::removeCssStyle($options, ['width', 'height']);
        ----------------------------------------------------------------


        e o encode e decoding que é uma das principais funcionalidade desse
        helper.
        ----------------------------------------------------------------
        $userName = Html::encode($user->name);
        echo $userName;

        $decodedUserName = Html::decode($userName);
        ----------------------------------------------------------------


        CRIANDO FORMS
          <?= Html::beginForm(['order/update', 'id' => $id], 'post', ['enctype' => 'multipart/form-data']) ?>
          <?= Html::endForm() ?>

          BUTTONS
            <?= Html::button('Press me!', ['class' => 'teaser']) ?>
            <?= Html::submitButton('Submit', ['class' => 'submit']) ?>
            <?= Html::resetButton('Reset', ['class' => 'reset']) ?>

          INPUT FIELDS
          ----------------------------------------------------------------
          //type, input name, input value, options
          <?= Html::input('text', 'username', $user->name, ['class' => $username]) ?>

          //type, model, model attribute name, options
          <?= Html::activeInput('text', $user, 'name', ['class' => $username]) ?>
          ----------------------------------------------------------------

          depois tem mais uns shortcuts, mais avançados
          -buttonInput
          -submitInput
          -resetInput
          -textInput/activeTextInput
          -hiddenInput/activeHiddenInput
          -passwordInput/activePasswordInput
          -fileInput/activeFileInput
          -textarea/activeTextarea

          depois exemplos de códigos com RADIOS e CHECKBOXES
          Dropdown list e list boxes tbm
          Label e Errors

          existe também como recuperar inputnames e values direto do model
          com algumas funções, que pode ser útil
          ----------------------------------------------------------------
          // Post[title]
          echo Html::getInputName($post, 'title');

          // post-title
          echo Html::getInputId($post, 'title');

          // my first post
          echo Html::getAttributeValue($post, 'title');

          // $post->authors[0]
          echo Html::getAttributeValue($post, '[0]authors[0]');
          ----------------------------------------------------------------


          podemos gerar css e scripts dentro dessa classe de HTML;

          ----------------------------------------------------------------
          <?= Html::style('.danger { color: #f00; }', ['media' => 'print']) ?>

          Gives you

          <style media="print">.danger { color: #f00; }</style>


          <?= Html::script('alert("Hello!");') ?>

          Gives you

          <script>alert("Hello!");</script>
          ----------------------------------------------------------------

          assim como importar um certo estilo caso seja em algum navegador,
          no caso do internet explorer.
          ----------------------------------------------------------------
          <?= Html::cssFile('@web/css/ie5.css', ['condition' => 'IE 5']) ?>

          generates

          <!--[if IE 5]>
              <link href="http://example.com/css/ie5.css" />
          <![endif]-->
          ----------------------------------------------------------------

          depois temos ainda generação de mais tags.
          HYPERLINKS
          IMAGES
          LISTS


        URL HELPER
          helpers com url(https://www.yiiframework.com/doc/guide/2.0/pt-br/helper-url)
          ----------------------------------------------------------------
          $relativeHomeUrl = Url::home();
          $absoluteHomeUrl = Url::home(true);
          $httpsAbsoluteHomeUrl = Url::home('https');
          ----------------------------------------------------------------

          CRIANDO URL'S
            utilizamos o método toRoute()
            ----------------------------------
            $url = Url::toRoute(['product/view', 'id' => 42]);

            com parâmetros
            ---------------------
            // generates: /index.php?r=site/index&param1=value1&param2=value2
            ['site/index', 'param1' => 'value1', 'param2' => 'value2']

            com anchor(a tag)
            --------------------
            // generates: /index.php?r=site/index&param1=value1#name
            ['site/index', 'param1' => 'value1', '#' => 'name']


            e aqui quando cria alias.
            --------------------------------------------
            // /index.php?r=site/index
            echo Url::toRoute('site/index');

            // /index.php?r=site/index&src=ref1#name
            echo Url::toRoute(['site/index', 'src' => 'ref1', '#' => 'name']);

            // /index.php?r=post/edit&id=100     assume the alias "@postEdit" is defined as "post/edit"
            echo Url::toRoute(['@postEdit', 'id' => 100]);

            // http://www.example.com/index.php?r=site/index
            echo Url::toRoute('site/index', true);

            // https://www.example.com/index.php?r=site/index
            echo Url::toRoute('site/index', 'https');

            ----------------------------------------------------

            temos também o url::to que é um outro tipo, que é feito com arrays.
            tem na doc.


            RELEMBRAR URL'S
              Há casos que você precisa relembrar url's, e é feito de forma simples

            ----------------------------------------------------
              // Remember current URL 
              Url::remember();

              // Remember URL specified. See Url::to() for argument format.
              Url::remember(['product/view', 'id' => 42]);

              // Remember URL specified with a name given
              Url::remember(['product/view', 'id' => 42], 'product');
            ----------------------------------------------------

            depois podemos tratar essas url para voltar com essas funções.
            -------------------------------
            $url = Url::previous();
            $productUrl = Url::previous('product');


            também tem função para saber se a url é relativa, quando tem
            informação do host