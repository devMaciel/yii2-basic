# Start Forms
  --SiteController: criar o model request(post) validate, view
  --Model: Formulario de Registro, model rules
  --View: Formulário(widgets)
  --View: Resposta do formulário

# Banco de Dados, ActiveRecord(sintaxe tipo eloquent(laravel))
  --Criar ActiveRecord (models), [Customer]
  --Checar conexão (config.db)
  ----querybuilder https://www.yiiframework.com/doc/guide/2.0/pt-br/db-query-builder#query-methods

  DB Browser SQLITE
  --schema/table
  --model: pais
  --PaisController: active record query's
  --'dsn' => 'sqlite:teste.sqlite', (cria banco em web->testesql)
  --view: pasta da action e index, view render db

# Gerando código com GII (https://www.yiiframework.com/doc/guide/2.0/pt-br/start-gii)
  --Models 
  --generate/overwrite - tableName - ModelClassName (pais-Pais), ctrl+c ou overwrite.

  --generate crud
  Model Class
    app\models\Pais
  Search Model Class
    app\models\PaisSearch
  Controller Class
    app\controllers\PaisController
  View Path
    @app/views/pais
  
  --criar namespace do models, o PaisSearch é a nova do crud, adicona o controller
    e a view, já criamos o controller model e view, e precisamos dar overwrite, 
    para criar os códigos template com support ao crud.

  urlparam: ?r=pais/index.
  urlparam-pais(update/delete): ?r=pais%2Fview&id=SS

# Seguindo em Frente (https://www.yiiframework.com/doc/guide/2.0/pt-br/start-looking-ahead)
- Docs (classes) - https://www.yiiframework.com/doc/api/2.0/index
- Wiki (forum/stack somente o yii2) - https://www.yiiframework.com/wiki?tag=yii2
- O Guia - https://www.yiiframework.com/doc/guide/2.0/pt-br
- Plugins/Extensões do yii2 - https://www.yiiframework.com/extensions

# Estrutura da Aplicação
- https://www.yiiframework.com/doc/guide/2.0/pt-br/structure-overview
-- Defined(const) em scripts de entrada, (modo web, console)
  EXEMPLO DO SCRIPT DE entrada
    require __DIR__ . '/../vendor/autoload.php';
    require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

    // carrega a configuração da aplicação
    $config = require __DIR__ . '/../config/web.php';

    // instancia e configura a aplicação
    (new yii\web\Application($config))->run();
  
  temos este arquivo rodando nosso basic app, temos as constantes/autoloads/vendor.

  Propiedades da App, required.
  id;basePath, 
    id geralmente ja vem um, a nao ser que tenha mais de uma app.
    basePath, caminho da app, do codfont, podemos criar aliases(atalhos), base path(@app)

    Exemplo de ALIASES
    [
      [
        'aliases' => [
          '@name1' => 'path/to/path1',
          '@name2' => 'path/to/path2',
      ],
    ]

  bootstrap da app
  -array de componentes, modulos, regras da app, que pode ser carregado junto com a app.
    exemplo do debug e o gii

  outras propriedades:
  --catchAll, pega todas requisições web para mostrar.
  --components - consegue armazenar lista de components, como cache/users/autologin etc
    tipo um bootstraping
  --ControllerMap, pega o controller e configura algumas coisas, como csrf token.
  --ControllerNamespace, como nome ja diz, consegue modificar o namespace do controller.
  --language, muda linguangem para o usuario final, padrão. 
  --modules, modules e configurações, ex: da config da database.
  --names/--params/--sourceLanguage/--timeZone/--version/--charset
    --defaultRoute/--extensions(plugins)
  
  --layout, layout da app, headers/footers etc, /--layoutPath
  --runtimePath, arquivos temporários/cache
  --viewpath/--vendorPath

  EVENTOS DA APLICAÇÃO
  [
    'on beforeRequest' => function ($event) {
        // ...
    },
  ]

  EVENT_BEFORE_REQUEST (antes do post)
  EVENT_AFTER_REQUEST  (depois do post)
  EVENT_BEFORE_ACTION   (antes de executar cada action controller)
  EVENT_AFTER_ACTION    (depois de executar cada action controller)

  LIFE CICLE
  -Script de entrada, carrega as config como array
  
  -- cria uma nova instancia da app
  --- preInit() config alta prioridade como o basePath
  --- config das propriedades da app
  --- init() chama o bootstrap() roda os components de inicialização

  ---- yii2 app run..
  ---- dispara os eventos, os before
  ---- resolve as rotas, params, model, controllers actions
  ---- dispara os eventos after 
  ---- envia resposta pro final user.

  ----- status code e completa o processamento.

  MVC
  Controllers/Rotas
  --Rotas é baseado na action e nos controllers
  Segue alguns exemplos, assumindo que o namespace do controller tenha por 
  padrão o valor app\controllers:

  article torna-se app\controllers\ArticleController;
  post-comment torna-se app\controllers\PostCommentController;
  admin/post-comment torna-se app\controllers\admin\PostCommentController;
  adminPanels/post-comment torna-se app\controllers\adminPanels\PostCommentController.

  também é possível mapear os controllers, para seguir um padrão, quando vem de crosssite.
  [
    'controllerMap' => [
        // declara o controller "account" usando um nome de classe
        'account' => 'app\controllers\UserController',

        // declara o controller "article" usando uma configuração em array
        'article' => [
            'class' => 'app\controllers\PostController',
            'enableCsrfValidation' => false,
        ],
    ],
  ]

  Segue algumas boas práticas em destaque. Os controllers:

  podem acessar os dados de uma requisição;

  podem chamar os métodos dos models e outros componentes de serviço com dados 
  da requisição;
  podem usar as views para compor as respostas;

  NÃO devem processar os dados da requisição - isto deve ser feito na 
  camada model (modelo);

  devem evitar inserir códigos HTML ou outro código de apresentação - é 
  melhor que sejam feitos nas views.

  Models
  -temos nossos request;rules/validations/atributos, nossa conexão com algumas
    tabela do db que passa pro controller dps como variável/const.

  atribuição em massa, podemos fazer apenas com atributos seguros(safe)
  public function rules()
  {
      return [
          [['title', 'description'], 'safe'],
      ];
  }

  não seguros podemos colocar !
  public function scenarios()
  {
      return [
          'login' => ['username', 'password', '!secret'],
      ];
  }

  na exportação de dados, são convertidos em arrays, porém podemos especificar depois
  para retornar um outro tipo de dado.

  boas praticas no model
  Em resumo, os models (modelos):

  podem conter atributos para representar os dados de negócio;
  podem conter regras de validação para garantir a validade e integridade dos dados;
  podem conter métodos para implementar lógicas de negócio;
  NÃO devem acessar diretamente as requisições, sessões ou quaisquer dados do ambiente do usuário. Os models (modelos) devem receber estes dados a partir dos controllers (controladores);
  devem evitar inserir HTML ou outros códigos de apresentação – isto deve ser feito nas views (visões);
  devem evitar ter muitos cenários em um único model (modelo).

  Views 
  --Segurança, sobre Html::encode, codifica o nome de usuario antes de exibi-lo

      <?php
      use yii\helpers\Html;
      ?>

      <div class="username">
          <?= Html::encode($user->name) ?>
      </div>

    Exibir conteúdo html, filtrar conteudo primeiro, ele é mais lento, então é melhor
    guardar em cache, se for usar muitas vezes.

      <?php
      use yii\helpers\HtmlPurifier;
      ?>

      <div class="post">
          <?= HtmlPurifier::process($post->text) ?>
      </div>

    
    além da render() temos outros tipos de render()...

    Nos controllers, você pode chamar os seguintes métodos para renderizar as views:

    render(): renderiza uma view nomeada e aplica um layout ao resultado da renderização.
    renderPartial(): renderiza uma view nomeada sem qualquer layout.
    renderAjax(): renderiza uma view nomeada sem qualquer layout e injeta todos os arquivos JS/CSS registrados. É geralmente utilizado em respostas de requisições Web Ajax.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.
    renderContent(): renderiza um conteúdo estático que será incorporado no layout selecionado. Este método está disponível desde a versão 2.0.1.

    na renderização de widgets podemos utiliar as seguintes:
    render(): renderiza uma view nomeada.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.

    podemos renderizar uma view dentro de outra:
    render(): renderiza uma view nomeada.
    renderAjax(): renderiza uma view nomeada sem qualquer layout e injeta todos os arquivos JS/CSS registrados. É geralmente utilizado em respostas de requisições Web Ajax.
    renderFile(): renderiza uma view a partir de um caminho de arquivo ou a partir de um alias.

    <?= $this->render('_visao-geral') ?>

    renderização de outros lugares, no código
    // exibe a view "@app/views/site/license.php"
    echo \Yii::$app->view->renderFile('@app/views/site/license.php');

    Compartilhando Dados entre as Views
    O componente view fornece a propriedade params que você pode usar para compartilhar dados entre as views.

    Por exemplo, em uma view sobre, você pode ter o seguinte código que especifica o seguimento atual do "rastro de navegação" (breadcrumbs):

    $this->params['breadcrumbs'][] = 'Sobre nós';
    Em seguida, no arquivo layout, que também é uma view, você pode exibir o "rastro de navegação" (breadcrumbs) usando os dados passados pela propriedade params:

    <?= yii\widgets\Breadcrumbs::widget([
        'links' => isset($this->params['breadcrumbs']) ? $this->params['breadcrumbs'] : [],
    ]) ?>




    Exemplo de layout, header/footer - content

    <?php
      use yii\helpers\Html;

      /* @var $this yii\web\View */
      /* @var $content string */
      ?>
      <?php $this->beginPage() ?>
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8"/>
          <?= Html::csrfMetaTags() ?>
          <title><?= Html::encode($this->title) ?></title>
          <?php $this->head() ?>
      </head>
      <body>
      <?php $this->beginBody() ?>
          <header>Minha Empresa</header>
          <?= $content ?>
          <footer>&copy; 2014 por Minhas Empresa</footer>
      <?php $this->endBody() ?>
      </body>
      </html>
      <?php $this->endPage() ?>



      Podemos utilizar layouts aninhados

      <?php $this->beginContent('@app/views/layouts/base.php'); ?>

      ...conteúdoo do layout filho aqui...

      <?php $this->endContent(); ?>

      
      podemos definir blocos no meio do layout também
      <?php $this->beginBlock('bloco1'); ?>

      ...conteúdoo do bloco1...

      <?php $this->endBlock(); ?>

      ...

      <?php $this->beginBlock('bloco3'); ?>

      ... conteúdoo do bloco3...

      <?php $this->endBlock(); ?>

      
      dai no layout temos que colocar o content do bloco também;
      ...
      <?php if (isset($this->blocks['bloco1'])): ?>
          <?= $this->blocks['bloco1'] ?>
      <?php else: ?>
          ... conteúdoo padrãoo para o bloco1 ...
      <?php endif; ?>


    Temos TEMAS, de widgets/modules e herança de temas

    ----------TODO-----------
    continuando na estrutura da documentação

    Config de title dapágina normal, tipo layout

    <?php
      $this->title = 'Título da Minha Página';
    ?>

    e dentro do layout encoded
    <title><?= Html::encode($this->title) ?></title>

    META TAGS 
    <?php
    $this->registerMetaTag(['name' => 'keywords', 'content' => 'yii, framework, php']);
    ?>

    KEYWORDS 
    <meta name="keywords" content="yii, framework, php">

    TAG LINKS
      $this->registerLinkTag([
      'title' => 'Notícias sobre o Yii',
      'rel' => 'alternate',
      'type' => 'application/rss+xml',
      'href' => 'http://www.yiiframework.com/rss.xml/',
    ]);

    codigo acima vai da nisso aqui:
    <link title="Notícias sobre o Yii" rel="alternate" type="application/rss+xml" href="http://www.yiiframework.com/rss.xml/">

    View também tem seus EVENTOS
    EVENT_BEFORE_RENDER
    EVENT_AFTER_RENDER
    EVENT_BEGIN_PAGE
    EVENT_END_PAGE
    EVENT_BEGIN_BODY
    EVENT_END_BODY


    exemplo de renderizar data com yii2 com php
    \Yii::$app->view->on(View::EVENT_END_BODY, function () {
     echo date('Y-m-d');
    });

    Página estáticas são aquelas que não existem nada de param de database ou vem do
    form.

    public function actionAbout()
    {
        return $this->render('about');
    }

    para repetir varias paginas estaticas podemos colocar uma action"externa" standalone.


    namespace app\controllers;

    use yii\web\Controller;

    class SiteController extends Controller
    {
        public function actions()
        {
            return [
                'page' => [
                    'class' => 'yii\web\ViewAction',
                ],
            ];
        }
    }


  BOAS PRATICAS da view
  Views são responsáveis por apresentar models (modelos) no formato que os usuários finais desejam. Em geral, views:

  devem conter principalmente código de apresentação, tal como o HTML, e trechos simples de PHP para percorrer, formatar e renderizar dados.
  não devem conter código de consulta ao banco de dados. Consultas assim devem ser feitas nos models.
  devem evitar acessar diretamente os dados da requisição, tais como $_GET e $_POST pois essa tarefa cabe aos controllers. Se os dados da requisição forem necessários, deverão ser fornecidos às views pelos controllers.
  podem ler as propriedades dos models, mas não devem alterá-las.
  Para tornar as views mais gerenciáveis, evite criar views muito complexas ou que contenham muito código redundante. Você pode usar as seguintes técnicas para atingir este objetivo:

  use layouts para representar as seções de apresentação comuns (por exemplo, cabeçalho e rodapé).
  divida uma view complicada em varias outras menores. As views menores podem ser renderizadas e montadas em uma maior usando os métodos descritos anteriormente.
  crie e use widgets como blocos de construção das views.
  crie e use as classes helper (auxiliares) para transformar e formatar os dados nas views.

  

  MODULES/FILTROS/
      filtro é tipo aqueles comportamentos(behaviors) na parte de auth também.
    contentNegotiator também filtras os dados, com se recebesse response em xml ou json.

    use yii\filters\ContentNegotiator;
    use yii\web\Response;

    public function behaviors()
    {
        return [
            [
                'class' => ContentNegotiator::className(),
                'formats' => [
                    'application/json' => Response::FORMAT_JSON,
                    'application/xml' => Response::FORMAT_XML,
                ],
                'languages' => [
                    'en-US',
                    'de',
                ],
            ],
        ];
    }

    PageCache, temos cache de página tbm, e fica dentro dos behaviors
    RateLimiter/VerbFilter

    Cors(cross origin resource sharing) acesso vindo de outros sites,
    podemos restringir acesso somente a um dominio, no caso o nosso tbm.


    WIDGETS 
      temos vários widgets, tipo uns plugins ou mini components, para usar na view
      datepicker, os forms.

    exemplo:
   
    namespace app\components;

    use yii\base\Widget;
    use yii\helpers\Html;

    class HelloWidget extends Widget
    {
        public $message;

        public function init()
        {
            parent::init();
            if ($this->message === null) {
                $this->message = 'Hello World';
            }
        }

        public function run()
        {
            return Html::encode($this->message);
        }
    }
    Para usar este widget, simplesmente insira o código a seguir em uma view (visão):

    <?php
    use app\components\HelloWidget;
      ?>
    <?= HelloWidget::widget(['message' => 'Good morning']) ?>

    Aqui temos o exemplo com buffer
    namespace app\components;

    use yii\base\Widget;
    use yii\helpers\Html;

    class HelloWidget extends Widget
    {
        public function init()
        {
            parent::init();
            ob_start();
        }

        public function run()
        {
            $content = ob_get_clean();
            return Html::encode($content);
        }
    }

    Como você pode ver, o buffer de saída do PHP é iniciado no método init() 
    para que qualquer conteúdo entre as chamadas de init() e run() possam ser 
    capturadas, processadas e retornadas em run().

    widgets é mais pra reuso de código na view, deve seguir o padrão MVC
    são autossuficientes e podem ser removidos da view sem fazer qualquer outra coisa.


  ASSETS
  Um asset no Yii é um arquivo que pode ser referenciado em uma página Web.
  parecido com do laravel, assets que podemos pegar nossos scripts de css ou js

  asset bundle, é uma coleção de assets, localizados em um diretório;
  exemplo:

  <?php

  namespace app\assets;

  use yii\web\AssetBundle;

  class AppAsset extends AssetBundle
  {
      public $basePath = '@webroot';
      public $baseUrl = '@web';
      public $css = [
          'css/site.css',
      ];
      public $js = [
      ];
      public $depends = [
          'yii\web\YiiAsset',
          'yii\bootstrap\BootstrapAsset',
      ];
  }

  então temos todas aquelas coisas, de asset js/css. e outras coisas.
  -sourcePath
  -basePath
  -baseUrl-js-css-depends-jsOptions
  -cssOptions
  -publishOptions

  Observação: Não use o @webroot/assets como o caminho da fonte. 
  Este diretório é usado por padrão pelo gerenciador de asset para 
  salvar os arquivos de asset publicados a partir de seu local de origem. 
  Qualquer conteúdo deste diretório será considerado como temporário e podem 
  estar sujeitos a serem deletados.

  <?php
  namespace app\assets;

  use yii\web\AssetBundle;

  class FontAwesomeAsset extends AssetBundle 
  {
      public $sourcePath = '@bower/font-awesome'; 
      public $css = [ 
          'css/font-awesome.min.css', 
      ]; 
      
      public function init()
      {
          parent::init();
          $this->publishOptions['beforeCopy'] = function ($from, $to) {
              $dirname = basename(dirname($from));
              return $dirname === 'fonts' || $dirname === 'css';
          };
      }
  }  
  O exemplo anterior define um asset bundle para o pacode de "fontawesome". 
  Ao especificar a opção de publicação beforeCopy, apenas os subdiretórios 
  fonts e css serão publicados.

  Assets do BOWER E NPM, pacotes js são gerenciados pelo Bower e NPM.

  temos o Cache Busting, que deixa os assets em cache, porém é preciso configurar
  também um timestamp para ele poder procurar o asset mais recente, caso adicione mais
  coisa depois no ambiente de produção

    return [
      // ...
      'components' => [
          'assetManager' => [
              'appendTimestamp' => true,
          ],
      ],
  ];

  dai temos até conversões de assets, mais configs etc. que podemso utilizar
  less/scss/stylus/coffeescript/typescript

  podemos e devemos combinar/comprimir nossos assets, para evitar muitas requisições http

  Localize todos os asset bundles em sua aplicação que você deseja combinar e comprimir.

  Divida estes bundles em um ou alguns grupos. Observe que cada bundle pode apenas 
  pertencer a um único grupo.

  Combinar/Comprimir os arquivos CSS de cada grupo em um único arquivo. 

  Faça isto de forma semelhante para os arquivos JavaScript.

  Defina um novo asset bundle para cada grupo:
  Defina as propriedade css e js com os arquivos CSS e JavaScript combinados, 
  respectivamente.

  Personalize os asset bundles de cada grupo definindo as suas propriedades 
  css e js como vazias e definindo a sua propriedade depends para ser o 
  novo asset bundle criado para o grupo.

  podemos fazer isto com as ferramentas, (CLOSURE COMPILER, YUI COMPRESSOR)

  da pra agrupar assset bundles também, como allshared/allfrontend/allbackend

  EXTENSÕES 
    tipo nossas dependencies, nos arquivos json, que pegamos com composer mesmo.
    composer.json q temos todo objeto com varios negocios, dependencias, até TAGS
    {
        // nome do pacote
        "name": "yiisoft/yii2-imagine",

        // tipo de pacote
        "type": "yii2-extension",

        "description": "The Imagine integration for the Yii framework",
        "keywords": ["yii2", "imagine", "image", "helper"],
        "license": "BSD-3-Clause",
        "support": {
            "issues": "https://github.com/yiisoft/yii2/issues?labels=ext%3Aimagine",
            "forum": "http://www.yiiframework.com/forum/",
            "wiki": "http://www.yiiframework.com/wiki/",
            "irc": "irc://irc.freenode.net/yii",
            "source": "https://github.com/yiisoft/yii2"
        },
        "authors": [
            {
                "name": "Antonio Ramirez",
                "email": "amigo.cobos@gmail.com"
            }
        ],

        // dependências do pacote
        "require": {
            "yiisoft/yii2": "~2.0.0",
            "imagine/imagine": "v0.5.0"
        },

        // especifica as classes autoloading 
        "autoload": {
            "psr-4": {
                "yii\\imagine\\": ""
            }
        }
    }


    namespace deve ser nomeado seguindo o padrão psr-4 ou psr-0
    não pode utilizar 'yii,yii2,yiisoft' como nome do vendor, pq são palavras 
    reservadas do codigo nativo do yii.
    

    existem extensoes nativas também, que estão no packagist.
    https://www.yiiframework.com/doc/guide/2.0/pt-br/structure-extensions
    
    apidoc - gerar api de doc do framework
    authclient - auth de clientes, contas etc
    bootstrap - widgets que encapsulam os components e plugins
    codeception - suporte a testes
    debug - debug o yii
    elasticsearch - consultas/pesquisas básicas, implementa tbm o active record.
    faker - dados falsos para gerar pra testar ou sei lá
    gii - gerador de código, que já vimos
    httpclient - httpclient v;
    imagine - funcoes de manipulação de imagens
    jui - conjunto de widgets
    mongodb - suporte pra uso do db mongodb
    redis - suporte para uso do redis, consulta basica, activerecord,cache..
    smarty - motor de template-
    sphinx - suporte pra uso do sphinx, mesma coisa de cima praticamente
    swiftmailer - fornece recursos para envio de emails
    twig- motor de template tbm.


  ==========================================
    # TRATANDO REQUISIÇÕES  

    visão geral de como funciona em imagem.
    depois falamos da inicialização - bootstrapping
    roteamento e criação de url, que é feita pelo UrlManager
    que já vimos também sobre o prettyUrl

      use yii\helpers\Url;

      // Url::to() chama UrlManager::createUrl() para criar uma URL
      $url = Url::to(['post/view', 'id' => 100]);
    
    que geralmente fica assim
      /index.php?r=post/view&id=100
      /index.php/post/100
      /posts/100

  rotemando vai criando 'automaticamente' com base no controller view etc
  precisamos nomear as pastas corretamentas e feita pelas actions.

  temos rotaPadrão
    [
      // ...
      'defaultRoute' => 'main/index',
    ];
  
  rota catchAll
    pega todas rotas, talvez para fazer manutenção
    [
      // ...
      'catchAll' => ['site/offline'],
    ];

  Para Criar URL's temos o Url::to

    use yii\helpers\Url;

  // cria uma URL para uma rota: /index.php?r=post/index
  echo Url::to(['post/index']);

  // cria uma URL para uma rota com parâmetros: /index.php?r=post/view&id=100
  echo Url::to(['post/view', 'id' => 100]);

  // cria uma URL ancorada: /index.php?r=post/view&id=100#content
  echo Url::to(['post/view', 'id' => 100, '#' => 'content']);

  // cria uma URL absoluta: http://www.example.com/index.php?r=post/index
  echo Url::to(['post/index'], true);

  // cria uma URL absoluta usando https: https://www.example.com/index.php?r=post/index
  echo Url::to(['post/index'], 'https');


  podemos setar alias também para url não relacionadas.

  use yii\helpers\Url;

    // rota atual requerida: /index.php?r=admin/post/index
    echo Url::to();

    // uma alias da URL: http://example.com
    Yii::setAlias('@example', 'http://example.com/');
    echo Url::to('@example');

    // uma URL absoluta: http://example.com/images/logo.gif
    echo Url::to('/images/logo.gif', true);


  além to url::to() temos outras aqui.

    use yii\helpers\Url;

    // URL da página inicial: /index.php?r=site/index
    echo Url::home();

    // URL base, útil se a aplicação for implementada em uma subpasta da pasta raiz do servidor Web
    echo Url::base();

    // A URL canônica da requisição atual
    // Veja mais detalhes em https://en.wikipedia.org/wiki/Canonical_link_element
    echo Url::canonical();

    // Obtêm a URL da requisição anterior para reutilizá-la em requisições futuras
    Url::remember();
    echo Url::previous();

  
    para usar as PRETTY URL

      [
          'components' => [
              'urlManager' => [
                  'enablePrettyUrl' => true,
                  'showScriptName' => false,
                  'enableStrictParsing' => false,
                  'rules' => [
                      // ...
                  ],
              ],
          ],
      ]

  então temos mais coisas aqui sobre as regras da url e param nomeados
  https://www.yiiframework.com/doc/guide/2.0/pt-br/runtime-routing

  temos o sufixo na url.

      [
        'components' => [
            'urlManager' => [
                'enablePrettyUrl' => true,
                'showScriptName' => false,
                'enableStrictParsing' => true,
                'suffix' => '.html',
                'rules' => [
                    // ...
                    [
                        'pattern' => 'posts',
                        'route' => 'post/index',
                        'suffix' => '.json',
                    ],
                ],
            ],
        ],
    ]

  
  métodos HTTP

    [
      'PUT,POST post/<id:\d+>' => 'post/create',
      'DELETE post/<id:\d+>' => 'post/delete',
      'post/<id:\d+>' => 'post/view',
    ] 

  temos como criar classes de regras, que vem da UrlRule, mas é flexível para alterar
  é uma mãozinha.
  
  caso a url use o mesmo prefixo em seus padrões e rotas, temos o groupUrlRule.
  


  REQUISIÇÕES

  temos nossos parâmetros de requisição, $_GET $_POST.

      $request = Yii::$app->request;

    $get = $request->get(); 
    // equivalente à: $get = $_GET;

    $id = $request->get('id');   
    // equivalente à: $id = isset($_GET['id']) ? $_GET['id'] : null;

    $id = $request->get('id', 1);   
    // equivalente à: $id = isset($_GET['id']) ? $_GET['id'] : 1;

    $post = $request->post(); 
    // equivalente à: $post = $_POST;

    $name = $request->post('name');   
    // equivalente à: $name = isset($_POST['name']) ? $_POST['name'] : null;

    $name = $request->post('name', '');   
    // equivalente à: $name = isset($_POST['name']) ? $_POST['name'] : '';

    temos ai algumas coisitas.

  para restful api, enviados pleo metodos put patch.
  $request = Yii::$app->request;

  // retorna todos os parâmetros 
  $params = $request->bodyParams;

  // retorna o parâmetro "id"
  $param = $request->getBodyParam('id');


  métodos de requisição
  $request = Yii::$app->request;
  if ($request->isAjax) { /* a requisição é uma requisição Ajax */ }
  if ($request->isGet)  { /* o método da requisição é GET */ }
  if ($request->isPost) { /* o método da requisição é POST */ }
  if ($request->isPut)  { /* o método da requisição é PUT */ }
  
  URLs da requisição
    temos pelo componente request, muitas formas de inspecionar a atual url da request.

    url - retorna a url sem info de protocolos e dominio 
      (/admin/index.php/product?id=100)

    absoluteUrl - url completoa, incluindo info do protocolo e dominio
      (http://example.com/admin/index.php/product?id=100)
    
    hostInfo - retorn o que são as info de protocolo e dominio
      (http://example.com)

    pathInfo - informa depois do script de etnrada e antes da interroção(query string)
      (/product)

    queryString - retorna a info depois da query string
      (id=100)

    baseUrl - retorna a info depois do dominio e antes do script de entrada
      (/admin)

    scriptUrl - retorna a info depois do dominio ate o script de entrada.
      (/admin/index.php)

    serverName - retorna o dominio da url
      (example.com)

    serverPort - retorna qual ap orta utilizada pelo servidor web
      (80)


  Header(cabeçalho) HTTP

  // $headers é um objeto de yii\web\HeaderCollection 
  $headers = Yii::$app->request->headers;

  // retorna o valor do cabeçalho Accept
  $accept = $headers->get('Accept');

  if ($headers->has('User-Agent')) { /* existe o cabeçalho User-Agent */ }

  assim como algumas outras coisas como
  -userAgent
  -contentType
  -acceptableContentTypes
  -acceptableLanguages

  Informações do Cliente ( host e IP )
  $userHost = Yii::$app->request->userHost;
  $userIP = Yii::$app->request->userIP;

  RESPOSTAS(RESPONSES) 
  https://www.yiiframework.com/doc/guide/2.0/pt-br/runtime-responses
    temos o status code
    Yii::$app->response->statusCode = 200;

  alguns verbos http mais comuns
  400 - bad request
  404 - not found
  409 - conflit HttpException
  403 - forbidden ..
  410 - gone
  405 - method not allowed
  406 - not accepttable
  500 - server error
  429 - too many request
  401 - unauthorized
  415 - unsupported media type

  sobre http headers, response HeaderCollection

  Response Body

    Yii::$app->response->content = 'hello world!';

  também podemos formatar como vai vir a 'data'

    $response = Yii::$app->response;
    $response->format = \yii\web\Response::FORMAT_JSON;
    $response->data = ['message' => 'hello world'];

  yii suporta
  -html
  -xml
  -json
  -jsonp 
  -raw

  public function actionInfo()
  {
      \Yii::$app->response->format = \yii\web\Response::FORMAT_JSON;
      return [
          'message' => 'hello world',
          'code' => 100,
      ];
  }

  temos nosso Redirect, e status code.
  
  public function actionOld()
  {
      return $this->redirect('http://example.com/new', 301);
  }

  \Yii::$app->response->redirect('http://example.com/new', 301)->send();

  para x-redirect - ajax(async)
  https://www.yiiframework.com/doc/api/2.0/yii-web-response#redirect()-detail


  Enviando Files
  public function actionDownload()
  {
      return \Yii::$app->response->sendFile('path/to/file.txt');
  }

  se chamar de outro lugar que nao for do actionMethod
    \Yii::$app->response->sendFile('path/to/file.txt')->send();

  
  Enviando Resposta, tem a estrutura de como é enviado as response.


  SESSÕES E COOKIES
  para abrir e fechar sessões.

  $session = Yii::$app->session;

  // verifica se a sessão está pronta para abrir
  if ($session->isActive) ...

  // abre uma sessão
  $session->open();

  // fecha uma sessão
  $session->close();

  // destrói todos os dados registrados em uma sessão.
  $session->destroy();

  
  para acessar dados da sessão

  $session = Yii::$app->session;

  // obter uma variável de sessão. Os exemplos abaixo são equivalentes:
  $language = $session->get('language');
  $language = $session['language'];
  $language = isset($_SESSION['language']) ? $_SESSION['language'] : null;

  // definir uma variável de sessão. Os exemplos abaixo são equivalentes:
  $session->set('language', 'en-US');
  $session['language'] = 'en-US';
  $_SESSION['language'] = 'en-US';

  // remover uma variável de sessão. Os exemplos abaixo são equivalentes:
  $session->remove('language');
  unset($session['language']);
  unset($_SESSION['language']);

  // verifica se a variável de sessão existe. Os exemplos abaixo são equivalentes:
  if ($session->has('language')) ...
  if (isset($session['language'])) ...
  if (isset($_SESSION['language'])) ...

  // percorrer todas as variáveis de sessão. Os exemplos abaixo são equivalentes:
  foreach ($session as $name => $value) ...
  foreach ($_SESSION as $name => $value) ...


  Session de arrays
  $session = Yii::$app->session;

  // o seguinte código não funciona
  $session['captcha']['number'] = 5;
  $session['captcha']['lifetime'] = 3600;

  // o seguinte código funciona:
  $session['captcha'] = [
      'number' => 5,
      'lifetime' => 3600,
  ];

  // o seguinte código também funciona:
  echo $session['captcha']['lifetime'];



  temos soluções diferente pelo yii
  $session = Yii::$app->session;

  // use diretamente $_SESSION (certifique-se que Yii::$app->session->open() tenha sido chamado)
  $_SESSION['captcha']['number'] = 5;
  $_SESSION['captcha']['lifetime'] = 3600;

  // obter todo o array primeiro, modificá-lo e depois salvá-lo
  $captcha = $session['captcha'];
  $captcha['number'] = 5;
  $captcha['lifetime'] = 3600;
  $session['captcha'] = $captcha;

  // use ArrayObject em vez de array
  $session['captcha'] = new \ArrayObject;
  ...
  $session['captcha']['number'] = 5;
  $session['captcha']['lifetime'] = 3600;

  // armazenar dados de array utilizando chaves com um prefixo comum
  $session['captcha.number'] = 5;
  $session['captcha.lifetime'] = 3600;


  podemos salvar em session personalizadas, porem requer mais configurações
  como armazenar direto em cache ou db, porém é preciso criar database e outras
  configurações.

  Dados Flash
  -dado especial de sessao, só estão disponivies na proxima requisição e serão 
    automaticamente excluido depois. geralmente implementado para mensagens

    $session = Yii::$app->session;

    // Request #1
    // defini uma mensagem flash chamada "postDeleted"
    $session->setFlash('postDeleted', 'You have successfully deleted your post.');

    // Request #2
    // exibe uma mensagem flash chamada "postDeleted"
    echo $session->getFlash('postDeleted');

    // Request #3
    // $result será falso uma vez que a mensagem flash foi automaticamente excluída
    $result = $session->hasFlash('postDeleted');


    podemos utilizar isto juntamente com o ALERT widget
    echo Alert::widget([
      'options' => ['class' => 'alert-info'],
      'body' => Yii::$app->session->getFlash('postDeleted'),
    ]);

    Temos os COOKIES.
      // pega a coleção de cookie  (yii\web\CookieCollection) do componente "request"
    $cookies = Yii::$app->request->cookies;

    // pega o valor do cookie "language". se o cookie não existir, retorna "en" como o valor padrão.
    $language = $cookies->getValue('language', 'en');

    // um caminho alternativo para pegar o valor do cookie "language"
    if (($cookie = $cookies->get('language')) !== null) {
        $language = $cookie->value;
    }

    // você também pode usar $cookies como um array
    if (isset($cookies['language'])) {
        $language = $cookies['language']->value;
    }

    // verifica se existe um cookie "language"
    if ($cookies->has('language')) ...
    if (isset($cookies['language'])) ...


    Enviando Cookies para o usuário final
    // pega a coleção de cookie (yii\web\CookieCollection) do componente "response"
    $cookies = Yii::$app->response->cookies;

    // adicionar um novo cookie a resposta que será enviado
    $cookies->add(new \yii\web\Cookie([
        'name' => 'language',
        'value' => 'zh-CN',
    ]));

    // remove um cookie
    $cookies->remove('language');
    // outra alternativa para remover um cookie
    unset($cookies['language']);

    temos também a validação de cookie
    tudo que vier pelo setcookie ou $_COOKIE nao serão validados.

    return [
        'components' => [
            'request' => [
                'cookieValidationKey' => 'fill in a secret key here',
            ],
        ],
    ];


  TRATAMENTO DE ERROS
  YII_ENABLE_ERROR_HANDLER é true, no script de entrada.
      return [
      'components' => [
          'errorHandler' => [
              'maxSourceLines' => 20,
          ],
      ],
    ];

    retorna isto ai de cima e podemos fazer com try catch esse tratament de errors
      use Yii;
      use yii\base\ErrorException;

      try {
        10/0;
      } catch (ErrorException $e) {
        Yii::warning("Division by zero.");
      }


  podemos dar throw error caso usuario faça uma requisição invalida ou inesperada.
  o manipulador de erro dira o status code corretamente.

  use yii\web\NotFoundHttpException;

  throw new NotFoundHttpException();

  o YII_DEBUG em dev fica true, em producao setams pra false. que vai personalizar 
  a exibição de erro corretamente. utiliza a view;
  @yii/views/errorHandler/error.php
  @yii/views/errorHandler/exception.php

  depois na url temos como tratar errors usando action configurando etc.
  https://www.yiiframework.com/doc/guide/2.0/pt-br/runtime-handling-errors


  GERENCIAMENTO DE LOGS

    yii fornece logs personalizaveis.
    -registrar mensagens de log 
    -configurar o destino do log 
    -examinar as msg de erro exportadas

    POdemos gravar mensagens com
    Yii::debug() - grava msg para reastrear como um determinado trecho de codfont
    Yii::info() - grava msg q transmit algumas informações uteis
    Yii::warning() - grava msg de aviso que indica algo inesperado aconteceu
    Yii::error() - grava fatalerror

    Destinos de log
    - é uma instancia de classe, filtra niveis e categoria e exporta pra algum meio.
    ex:banco de dados etc.
    --é preciso configurar component da aplicação dai.
          return [
        // o componente  "log" deve ser carregado durante o tempo de inicialização
        'bootstrap' => ['log'],
        
        'components' => [
            'log' => [
                'targets' => [
                    [
                        'class' => 'yii\log\DbTarget',
                        'levels' => ['error', 'warning'],
                    ],
                    [
                        'class' => 'yii\log\EmailTarget',
                        'levels' => ['error'],
                        'categories' => ['yii\db\*'],
                        'message' => [
                          'from' => ['log@example.com'],
                          'to' => ['admin@example.com', 'developer@example.com'],
                          'subject' => 'Database errors at example.com',
                        ],
                    ],
                ],
            ],
        ],
      ];

      este componente de log deve ser carregado durante a inicialização, por isto
      ele fica no boostrap.

      os logs podem ser dispachados pra varios lugares.
      -é preciso consultar a API, por exemplo
      --envia pra um banco de dados, ou email, ou em arquivos, ou em syslog do php.

      Filtragem de mensagem
      -error
      -warning
      -info
      -trace
      -profile

      podemos formatar mensagem, por padrão É
      Timestamp [IP address][User ID][Session ID][Severity Level][Category] Message Text

      e temos mais outras coisas complexas com log, como nivel de rastreio
      libertação e exportação de mensagens, alternar destino de log, criar novos Destinos
      perfil de desempenho

    
  ==========================================
    # CONCEITOS CHAVES 
      
      Componentes
      -propriedades
      -eventos
      -behaviors(comportamento)

      ja vimos lá no getting started
      <?php

        namespace yii\components\MyClass;

        use yii\base\BaseObject;

        class MyClass extends BaseObject
        {
          public $prop1;
          public $prop2;

          public function __construct($param1, $param2, $config = [])
          {
              // ... initialization before configuration is applied

              parent::__construct($config);
          }

          public function init()
          {
              parent::init();

              // ... initialization after configuration is applied
          }
        }

      configurando o component
      $component = new MyClass(1, 2, ['prop1' => 3, 'prop2' => 4]);
      // alternatively
      $component = \Yii::createObject([
        'class' => MyClass::className(),
        'prop1' => 3,
        'prop2' => 4,
      ], [1, 2]);


    PROPRIEDADES 

    temos os métodos getter and setter  
    namespace app\components;

      use yii\base\BaseObject;

      class Foo extends BaseObject
      {
          private $_label;

          public function getLabel()
          {
              return $this->_label;
          }

          public function setLabel($value)
          {
              $this->_label = trim($value);
          }
      }


    tem até uns atalhos.

    // equivalent to $label = $object->getLabel();
    $label = $object->label;

    // equivalent to $object->setLabel('abc');
    $object->label = 'abc';

  tem uma parada com trim() que fazendo aqueles bang ali não precisa chamar na maioria
  das calls.

  
  EVENTOS
  -permitem que você injete código personalizado dentro de outro código existente em 
  determinado pontos de execução

  function ($event) {
   // $event is an object of yii\base\Event or a child class
  }

  $event tem:
  -nome do evento
  -objeto chamador
  -dados personalizados

  adicionando manipuladores de evento
  $foo = new Foo;

  // esse manipulador é uma função global
  $foo->on(Foo::EVENT_HELLO, 'function_name');

  // esse manipulador é um método de objeto
  $foo->on(Foo::EVENT_HELLO, [$object, 'methodName']);

  // esse manipulador é um método estático da classe
  $foo->on(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

  // esse manipulador é uma função anônima
  $foo->on(Foo::EVENT_HELLO, function ($event) {
    // Código ...
  });


  --------------------------------------------
  // O código a seguir mostrará "abc" quando o evento for disparado
  // porque $event->data contêm os dados passados no terceiro parâmetro do "on"
  $foo->on(Foo::EVENT_HELLO, 'function_name', 'abc');

  function function_name($event) {
    echo $event->data;
  }


  Disparando eventos:
  namespace app\components;

  use yii\base\Component;
  use yii\base\Event;

  class Foo extends Component
  {
    const EVENT_HELLO = 'hello';

    public function bar()
    {
        $this->trigger(self::EVENT_HELLO);
    }
  }
  Com o código acima, todas as chamadas para bar () irão disparar um evento 
  chamado hello.


  outro exemplo com evento..
  namespace app\components;

  use yii\base\Component;
  use yii\base\Event;

  class MessageEvent extends Event
  {
    public $message;
  }

  class Mailer extends Component
  {
    const EVENT_MESSAGE_SENT = 'messageSent';

    public function send($message)
    {
        // ...sending $message...

        $event = new MessageEvent;
        $event->message = $message;
        $this->trigger(self::EVENT_MESSAGE_SENT, $event);
    }
  }

  trigger(), chama todos os manipuladores ligados ao evento passado.


  para desvincular manipuladores de eventos.

    // o manipulador é uma função global
  $foo->off(Foo::EVENT_HELLO, 'function_name');

  // o manipulador é um método de objeto
  $foo->off(Foo::EVENT_HELLO, [$object, 'methodName']);

  // o manipulador é um método de estático da Classe
  $foo->off(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

  // o manipulador é uma função anônima
  $foo->off(Foo::EVENT_HELLO, $anonymousFunction);


  ou desvincula todos manipuladores do evento mesmo.
  $foo->off(Foo::EVENT_HELLO);

  
  
  --podemos chamar eventos a níveis de classe também.
  use yii\base\Event;

  Event::on(Foo::className(), Foo::EVENT_HELLO, function ($event) {
    var_dump($event->sender);  // displays "null"
  });

  Event::trigger(Foo::className(), Foo::EVENT_HELLO);

  --para desvincular o evento.
  // desvincula $handler
  Event::off(Foo::className(), Foo::EVENT_HELLO, $handler);

  // Desvincula todos os manipuladores de Foo::EVENT_HELLO
  Event::off(Foo::className(), Foo::EVENT_HELLO);


  Eventos Globais existem, podemos chamar para todo APP
  use Yii;
  use yii\base\Event;
  use app\components\Foo;

  Yii::$app->on('bar', function ($event) {
    echo get_class($event->sender);  // Mostra na tela "app\components\Foo"
  });

  Yii::$app->trigger('bar', new Event(['sender' => new Foo]));



  BEHAVIORS 


  namespace app\components;

  use yii\base\Behavior;

  class MyBehavior extends Behavior
  {
    public $prop1;

    private $_prop2;

    public function getProp2()
    {
        return $this->_prop2;
    }

    public function setProp2($value)
    {
        $this->_prop2 = $value;
    }

    public function foo()
    {
        // ...
    }
  }


  temos propriedades como variáveis, e comportamento diferentes
  parecido com getter/setter


  aqui um exemplo de como colocar behavior no codigo
  public function behaviors()
   {
       return [
           // behavior anônimo, somente o nome da classe
           MyBehavior::className(),

           // behavior nomeado, somente o nome da classe
           'myBehavior2' => MyBehavior::className(),

           // behavior anônimo, array de configuração
           [
               'class' => MyBehavior::className(),
               'prop1' => 'value1',
               'prop2' => 'value2',
           ],

           // behavior nomeado, array de configuração
           'myBehavior4' => [
               'class' => MyBehavior::className(),
               'prop1' => 'value1',
               'prop2' => 'value2',
           ]
       ];

    
    podemos também colocar vários behaviors, com attach.
    $component->attachBehaviors([
    'myBehavior1' => new MyBehavior,  // um behavior nomeado
      MyBehavior::className(),          // um behavior anônimo 
    ]);



    então podemos utilizar behavior parecido com components, behavior vai ta nas propriedades
    do component e chamamos ele

      // "prop1" é uma propriedade definida na classe behavior 
    echo $component->prop1;
    $component->prop1 = $value;

    podemos desvincular behaviors. single ou all
    temos o timestampBehavior, praticamente timestamp.

    Behavior vs Traits
    behavior se comporta como classe, são comfiguráveis
    traits são mais eficiente q behavior, porém requerem mais tempo e memoria.



    CONFIGURAÇÕES   

      aqui temos varias configurações, por exemplo do banco de dados, dsn etc.
      e temos muitos outros tipos de config. no caso do template basic.


    temos a configuração de widget
    use yii\widgets\Menu;

    echo Menu::widget([
        'activateItems' => false,
        'items' => [
            ['label' => 'Home', 'url' => ['site/index']],
            ['label' => 'Products', 'url' => ['product/index']],
            ['label' => 'Login', 'url' => ['site/login'], 'visible' => Yii::$app->user->isGuest],
        ],
    ]);

    que no caso podemos colocar na view.

    os arquivos de configuração estão em web.php
    assim como as constantes de ambiente.


    ALIASES (apelidos)
    --apelidos dos caminhos geralmente

      // um alias de um caminho de arquivo
    Yii::setAlias('@foo', '/caminho/para/foo');

    // um alias de uma URL
    Yii::setAlias('@bar', 'http://www.exemplo.com.br');


  Você pode definir um alias usando outro alias (tanto raiz quanto derivado):

  Yii::setAlias('@foobar', '@foo/bar');
  -------------------

  também podemos recuperar com get
    Yii::getAlias('@foo/test/arquivo.php');  // exibe: /caminho/para/foo/test/arquivo.php
    Yii::getAlias('@foo/bar/arquivo.php');   // exibe: /caminho2/bar/arquivo.php

  existem alias já predefinidos
  -@yii
  -@app
  -@runtime
  -@webroot
  -@web
  -@vendor
  -@bower
  -@npm 


  um alias e automaticamente criado quando instalamos uma extensão.
  exemplo de como fica..

  Yii::setAlias('@yii/jui', 'VendorPath/yiisoft/yii2-jui');




  AUTOLOADING DE CLASSES  
  -ele é feito no arquivo yii.php, automaticamente;
  utiliza o autoloader do composer.


  SERVICE LOCATOR
  -Um service locator é um objeto que sabe como fornecer todos os tipos de serviços 
  (ou componentes) que uma aplicação pode precisar.

  aqui mais ou menos como funciona na classe, e depois chamando a classe.
  class SolrServiceBuilder
  {
      public static function build($ip)
      {
          return function () use ($ip) {
              $solr = new app\components\SolrService($ip);
              // ... outras inicializações ...
              return $solr;
          };
      }
  }

  return [
      // ...
      'components' => [
          // ...
          'search' => SolrServiceBuilder::build('127.0.0.1'),
      ],
  ];


  CONTAINER DE INJEÇÃO DE DEPENDÊNCIA 
  - é um objeto que sabe como instanciar e configurar objetos 
    e todas as suas dependências

   yii\di\Container
   -injeção de construtor
   -injeção de setter e propriedade
   -injeção de php callable

  mais sobre DI 
    https://www.yiiframework.com/doc/guide/2.0/pt-br/concept-di-container

  
  ==========================================
    # TRABALHANDO COM BANCO DE DADOS 

  no yii temos alguns db que já podemos fazer conexão mais facilmente
  -mysql
  -mariadb
  -sqlite
  -postgree
  -cubrid
  -oracle
  -mssql

  temos todas configs para cada um.

  podemos criar nossas query's mas nao diz aonde.
  // return a set of rows. each row is an associative array of column names and values.
  // an empty array is returned if the query returned no results
  $posts = Yii::$app->db->createCommand('SELECT * FROM post')
              ->queryAll();

  // return a single row (the first row)
  // false is returned if the query has no result
  $post = Yii::$app->db->createCommand('SELECT * FROM post WHERE id=1')
            ->queryOne();

  // return a single column (the first column)
  // an empty array is returned if the query returned no results
  $titles = Yii::$app->db->createCommand('SELECT title FROM post')
              ->queryColumn();

  // return a scalar value
  // false is returned if the query has no result
  $count = Yii::$app->db->createCommand('SELECT COUNT(*) FROM post')
              ->queryScalar();


  BINDING PARAMETERS

  para uma questao melhor de segurança/validação, podemos dar bind nos values/param
  que recebem.
  $post = Yii::$app->db->createCommand('SELECT * FROM post WHERE id=:id AND status=:status')
           ->bindValue(':id', $_GET['id'])
           ->bindValue(':status', 1)
           ->queryOne();



  NON SQL Query's 
  // INSERT (table name, column values)
  Yii::$app->db->createCommand()->insert('user', [
      'name' => 'Sam',
      'age' => 30,
  ])->execute();

  // UPDATE (table name, column values, condition)
  Yii::$app->db->createCommand()->update('user', ['status' => 1], 'age > 30')->execute();

  // DELETE (table name, condition)
  Yii::$app->db->createCommand()->delete('user', 'status = 0')->execute();


  temos batch insert para adicionar algum comando.
  // table name, column names, column values
  Yii::$app->db->createCommand()->batchInsert('user', ['name', 'age'], [
      ['Tom', 30],
      ['Jane', 20],
      ['Linda', 25],
  ])->execute();


  no database schema é feito com o yii DAO, e alguns métodos.
  createTable(): creating a table
  renameTable(): renaming a table
  dropTable(): removing a table
  truncateTable(): removing all rows in a table
  addColumn(): adding a column
  renameColumn(): renaming a column
  dropColumn(): removing a column
  alterColumn(): altering a column
  addPrimaryKey(): adding a primary key
  dropPrimaryKey(): removing a primary key
  addForeignKey(): adding a foreign key
  dropForeignKey(): removing a foreign key
  createIndex(): creating an index
  dropIndex(): removing an index

  exemplo de uso:
  // CREATE TABLE
  Yii::$app->db->createCommand()->createTable('post', [
      'id' => 'pk',
      'title' => 'string',
      'text' => 'text',
  ]);



  QUERY BUILDER 

  $rows = (new \yii\db\Query())
   ->select(['id', 'email'])
   ->from('user')
   ->where(['last_name' => 'Smith'])
   ->limit(10)
   ->all();


  temos nosso select()
    $query->select(['id', 'email']);

    // equivalente a:

    $query->select('id, email')

    em subquery's temos.
    $subQuery = (new Query())->select('COUNT(*)')->from('user');

    // SELECT `id`, (SELECT COUNT(*) FROM `user`) AS `count` FROM `post`
    $query = (new Query())->select(['id', 'count' => $subQuery])->from('post');


    from()
      // SELECT * FROM `user`
      $query->from('user');

    where()
      $query->where('status=1');

      // ou usar parâmetro para vincular os valores dinamicamente 
      $query->where('status=:status', [':status' => $status]);

    ----------
    // Perigoso! NÃO faça isto a menos que você esteja muito certo que o $status deve ser um número inteiro.
    $query->where("status=$status");

    Ao usar parâmetro, você pode chamar params() ou addParams() para especificar os parâmetros separadamente.

    $query->where('status=:status')
      ->addParams([':status' => $status]);


  Formato Hash
    Formato HASH é mais usado para especificar múltiplos AND - sub-condições 
    concatenadas, sendo cada uma afirmação simples de igualdade. 
    É escrito como um array cujas chaves são nomes de coluna e os valores 
    correspondem ao conteúdo destas colunas. Por exemplo:

    // ...WHERE (`status` = 10) AND (`type` IS NULL) AND (`id` IN (4, 8, 15))
    $query->where([
      'status' => 10,
      'type' => null,
      'id' => [4, 8, 15],
    ]);


  Filtrar Condições
  -Ao construir condições WHERE a partir de entradas de usuários finais, 
    você geralmente deseja ignorar os valores vazios. 

  // $username and $email são inputs dos usuário finais 
  $query->filterWhere([
    'username' => $username,
    'email' => $email,
  ]);


  orderBy()
  groupBy()
  having()
  limit() e offset()
  join()
  union()

  MÉTODOS QUERY
  all() - array de linhas, pares nome-valor
  one() - retorna primeira linha do resultado
  column() - primeira coluna do resultado
  scalar() - retorna valor a escalar localizado na 1ºlinha e coluna do 1ºresultado.
  exists() - retorna valor indica se a consulta contém qualquer resultado
  count() - retorna a quantidade de resultados da query.


  podemos mostrar o commando pra ver o que está sendo a query.
  $command = (new \yii\db\Query())
   ->select(['id', 'email'])
   ->from('user')
   ->where(['last_name' => 'Smith'])
   ->limit(10)
   ->createCommand();
   
  // mostra a instrução SQL 
  echo $command->sql;

  // Mostra os parâmetros que serão ligados
  print_r($command->params);

  // retorna todas as linhas do resultado da query
  $rows = $command->queryAll();



  temos o indexBy(), temos sintax com anonymousFunction

  // retorna [100 => ['id' => 100, 'username' => '...', ...], 101 => [...], 103 => [...], ...]
  $query = (new \yii\db\Query())
    ->from('user')
    ->limit(10)
    ->indexBy('id')
    ->all();


  BATCH QUERY, com foreach.
  use yii\db\Query;

  $query = (new Query())
    ->from('user')
    ->orderBy('id');

  foreach ($query->batch() as $users) {
    // $users é um array de 100 ou menos linha da tabela user
  }

  // ou se você quiser fazer uma iteração da linha uma por uma
  foreach ($query->each() as $user) {
    // $user representa uma linha de dados a partir da tabela user
  }



  !!ACTIVE RECORD!!
  como se fosse query também. construtor de consulta.
  só que é feito por classe.

  $customer = new Customer();
  $customer->name = 'Qiang';
  $customer->save();

  tem support para os mesmos bancos citados acima.

  -------------------
  namespace app\models;

  use yii\db\ActiveRecord;

  class Customer extends ActiveRecord
  {
    const STATUS_INACTIVE = 0;
    const STATUS_ACTIVE = 1;
    
    /**
      * @return string the name of the table associated with this ActiveRecord class.
      */
    public static function tableName()
    {
        return 'customer';
    }
  }
  -----------------------

  a consulta de dados é parecida com a do query builder, mas temos que utilizar
  a classe da active record.

  // retorna um único customer cujo ID é 123
  // SELECT * FROM `customer` WHERE `id` = 123
  $customer = Customer::find()
    ->where(['id' => 123])
    ->one();

  // retorna todos customers ativos e os ordena por seus IDs
  // SELECT * FROM `customer` WHERE `status` = 1 ORDER BY `id`
  $customers = Customer::find()
    ->where(['status' => Customer::STATUS_ACTIVE])
    ->orderBy('id')
    ->all();

  // retorna a quantidade de customers ativos
  // SELECT COUNT(*) FROM `customer` WHERE `status` = 1
  $count = Customer::find()
    ->where(['status' => Customer::STATUS_ACTIVE])
    ->count();

  // retorna todos customers em um array indexado pelos seus IDs
  // SELECT * FROM `customer`
  $customers = Customer::find()
    ->indexBy('id')
    ->all();


  -------------------------------
  -findOne()
  -findAll()


  // retorna um único customer cujo ID é 123
  // SELECT * FROM `customer` WHERE `id` = 123
  $customer = Customer::findOne(123);

  // retorna customers cujo ID é 100, 101, 123 or 124
  // SELECT * FROM `customer` WHERE `id` IN (100, 101, 123, 124)
  $customers = Customer::findAll([100, 101, 123, 124]);

  // retorna um customer ativo cujo ID é 123
  // SELECT * FROM `customer` WHERE `id` = 123 AND `status` = 1
  $customer = Customer::findOne([
    'id' => 123,
    'status' => Customer::STATUS_ACTIVE,
  ]);

  // retorna todos os customers inativos
  // SELECT * FROM `customer` WHERE `status` = 0
  $customers = Customer::findAll([
    'status' => Customer::STATUS_INACTIVE,
  ]);

----------------------------------------

  TRANSFORMANDO DADOS
    já que é uma classe podemos já retornar os dados limpos para usar na view
    por exemplo a data que vem com formato americano.

      class Customer extends ActiveRecord
    {
      // ...

      public function getBirthdayText()
      {
          return date('Y/m/d', $this->birthday);
      }
      
      public function setBirthdayText($value)
      {
          $this->birthday = strtotime($value);
      }
    }


  podemos retornar em array, (json nao sei se pode direto, mas pra converter depois
    para objeto)

    // retorna todos os `customers`
    // cada `customer` retornado é associado a um array
    $customers = Customer::find()
      ->asArray()
      ->all();


  para SALVAR DADOS quase a mesma coisa.

  // insere uma nova linha de dados
  $customer = new Customer();
  $customer->name = 'James';
  $customer->email = 'james@example.com';
  $customer->save();

  // atualiza uma linha de dados existente
  $customer = Customer::findOne(123);
  $customer->email = 'james@newexample.com';
  $customer->save();



  UPDATE Counter

  $post = Post::findOne(100);
  // UPDATE `post` SET `view_count` = `view_count` + 1 WHERE `id` = 100
  $post->updateCounters(['view_count' => 1]);


  DEFAULT VALUES, wat
  $customer = new Customer();
  $customer->loadDefaultValues();
  // $customer->xyz will be assigned the default value declared when defining the "xyz" column
 

  em formato json chama assim
  $query->andWhere(['=', 'json', new ArrayExpression(['foo' => 'bar'])


  UPDATING Multiple rows
  // UPDATE `customer` SET `status` = 1 WHERE `email` LIKE `%@example.com%`
  Customer::updateAll(['status' => Customer::STATUS_ACTIVE], ['like', 'email', '@example.com']);


  DELETE
  $customer = Customer::findOne(123);
  $customer->delete();

  DELETE ALL 
  Customer::deleteAll(['status' => Customer::STATUS_INACTIVE]);

  -----------------------------------

  TRABALHANDO COM TRANSACTION
  -praticamente uma function(transaction) são várias query's juntas
  utilizada no active record.

  podemos fazer com uma anonymousFunction ou começar com static class e fazer
  um try catch

  $customer = Customer::findOne(123);

  Customer::getDb()->transaction(function($db) use ($customer) {
      $customer->id = 200;
      $customer->save();
      // ...other DB operations...
  });

  // or alternatively

  $transaction = Customer::getDb()->beginTransaction();
  try {
      $customer->id = 200;
      $customer->save();
      // ...other DB operations...
      $transaction->commit();
  } catch(\Exception $e) {
      $transaction->rollBack();
      throw $e;
  } catch(\Throwable $e) {
      $transaction->rollBack();
      throw $e;
  }

  ----------------------------------------------

  tem outras coisas com o "OptimisticLock"
  meio que salva em um hidden form, quando for salvar e verifica,
  se tem duas ações editando a mesma coisa no banco, para não dar 
  staleobject error.


  --------------------------------------------------------

  Podemos trabalhar com "Relações" no DB

  class Customer extends ActiveRecord
  {
      // ...

      public function getOrders()
      {
          return $this->hasMany(Order::className(), ['customer_id' => 'id']);
      }
  }

  class Order extends ActiveRecord
  {
      // ...

      public function getCustomer()
      {
          return $this->hasOne(Customer::className(), ['id' => 'customer_id']);
      }
  }


  -hasMany()
  -hasOne()


  e aquui temos como pegar pelo active record, e retornar arrays
  praticamente activerecord é a classe, então tem os métodos getters setters
  $customer->orders; // is an array of `Order` objects
  $customer->getOrders(); // returns an ActiveQuery instance

  -------------------------------------------

  Dynamic Relational Query.... especifico, talvez n seja mt bom para algumas coisas
  a não ser em alguma função especifica mesmo.
  $customer = Customer::findOne(123);

  // SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal` > 200 ORDER BY `id`
  $orders = $customer->getOrders()
      ->where(['>', 'subtotal', 200])
      ->orderBy('id')
      ->all();

  
  -------------------------------------------


  temos também
  Relações via Junction table 
  Chaining relation,

  -------------------------------

  temos o uso do with(). exemplo:

  Query sem o with():
  faz 100 sql statement,1 por 1

    // SELECT * FROM `customer` LIMIT 100
  $customers = Customer::find()->limit(100)->all();

  foreach ($customers as $customer) {
      // SELECT * FROM `order` WHERE `customer_id` = ...
      $orders = $customer->orders;
  }

  Com with() junta tudo em uma query e reduz o processamento.
  // SELECT * FROM `customer` LIMIT 100;
  // SELECT * FROM `orders` WHERE `customer_id` IN (...)
  $customers = Customer::find()
      ->with('orders')
      ->limit(100)
      ->all();

  foreach ($customers as $customer) {
      // no SQL executed
      $orders = $customer->orders;
  }

  ------------------------------------------
  mais exemplos:

    // eager loading both "orders" and "country"
  $customers = Customer::find()->with('orders', 'country')->all();
  // equivalent to the array syntax below
  $customers = Customer::find()->with(['orders', 'country'])->all();
  // no SQL executed 
  $orders= $customers[0]->orders;
  // no SQL executed 
  $country = $customers[0]->country;

  // eager loading "orders" and the nested relation "orders.items"
  $customers = Customer::find()->with('orders.items')->all();
  // access the items of the first order of the first customer
  // no SQL executed
  $items = $customers[0]->orders[0]->items;


  -----------------------------------------------
  Aqui um exemplo completo com a sintax e query original do db.

  // SELECT `customer`.* FROM `customer`
  // LEFT JOIN `order` ON `order`.`customer_id` = `customer`.`id`
  // WHERE `order`.`status` = 1
  // 
  // SELECT * FROM `order` WHERE `customer_id` IN (...)
  $customers = Customer::find()
      ->select('customer.*')
      ->leftJoin('order', '`order`.`customer_id` = `customer`.`id`')
      ->where(['order.status' => Order::STATUS_ACTIVE])
      ->with('orders')
      ->all();

  

  -----------------------------------------------
  temos ALIASES para db também. porém fácil de se perder.

    $query->joinWith([
      'orders' => function ($q) {
          $q->from(['o' => Order::tableName()]);
      },
  ])

  -----------------------------------------------


  INVERSE RELATION, temos outra function.
  class Customer extends ActiveRecord
  {
      public function getOrders()
      {
          return $this->hasMany(Order::className(), ['customer_id' => 'id'])->inverseOf('customer');
      }
  }

  // SELECT * FROM `customer` WHERE `id` = 123
  $customer = Customer::findOne(123);

  // SELECT * FROM `order` WHERE `customer_id` = 123
  $order = $customer->orders[0];

  // No SQL will be executed
  $customer2 = $order->customer;

  // displays "same"
  echo $customer2 === $customer ? 'same' : 'not the same';


  -----------------------------------------------------


  SAVING RELATIONS, usamos o link() ao inves de save();
  ---maneira errada.
    $customer = Customer::findOne(123);
  $order = new Order();
  $order->subtotal = 100;
  // ...

  // setting the attribute that defines the "customer" relation in Order
  $order->customer_id = $customer->id;
  $order->save();

  ---maneira correta
  $customer = Customer::findOne(123);
  $order = new Order();
  $order->subtotal = 100;
  // ...

  $order->link('customer', $customer);

  ----------------------------------------------------

  tem opção de CROSS-DB RELATIONS tbm.. mais complexo..
  customizar Query's também
  Extra fields..
  -------------------------------------------------------

  
  MIGRATIONS
  -- para migrar para o db, nossas tabelas criadas por codigo.
    temos o básico de toda migration, e cria o prefix com timestamp.

    -create new migrations;
    -apply migrations;
    -revert migrations;
    -re-apply migrations;
    -show migration history and status.


  utilizamos o terminal com os comandos:
  !!caso não encontre podemos utilizar o 
    php yii migrate/create create_news_table
  !!
  
  -Criar Migration-
    yii migrate/create <name> 
      ex: (yii migrate/create create_news_table)

  Como fica a classe de migration criada.
    <?php

    use yii\db\Migration;

    class m150101_185401_create_news_table extends Migration
    {
        public function up()
        {

        }

        public function down()
        {
            echo "m101129_185401_create_news_table cannot be reverted.\n";

            return false;
        }

        /*
        // Use safeUp/safeDown to run migration code within a transaction
        public function safeUp()
        {
        }

        public function safeDown()
        {
        }
        */
    }
  

    ----------------------------------------------------------------
    Aqui temos a API com os comandos que podemos utilizar;
    https://www.yiiframework.com/doc/api/2.0/yii-db-schemabuildertrait

    -------------------

    Também pelo command line podemos especificar as linhas
      yii migrate/create create_post_table --fields="title:string,body:text"
    
    cria-se 'automaticamente' nossas tables.
    podemos passar parâmetros junto.

      yii migrate/create create_post_table --fields="title:string(12):notNull:unique,body:text"


    até as foreign key podem ser criadas pelo command line
      yii migrate/create create_post_table --fields="author_id:integer:notNull:foreignKey(user),category_id:integer:defaultValue(1):foreignKey,title:string,body:text"

    então nesse caso até poderia ser bom.


    DROP TABLE na function up()
       yii migrate/create drop_post_table --fields="title:string(12):notNull:unique,body:text"

    possível também pelo command line

        class m150811_220037_drop_post_table extends Migration
        {
            public function up()
            {
                $this->dropTable('post');
            }

            public function down()
            {
                $this->createTable('post', [
                    'id' => $this->primaryKey(),
                    'title' => $this->string(12)->notNull()->unique(),
                    'body' => $this->text()
                ]);
            }
        }


    Adicionar Colunas também..
    ADD COLUMN
      yii migrate/create add_position_column_to_post_table --fields="position:integer"

    e DROP COLUMN
      yii migrate/create drop_position_column_from_post_table --fields="position:integer"

    JUNCTION TABLE
      yii migrate/create create_junction_table_for_post_and_tag_tables --fields="created_at:dateTime"

    TRANSACTION MIGRATIONS

      <?php
      use yii\db\Migration;

      class m150101_185401_create_news_table extends Migration
      {
          public function safeUp()
          {
              $this->createTable('news', [
                  'id' => $this->primaryKey(),
                  'title' => $this->string()->notNull(),
                  'content' => $this->text(),
              ]);

              $this->insert('news', [
                  'title' => 'test 1',
                  'content' => 'content 1',
              ]);
          }

          public function safeDown()
          {
              $this->delete('news', ['id' => 1]);
              $this->dropTable('news');
          }
      }


    
    DATABASE ACESSING METHODS
    -execute(): executing a SQL statement
    -insert(): inserting a single row
    -batchInsert(): inserting multiple rows
    -update(): updating rows
    -upsert(): inserting a single row or updating it if it exists (since 2.0.14)
    -delete(): deleting rows
    -createTable(): creating a table
    -renameTable(): renaming a table
    -dropTable(): removing a table
    -truncateTable(): removing all rows in a table
    -addColumn(): adding a column
    -renameColumn(): renaming a column
    -dropColumn(): removing a column
    -alterColumn(): altering a column
    -addPrimaryKey(): adding a primary key
    -dropPrimaryKey(): removing a primary key
    -addForeignKey(): adding a foreign key
    -dropForeignKey(): removing a foreign key
    -createIndex(): creating an index
    -dropIndex(): removing an index
    -addCommentOnColumn(): adding comment to column
    -dropCommentFromColumn(): dropping comment from column
    -addCommentOnTable(): adding comment to table
    -dropCommentFromTable(): dropping comment from table



    para aplicar as migrations só dar migrate
      yii migrate
        ou
      php yii migrate


    podemos escolher numero de migrations para se fazer também
      yii migrate 3 (migra 3 tables só e assim vai indo)

    para reverter as migrations temos outros comandos
    REVERTING MIGRATIONS
      yii migrate/down     # revert the most recently applied migration
      yii migrate/down 3   # revert the most 3 recently applied migrations

    nem todas são reversiveis, ainda mais trabalhando com banco relacional,
    então tem que tomar cuidado.


    tambḿe podemos reverter as migrations e upar novamente no banco
    com REDOING MIGRATIONS
      yii migrate/redo        # redo the last applied migration
      yii migrate/redo 3      # redo the last 3 applied migrations

    
    REFRESHING MIGRATIONS
      praticamente deleta todas tables e foreign keys. e aplica tudo novamente do inicio
      yii migrate/fresh       # truncate the database and apply all migrations from the beginning
    
    
    LISTAR MIGRATIONS
      yii migrate/history     # showing the last 10 applied migrations
      yii migrate/history 5   # showing the last 5 applied migrations
      yii migrate/history all # showing all applied migrations

      yii migrate/new         # showing the first 10 new migrations
      yii migrate/new 5       # showing the first 5 new migrations
      yii migrate/new all     # showing all new migrations
    
    
    podemos modificar a history da migration(timestamp) ao invés
    de refaze-la para criar outra timestamp, no caso de atualizar a migration etc.

    yii migrate/mark 150101_185401                      # using timestamp to specify the migration
    yii migrate/mark "2015-01-01 18:54:01"              # using a string that can be parsed by strtotime()
    yii migrate/mark m150101_185401_create_news_table   # using full name
    yii migrate/mark 1392853618                         # using UNIX timestamp


    Podemos personalizar migration nas configs
    -customizar/namespace/component/commandline/

    MIGRATING MULTIPLE DATABASES
      ... existe esta opção


 
  ==========================================
    # COLETANDO DADOS DE USUARIOS

    Active Record based forms.
    aqui criamos um model

    <?php

    class LoginForm extends \yii\base\Model
    {
        public $username;
        public $password;

        public function rules()
        {
            return [
                // define validation rules here
            ];
        }
    }


    já temos exemlo no loginForm e SiteController, e outros tipos para criar forms
    
    // a password input
    <?= $form->field($model, 'password')->passwordInput() ?>
    // adding a hint and a customized label
    <?= $form->field($model, 'username')->textInput()->hint('Please enter your name')->label('Name') ?>
    // creating a HTML5 email input element
    <?= $form->field($model, 'email')->input('email') ?>

    // allow multiple files to be uploaded:
    echo $form->field($model, 'uploadFile[]')->fileInput(['multiple'=>'multiple']);

    // allow multiple items to be checked:
    echo $form->field($model, 'items[]')->checkboxList(['a' => 'Item A', 'b' => 'Item B', 'c' => 'Item C']);


    Criando Listas.
    -Dropdown list
    -Radio lists
    -Checkbox lists

      $items = [
        1 => 'item 1', 
        2 => 'item 2'
      ] 

      $items = Category::find()
          ->select(['label'])
          ->indexBy('id')
          ->column();

    temos dropdowns
    /* @var $form yii\widgets\ActiveForm */

    echo $form->field($model, 'category')->dropdownList([
            1 => 'item 1', 
            2 => 'item 2'
        ],
        ['prompt'=>'Select Category']
    );

    --radiolist
    /* @var $form yii\widgets\ActiveForm */

    echo $form->field($model, 'category')->radioList([
        1 => 'radio 1', 
        2 => 'radio 2'
    ]);

    --checkboxList
    /* @var $form yii\widgets\ActiveForm */

    echo $form->field($model, 'category')->checkboxList([
        1 => 'checkbox 1', 
        2 => 'checkbox 2'
    ]);


    PJAX é tipo ajax, so que com forms, envia o form e retorna já a resposta sem
    dar o refresh na página.

    use yii\widgets\Pjax;
    use yii\widgets\ActiveForm;

    Pjax::begin([
        // Pjax options
    ]);
        $form = ActiveForm::begin([
            'options' => ['data' => ['pjax' => true]],
            // more ActiveForm options
        ]);

            // ActiveForm content

        ActiveForm::end();
    Pjax::end();

    Tip: Be careful with the links inside the Pjax widget since the 
    response will also be rendered inside the widget. To prevent this, 
    use the data-pjax="0" HTML attribute.


    VALIDANDO DADOS

    validamos input principalmente pelo model, com validate()
    $model = new \app\models\ContactForm();

    // populate model attributes with user inputs
    $model->load(\Yii::$app->request->post());
    // which is equivalent to the following:
    // $model->attributes = \Yii::$app->request->post('ContactForm');

    if ($model->validate()) {
        // all inputs are valid
    } else {
        // validation failed: $errors is an array containing error messages
        $errors = $model->errors;
    }

    junto com rules()
    public function rules()
    {
        return [
            // the name, email, subject and body attributes are required
            [['name', 'email', 'subject', 'body'], 'required'],

            // the email attribute should be a valid email address
            ['email', 'email'],
        ];
    }


    e essas rules vão retornra um 'array of rules'. formato de array.

    CUSTOMIZING ERROR MESSAGES
 
      dentro do array de rules temos um array->array, com key=>value
      ['message'=>'custom_message']

      public function rules()
      {
          return [
              ['username', 'required', 'message' => 'Please choose a username.'],
          ];
      }


      para quase tudo no framework temos eventos, validation também tem eventos.
      -beforeValidate()
      -afterValidate()
      como se fosse o life cicle mesmo.

      CONDITIONAL VALIDATON
        também temos dentro da validate() esta opção caso usemos.
        ['state', 'required', 'when' => function($model) {
            return $model->country == 'USA';
        }]

      podemos utilizar o trim()[tira os espaços brancos do input]
      dentro do validate, default() nao tenho certeza se vem com espaço em branco.

        return [
            [['username', 'email'], 'trim'],
            [['username', 'email'], 'default'],
        ];


      ----------------------------------------
      Aqui temos mais uma regrinha de validação
        ['age', 'trim'],
        ['age', 'default', 'value' => null],
        ['age', 'integer', 'min' => 0],
        ['age', 'filter', 'filter' => 'intval', 'skipOnEmpty' => true],

      empty inputs, preisam ser null para entra na database, caso precise ter o valor
      depois,
      skipOnEmpty, não vai colocar nada se o valor for vazio.

      ---------------------------------------
      HANDLING EMPTY INPUTS 

      por default, é uma emptystring, ou empty array ou null.

        return [
            // set "username" and "email" as null if they are empty
            [['username', 'email'], 'default'],

            // set "level" to be 1 if it is empty
            ['level', 'default', 'value' => 1],
        ];
    ------------------------------------------------------------------------
         ['agree', 'required', 'isEmpty' => function ($value) {
            return empty($value);
         }]

      podemos também nas validate, colocar um default value caso seja vazio. no caso
      em cima.

    ---------------

    AD HOC validation
      quando não temos a validação no model, podemos utilizar algumas já prontas
      no caso o do emailValidator()

      $email = 'test@example.com';
      $validator = new yii\validators\EmailValidator();

      if ($validator->validate($email, $error)) {
          echo 'Email is valid.';
      } else {
          echo $error;
      }
      
    -------------------------------


    Multiple Validations against several values.
    utilizamos o DynamicModel::
      public function actionSearch($name, $email)
      {
          $model = DynamicModel::validateData(['name' => $name, 'email' => $email], [
              [['name', 'email'], 'string', 'max' => 128],
              ['email', 'email'],
          ]);

          if ($model->hasErrors()) {
              // validation fails
          } else {
              // validation succeeds
          }
      }

      Dynamic model é possivel criar rules/validation como classe,
      por exemplo em um método da classe.

      public function actionSearch($name, $email)
      {
          $model = new DynamicModel(['name' => $name, 'email' => $email]);
          $model->addRule(['name', 'email'], 'string', ['max' => 128])
              ->addRule('email', 'email')
              ->validate();

          if ($model->hasErrors()) {
              // validation fails
          } else {
              // validation succeeds
          }
      }


  ---------------------------------------
  existem também INLINE-validator, caso colocamos mais condições na rules..
  STANDALONE sobreescreve a validação, com alguma condição, parecido com inline.
  utilizamos o addError() também.


  aqui temos exemplo validando sem pegar do model, praticamente cria as variáveis
  dentro da própria classe e utiliza elas.
  -----------------------------------------
  namespace app\models;

    use Yii;
    use yii\base\Model;
    use app\components\validators\CountryValidator;

    class EntryForm extends Model
    {
        public $name;
        public $email;
        public $country;

        public function rules()
        {
            return [
                [['name', 'email'], 'required'],
                ['country', CountryValidator::className()],
                ['email', 'email'],
            ];
        }
    }
  -----------------------------------------

  MULTIPLE ATTRIBUTES..
    no caso temos constantes na classe e utilizamos elas dentro do validator.
    -----------------------------------------
    class MigrationForm extends \yii\base\Model
    {
        /**
        * Minimal funds amount for one adult person
        */
        const MIN_ADULT_FUNDS = 3000;
        /**
        * Minimal funds amount for one child
        */
        const MIN_CHILD_FUNDS = 1500;

        public $personalSalary;
        public $spouseSalary;
        public $childrenCount;
        public $description;

        public function rules()
        {
            return [
                [['personalSalary', 'description'], 'required'],
                [['personalSalary', 'spouseSalary'], 'integer', 'min' => self::MIN_ADULT_FUNDS],
                ['childrenCount', 'integer', 'min' => 0, 'max' => 5],
                [['spouseSalary', 'childrenCount'], 'default', 'value' => 0],
                ['description', 'string'],
            ];
        }
    }
    -----------------------------------------


    Podemos CRIAR nosso próprio validator. um pouco complexo.
    doc: https://www.yiiframework.com/doc/guide/2.0/pt-br/input-validation

    ---------------------

    Com a funcionalidade do addError() podemos colocar erros de validação
    para várias variáveis em comum. exemplo:

    Nesse caso, simplesmente adicionamos a validação naquela variável. no caso
      poderia vir de um formulário ou coisa parecida.
        $this->addError('childrenCount', 'Your salary is not enough for children.');

    Podemos fazer desta forma também, para múltiplos campos/vars.
        $message = 'Your salary is not enough for children.';
        $this->addError('personalSalary', $message);
        $this->addError('wifeSalary', $message);
        $this->addError('childrenCount', $message);

    Ou quando existem muitas variáveis, é melhor fazer isto dentro do laço de repetição.
        $attributes = ['personalSalary', 'wifeSalary', 'childrenCount'];
        foreach ($attributes as $attribute) {
            $this->addError($attribute, 'Your salary is not enough for children.');
        }

    Também funciona o all(*), adiciona esse erro pra todos campos.
      $this->addError('*', 'Your salary is not enough for children.');


    fazendo deste jeito, os forms na VIEW ficam mais enxutos.
      <?= $form->errorSummary($model) ?>




    CLIENT-SIDE VALIDATION  
      são feito pelo model RULES() no backend.
      do frontend temos o validate() para os campos do formulários.

      aqui o exemplo de rules client-side.
      --------------------------------------------------
        namespace app\models;

        use yii\base\Model;
        use app\models\User;

        class LoginForm extends Model
        {
            public $username;
            public $password;

            public function rules()
            {
                return [
                    // username and password are both required
                    [['username', 'password'], 'required'],

                    // password is validated by validatePassword()
                    ['password', 'validatePassword'],
                ];
            }

            public function validatePassword()
            {
                $user = User::findByUsername($this->username);

                if (!$user || !$user->validatePassword($this->password)) {
                    $this->addError('password', 'Incorrect username or password.');
                }
            }
        }
      --------------------------------------------------


      Temos Client-Side Validation, com validator também.
      outra coisa mais complexa que não entendi porque utilizar validator no backend.
      mas caso precise, está na documentação.
       https://www.yiiframework.com/doc/guide/2.0/pt-br/input-validation

      --------------------------------------------------


      DEFERRED VALIDATION
        com async (ajax validation) mais complexo também, tem na doc.
      
      AJAX Validation
        para isto é preciso dar um enable, porque já é setado como false.
        podemos fazer para um form ou para todos.

      -form específico
      ---------------------------------
      use yii\widgets\ActiveForm;

      $form = ActiveForm::begin([
          'id' => 'registration-form',
      ]);

      echo $form->field($model, 'username', ['enableAjaxValidation' => true]);

      // ...

      ActiveForm::end();
      ---------------------------------

      -all forms
      ---------------------------------
      $form = ActiveForm::begin([
          'id' => 'contact-form',
          'enableAjaxValidation' => true,
      ]);
    

  RECEBENDO ARQUIVOS(UPLOAD)
    já vimos acima lago parecido no formulário.
    depois de feitas as rules pleo model, podemos ter a function de upload()
    caso exista um upload, vai criar na root folder a pasta de uploads.
    exemplo do código:

    --------------------------------------
    namespace app\models;

    use yii\base\Model;
    use yii\web\UploadedFile;

    class UploadForm extends Model
    {
        /**
        * @var UploadedFile
        */
        public $imageFile;

        public function rules()
        {
            return [
                [['imageFile'], 'file', 'skipOnEmpty' => false, 'extensions' => 'png, jpg'],
            ];
        }
        
        public function upload()
        {
            if ($this->validate()) {
                $this->imageFile->saveAs('uploads/' . $this->imageFile->baseName . '.' . $this->imageFile->extension);
                return true;
            } else {
                return false;
            }
        }
    }    

    --------------------------------------

    temos o fileValidator
    https://www.yiiframework.com/doc/api/2.0/yii-validators-filevalidator

    ------------------------------------

    Na VIEW temos este formulário feito por widgets com active form
    <?php
      use yii\widgets\ActiveForm;
      ?>

      <?php $form = ActiveForm::begin(['options' => ['enctype' => 'multipart/form-data']]) ?>

          <?= $form->field($model, 'imageFile')->fileInput() ?>

          <button>Submit</button>

      <?php ActiveForm::end() ?>

    --------------------------------------------

    Já no controller temos isto aqui.

    namespace app\controllers;

    use Yii;
    use yii\web\Controller;
    use app\models\UploadForm;
    use yii\web\UploadedFile;

    class SiteController extends Controller
    {
        public function actionUpload()
        {
            $model = new UploadForm();

            if (Yii::$app->request->isPost) {
                $model->imageFile = UploadedFile::getInstance($model, 'imageFile');
                if ($model->upload()) {
                    // file is uploaded successfully
                    return;
                }
            }

            return $this->render('upload', ['model' => $model]);
        }
    }

  ---------------------------------------------

  pegamos do model no controller o form de upload.

  Para fazer multiple uploads é um pocuo diferente, temos ainda as mesmas rules.
  porém no upload, temos que validar, e salvamos as files dentro do loop foreach. 
  segue em seguinte.

  ------------------------
  namespace app\models;

  use yii\base\Model;
  use yii\web\UploadedFile;

  class UploadForm extends Model
  {
      /**
      * @var UploadedFile[]
      */
      public $imageFiles;

      public function rules()
      {
          return [
              [['imageFiles'], 'file', 'skipOnEmpty' => false, 'extensions' => 'png, jpg', 'maxFiles' => 4],
          ];
      }
      
      public function upload()
      {
          if ($this->validate()) { 
              foreach ($this->imageFiles as $file) {
                  $file->saveAs('uploads/' . $file->baseName . '.' . $file->extension);
              }
              return true;
          } else {
              return false;
          }
      }
    }

  --------------------------------------------------
  
  na VIEW, precisamos colocar a opção para multiple files, no file input.
  vai salvar como array, fileInput->multiple, e imagesFIles[] como array.
  praticamente isto.

  ----------------------------
  <?php
    use yii\widgets\ActiveForm;
    ?>

    <?php $form = ActiveForm::begin(['options' => ['enctype' => 'multipart/form-data']]) ?>

        <?= $form->field($model, 'imageFiles[]')->fileInput(['multiple' => true, 'accept' => 'image/*']) ?>

        <button>Submit</button>

  <?php ActiveForm::end() ?>
  ----------------------------

  Agora no controller , muda o getInstace, para getInstances. na uploadFile
  e o UploadForm é imagesFiles, que armazena todas files.

  -----------------------------------------
  namespace app\controllers;

    use Yii;
    use yii\web\Controller;
    use app\models\UploadForm;
    use yii\web\UploadedFile;

    class SiteController extends Controller
    {
        public function actionUpload()
        {
            $model = new UploadForm();

            if (Yii::$app->request->isPost) {
                $model->imageFiles = UploadedFile::getInstances($model, 'imageFiles');
                if ($model->upload()) {
                    // file is uploaded successfully
                    return;
                }
            }

            return $this->render('upload', ['model' => $model]);
        }
    }

  ---------------------------------------

  COLLECTING TABULAR INPUT
    isso acontece quando temos multiplos models do mesmo tipo, em um único formulário.
    geralmente é feito isso com settings dentro do banco de dados.
    https://www.yiiframework.com/doc/guide/2.0/pt-br/input-tabular-input

  ------------------------------------------

  GETTING DATA FOR MULTIPLE MODELS
    Aqui também, quando temos multiplos models com informações complexas
    de outros banco de dados e não somente o mesmo. Docs
    https://www.yiiframework.com/doc/guide/2.0/pt-br/input-multiple-models

  ------------------------------------------

  EXTENDING ACTIVEFORM ON THE CLIENT SIDE
    aqui podemos utilizar dos EVENTS no active form. no caso, verificação de mensagem
    se desejos realmente enviar os dados, confirmação de envio etc.

    $('#contact-form').on('beforeSubmit', function (e) {
      if (!confirm("Everything is correct. Submit?")) {
        return false;
      }
      return true;
    });

    aqui parece um código jquery, antes de enviar o formulário, confirmamos com uma
    mensagem se tudo está correto, se for, avança ou cancela a ação.


    Então temos a explicação do life cicle, com
    doc(https://www.yiiframework.com/doc/guide/2.0/pt-br/input-form-javascript)
    -beforeValidate
    -afterValidate
    -beforeValidateAttribute
    -afterValidateAttribute
    -beforeSubmit
    -ajaxBeforeSend
    -ajaxComplete(quando completa a req ajax)

    
    que é parecido com os eventos de segurança de autenticação.

    aqui temos um form ajax padrão normal
    -------------------------------------------
    var $form = $('#formId');
    $form.on('beforeSubmit', function() {
        var data = $form.serialize();
        $.ajax({
            url: $form.attr('action'),
            type: 'POST',
            data: data,
            success: function (data) {
                // Implement successful
            },
            error: function(jqXHR, errMsg) {
                alert(errMsg);
            }
        });
        return false; // prevent default submit
    });
    -------------------------------------------

    temos como adicionar dinamicamente também, não entendi mt bem.
    https://www.yiiframework.com/doc/guide/2.0/pt-br/input-form-javascripts
    

  ==========================================
    # EXIBINDO DADOS

    



  ==========================================
    # SEGURANÇA

      !!AUTENTICAÇÃO!!(https://www.yiiframework.com/doc/guide/2.0/pt-br/security-authentication)
      
      processo de verificação de identidade do usuário, nome/token/etc
      ---yii\web\user 

            return [
            'components' => [
                'user' => [
                    'identityClass' => 'app\models\User',
                ],
            ],
        ];

      no caso precisamos da getAuthKey() e validateAuthKey(), para validar usuario, porém
      neste link temos outros métodos, e também se gravamos em cookie o user.

      Para logar um usuário, você pode usar o seguinte código:

      // encontrar uma identidade de usuário com o nome de usuário especificado.
      // observe que você pode querer checar a senha se necessário
      $identity = User::findOne(['username' => $username]);

      // logar o usuário
      Yii::$app->user->login($identity);

      Para realizar o logout de um usuário, simplesmente chame:

      Yii::$app->user->logout();

      ele também destruirá todos os dados da sessão do usuário. 
      Se você quiser guardar os dados da sessão, você deve chamar 
      Yii::$app->user->logout(false).

      existe também EVENTOS para autenticação
      EVENT_BEFORE_LOGIN
      EVENT_AFTER_LOGIN
      EVENT_BEFORE_LOGOUT
      EVENT_AFTER_LOGOUT
    


    !!AUTORIZAÇÃO!! (https://www.yiiframework.com/doc/guide/2.0/pt-br/security-authorization)

    verifica se o user tem permissão para fazer algo dentro da app.
    oferece o Filtro de Controle de Acesso(ACF) e Controle de Acesso Baseado em Role (RBAC)

    ACF apenas no controller, varias rules, e permissões que o usuário poderá fazer.
    behaviors = comportamento

    use yii\web\Controller;
    use yii\filters\AccessControl;

    class SiteController extends Controller
    {
      public function behaviors()
      {
          return [
              'access' => [
                  'class' => AccessControl::className(),
                  'only' => ['login', 'logout', 'signup'],
                  'rules' => [
                      [
                          'allow' => true,
                          'actions' => ['login', 'signup'],
                          'roles' => ['?'],
                      ],
                      [
                          'allow' => true,
                          'actions' => ['logout'],
                          'roles' => ['@'],
                      ],
                  ],
              ],
          ];
      }
      // ...
    }


    deny callbacks

      [
    'class' => AccessControl::className(),
    ...
    'denyCallback' => function ($rule, $action) {
        throw new \Exception('Você não está autorizado a acessar esta página');
        }
      ]

    
    temos um exemplo também de matchCallBack, lógica de validação de acesso,
    no caso, uma página disponível somente em uma certa data.

    use yii\filters\AccessControl;

    class SiteController extends Controller
    {
      public function behaviors()
      {
          return [
              'access' => [
                  'class' => AccessControl::className(),
                  'only' => ['special-callback'],
                  'rules' => [
                      [
                          'actions' => ['special-callback'],
                          'allow' => true,
                          'matchCallback' => function ($rule, $action) {
                              return date('d-m') === '31-10';
                          }
                      ],
                  ],
              ],
          ];
      }

      // Match callback chamada! Esta página pode ser acessado somente a cada 31 de outubro
      public function actionSpecialCallback()
      {
          return $this->render('happy-halloween');
      }
    }


    RBAC
      uma role representa coleção de permissão.(criar posts, atualizar posts etc);
      pode ser atribuída a um ou vários usuários.

  então temos a config do phpManager ou DbManager, que é feito pela config em components
  ++rbac (rolesPadrões);





